var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
window._p;
_p = window;
_p.gl;
_p.WebGLRenderingContext;
_p.DeviceOrientationEvent;
_p.DeviceMotionEvent;
_p.AudioContext;
_p.webkitAudioContext;
_p.mozAudioContext;
_p = Object.prototype;
_p._super;
_p.ctor;
delete window._p;
cc.newElement = function (x) {
    return document.createElement(x);
};
cc._addEventListener = function (element, type, listener, useCapture) {
    element.addEventListener(type, listener, useCapture);
};
cc._isNodeJs = typeof require !== 'undefined' && require("fs");
cc.each = function (obj, iterator, context) {
    if (!obj)
        return;
    if (obj instanceof Array) {
        for (var i = 0, li = obj.length; i < li; i++) {
            if (iterator.call(context, obj[i], i) === false)
                return;
        }
    } else {
        for (var key in obj) {
            if (iterator.call(context, obj[key], key) === false)
                return;
        }
    }
};
cc.extend = function(target) {
    var sources = arguments.length >= 2 ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(sources, function(src) {
        for(var key in src) {
            if (src.hasOwnProperty(key)) {
                target[key] = src[key];
            }
        }
    });
    return target;
};
cc.isFunction = function(obj) {
    return typeof obj == 'function';
};
cc.isNumber = function(obj) {
    return typeof obj == 'number' || Object.prototype.toString.call(obj) == '[object Number]';
};
cc.isString = function(obj) {
    return typeof obj == 'string' || Object.prototype.toString.call(obj) == '[object String]';
};
cc.isArray = function(obj) {
    return Object.prototype.toString.call(obj) == '[object Array]';
};
cc.isUndefined = function(obj) {
    return typeof obj == 'undefined';
};
cc.isObject = function(obj) {
    var type = typeof obj;
    return type == 'function' || (obj && type == 'object');
};
cc.isCrossOrigin = function (url) {
    if (!url) {
        cc.log("invalid URL");
        return false;
    }
    var startIndex = url.indexOf("://");
    if (startIndex == -1)
        return false;
    var endIndex = url.indexOf("/", startIndex + 3);
    var urlOrigin = (endIndex == -1) ? url : url.substring(0, endIndex);
    return urlOrigin != location.origin;
};
cc.AsyncPool = function(srcObj, limit, iterator, onEnd, target){
    var self = this;
    self._srcObj = srcObj;
    self._limit = limit;
    self._pool = [];
    self._iterator = iterator;
    self._iteratorTarget = target;
    self._onEnd = onEnd;
    self._onEndTarget = target;
    self._results = srcObj instanceof Array ? [] : {};
    self._isErr = false;
    cc.each(srcObj, function(value, index){
        self._pool.push({index : index, value : value});
    });
    self.size = self._pool.length;
    self.finishedSize = 0;
    self._workingSize = 0;
    self._limit = self._limit || self.size;
    self.onIterator = function(iterator, target){
        self._iterator = iterator;
        self._iteratorTarget = target;
    };
    self.onEnd = function(endCb, endCbTarget){
        self._onEnd = endCb;
        self._onEndTarget = endCbTarget;
    };
    self._handleItem = function(){
        var self = this;
        if(self._pool.length == 0)
            return;
        if(self._workingSize >= self._limit)
            return;
        var item = self._pool.shift();
        var value = item.value, index = item.index;
        self._workingSize++;
        self._iterator.call(self._iteratorTarget, value, index, function(err){
            if(self._isErr)
                return;
            self.finishedSize++;
            self._workingSize--;
            if(err) {
                self._isErr = true;
                if(self._onEnd)
                    self._onEnd.call(self._onEndTarget, err);
                return;
            }
            var arr = Array.prototype.slice.call(arguments, 1);
            self._results[this.index] = arr[0];
            if(self.finishedSize == self.size) {
                if(self._onEnd)
                    self._onEnd.call(self._onEndTarget, null, self._results);
                return;
            }
            self._handleItem();
        }.bind(item), self);
    };
    self.flow = function(){
        var self = this;
        if(self._pool.length == 0) {
            if(self._onEnd)
                self._onEnd.call(self._onEndTarget, null, []);
                return;
        }
        for(var i = 0; i < self._limit; i++)
            self._handleItem();
    }
};
cc.async = {
    series : function(tasks, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, 1, function(func, index, cb1){
            func.call(target, cb1);
        }, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    parallel : function(tasks, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, 0, function(func, index, cb1){
            func.call(target, cb1);
        }, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    waterfall : function(tasks, cb, target){
        var args = [];
        var lastResults = [null];//the array to store the last results
        var asyncPool = new cc.AsyncPool(tasks, 1,
            function (func, index, cb1) {
                args.push(function (err) {
                    args = Array.prototype.slice.call(arguments, 1);
                    if(tasks.length - 1 == index) lastResults = lastResults.concat(args);//while the last task
                    cb1.apply(null, arguments);
                });
                func.apply(target, args);
            }, function (err) {
                if (!cb)
                    return;
                if (err)
                    return cb.call(target, err);
                cb.apply(target, lastResults);
            });
        asyncPool.flow();
        return asyncPool;
    },
    map : function(tasks, iterator, cb, target){
        var locIterator = iterator;
        if(typeof(iterator) == "object"){
            cb = iterator.cb;
            target = iterator.iteratorTarget;
            locIterator = iterator.iterator;
        }
        var asyncPool = new cc.AsyncPool(tasks, 0, locIterator, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    mapLimit : function(tasks, limit, iterator, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, limit, iterator, cb, target);
        asyncPool.flow();
        return asyncPool;
    }
};
cc.path = {
    join: function () {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) {
            result = (result + (result == "" ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        }
        return result;
    },
    extname: function (pathStr) {
        var temp = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(pathStr);
        return temp ? temp[1] : null;
    },
    mainFileName: function(fileName){
        if(fileName){
           var idx = fileName.lastIndexOf(".");
            if(idx !== -1)
               return fileName.substring(0,idx);
        }
        return fileName;
    },
    basename: function (pathStr, extname) {
        var index = pathStr.indexOf("?");
        if (index > 0) pathStr = pathStr.substring(0, index);
        var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
        if (!result) return null;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() == extname.toLowerCase())
            return baseName.substring(0, baseName.length - extname.length);
        return baseName;
    },
    dirname: function (pathStr) {
        return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, '$2');
    },
    changeExtname: function (pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
    },
    changeBasename: function (pathStr, basename, isSameExt) {
        if (basename.indexOf(".") == 0) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
    }
};
cc.loader = {
    _jsCache: {},//cache for js
    _register: {},//register of loaders
    _langPathCache: {},//cache for lang path
    _aliases: {},//aliases for res url
    resPath: "",//root path of resource
    audioPath: "",//root path of audio
    cache: {},//cache for data loaded
    getXMLHttpRequest: function () {
        return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    },
    _getArgs4Js: function (args) {
        var a0 = args[0], a1 = args[1], a2 = args[2], results = ["", null, null];
        if (args.length === 1) {
            results[1] = a0 instanceof Array ? a0 : [a0];
        } else if (args.length === 2) {
            if (typeof a1 == "function") {
                results[1] = a0 instanceof Array ? a0 : [a0];
                results[2] = a1;
            } else {
                results[0] = a0 || "";
                results[1] = a1 instanceof Array ? a1 : [a1];
            }
        } else if (args.length === 3) {
            results[0] = a0 || "";
            results[1] = a1 instanceof Array ? a1 : [a1];
            results[2] = a2;
        } else throw "arguments error to load js!";
        return results;
    },
    loadJs: function (baseDir, jsList, cb) {
        var self = this, localJsCache = self._jsCache,
            args = self._getArgs4Js(arguments);
        var preDir = args[0], list = args[1], callback = args[2];
        if (navigator.userAgent.indexOf("Trident/5") > -1) {
            self._loadJs4Dependency(preDir, list, 0, callback);
        } else {
            cc.async.map(list, function (item, index, cb1) {
                var jsPath = cc.path.join(preDir, item);
                if (localJsCache[jsPath]) return cb1(null);
                self._createScript(jsPath, false, cb1);
            }, callback);
        }
    },
    loadJsWithImg: function (baseDir, jsList, cb) {
        var self = this, jsLoadingImg = self._loadJsImg(),
            args = self._getArgs4Js(arguments);
        this.loadJs(args[0], args[1], function (err) {
            if (err) throw err;
            jsLoadingImg.parentNode.removeChild(jsLoadingImg);//remove loading gif
            if (args[2]) args[2]();
        });
    },
    _createScript: function (jsPath, isAsync, cb) {
        var d = document, self = this, s = cc.newElement('script');
        s.async = isAsync;
        s.src = jsPath;
        self._jsCache[jsPath] = true;
        cc._addEventListener(s, 'load', function () {
            s.parentNode.removeChild(s);
            this.removeEventListener('load', arguments.callee, false);
            cb();
        }, false);
        cc._addEventListener(s, 'error', function () {
            s.parentNode.removeChild(s);
            cb("Load " + jsPath + " failed!");
        }, false);
        d.body.appendChild(s);
    },
    _loadJs4Dependency: function (baseDir, jsList, index, cb) {
        if (index >= jsList.length) {
            if (cb) cb();
            return;
        }
        var self = this;
        self._createScript(cc.path.join(baseDir, jsList[index]), false, function (err) {
            if (err) return cb(err);
            self._loadJs4Dependency(baseDir, jsList, index + 1, cb);
        });
    },
    _loadJsImg: function () {
        var d = document, jsLoadingImg = d.getElementById("cocos2d_loadJsImg");
        if (!jsLoadingImg) {
            jsLoadingImg = cc.newElement('img');
            if (cc._loadingImage)
                jsLoadingImg.src = cc._loadingImage;
            var canvasNode = d.getElementById(cc.game.config["id"]);
            canvasNode.style.backgroundColor = "black";
            canvasNode.parentNode.appendChild(jsLoadingImg);
            var canvasStyle = getComputedStyle ? getComputedStyle(canvasNode) : canvasNode.currentStyle;
            if (!canvasStyle)
                canvasStyle = {width: canvasNode.width, height: canvasNode.height};
            jsLoadingImg.style.left = canvasNode.offsetLeft + (parseFloat(canvasStyle.width) - jsLoadingImg.width) / 2 + "px";
            jsLoadingImg.style.top = canvasNode.offsetTop + (parseFloat(canvasStyle.height) - jsLoadingImg.height) / 2 + "px";
            jsLoadingImg.style.position = "absolute";
        }
        return jsLoadingImg;
    },
    loadTxt: function (url, cb) {
        if (!cc._isNodeJs) {
            var xhr = this.getXMLHttpRequest(),
                errInfo = "load " + url + " failed!";
            xhr.open("GET", url, true);
            if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                xhr.setRequestHeader("Accept-Charset", "utf-8");
                xhr.onreadystatechange = function () {
                    if(xhr.readyState == 4)
                        xhr.status == 200 ? cb(null, xhr.responseText) : cb(errInfo);
                };
            } else {
                if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=utf-8");
                xhr.onload = function () {
                    if(xhr.readyState == 4)
                        xhr.status == 200 ? cb(null, xhr.responseText) : cb(errInfo);
                };
            }
            xhr.send(null);
        } else {
            var fs = require("fs");
            fs.readFile(url, function (err, data) {
                err ? cb(err) : cb(null, data.toString());
            });
        }
    },
    _loadTxtSync: function (url) {
        if (!cc._isNodeJs) {
            var xhr = this.getXMLHttpRequest();
            xhr.open("GET", url, false);
            if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                xhr.setRequestHeader("Accept-Charset", "utf-8");
            } else {
                if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=utf-8");
            }
            xhr.send(null);
            if (!xhr.readyState == 4 || xhr.status != 200) {
                return null;
            }
            return xhr.responseText;
        } else {
            var fs = require("fs");
            return fs.readFileSync(url).toString();
        }
    },
    loadCsb: function(url, cb){
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            var arrayBuffer = xhr.response;
            if (arrayBuffer) {
                window.msg = arrayBuffer;
            }
            if(xhr.readyState == 4)
                xhr.status == 200 ? cb(null, xhr.response) : cb("load " + url + " failed!");
        };
        xhr.send(null);
    },
    loadJson: function (url, cb) {
        this.loadTxt(url, function (err, txt) {
            try {
                err ? cb(err) : cb(null, JSON.parse(txt));
            } catch (e) {
                throw "load json [" + url + "] failed : " + e;
            }
        });
    },
    _checkIsImageURL: function (url) {
        var ext = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(url);
        return (ext != null);
    },
    loadImg: function (url, option, cb) {
        var opt = {
            isCrossOrigin: true
        };
        if (cb !== undefined)
            opt.isCrossOrigin = option.isCrossOrigin == null ? opt.isCrossOrigin : option.isCrossOrigin;
        else if (option !== undefined)
            cb = option;
        var img = new Image();
        if (opt.isCrossOrigin && location.origin != "file://")
            img.crossOrigin = "Anonymous";
        var lcb = function () {
            this.removeEventListener('load', lcb, false);
            this.removeEventListener('error', ecb, false);
            if (cb)
                cb(null, img);
        };
        var ecb = function () {
            this.removeEventListener('error', ecb, false);
            if(img.crossOrigin && img.crossOrigin.toLowerCase() == "anonymous"){
                opt.isCrossOrigin = false;
                cc.loader.loadImg(url, opt, cb);
            }else{
                typeof cb == "function" && cb("load image failed");
            }
        };
        cc._addEventListener(img, "load", lcb);
        cc._addEventListener(img, "error", ecb);
        img.src = url;
        return img;
    },
    _loadResIterator: function (item, index, cb) {
        var self = this, url = null;
        var type = item.type;
        if (type) {
            type = "." + type.toLowerCase();
            url = item.src ? item.src : item.name + type;
        } else {
            url = item;
            type = cc.path.extname(url);
        }
        var obj = self.cache[url];
        if (obj)
            return cb(null, obj);
        var loader = null;
        if (type) {
            loader = self._register[type.toLowerCase()];
        }
        if (!loader) {
            cc.error("loader for [" + type + "] not exists!");
            return cb();
        }
        var basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
        var realUrl = self.getUrl(basePath, url);
        loader.load(realUrl, url, item, function (err, data) {
            if (err) {
                cc.log(err);
                self.cache[url] = null;
                delete self.cache[url];
                cb();
            } else {
                self.cache[url] = data;
                cb(null, data);
            }
        });
    },
    getUrl: function (basePath, url) {
        var self = this, langPathCache = self._langPathCache, path = cc.path;
        if (basePath !== undefined && url === undefined) {
            url = basePath;
            var type = path.extname(url);
            type = type ? type.toLowerCase() : "";
            var loader = self._register[type];
            if (!loader)
                basePath = self.resPath;
            else
                basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
        }
        url = cc.path.join(basePath || "", url);
        if (url.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (langPathCache[url])
                return langPathCache[url];
            var extname = path.extname(url) || "";
            url = langPathCache[url] = url.substring(0, url.length - extname.length) + "_" + cc.sys.language + extname;
        }
        return url;
    },
    load : function(resources, option, cb){
        var self = this;
        var len = arguments.length;
        if(len == 0)
            throw "arguments error!";
        if(len == 3){
            if(typeof option == "function"){
                if(typeof cb == "function")
                    option = {trigger : option, cb : cb };
                else
                    option = { cb : option, cbTarget : cb};
            }
        }else if(len == 2){
            if(typeof option == "function")
                option = {cb : option};
        }else if(len == 1){
            option = {};
        }
        if(!(resources instanceof Array))
            resources = [resources];
        var asyncPool = new cc.AsyncPool(resources, 0, function(value, index, cb1, aPool){
            self._loadResIterator(value, index, function(err){
                if(err)
                    return cb1(err);
                var arr = Array.prototype.slice.call(arguments, 1);
                if(option.trigger)
                    option.trigger.call(option.triggerTarget, arr[0], aPool.size, aPool.finishedSize);
                cb1(null, arr[0]);
            });
        }, option.cb, option.cbTarget);
        asyncPool.flow();
        return asyncPool;
    },
    _handleAliases: function (fileNames, cb) {
        var self = this, aliases = self._aliases;
        var resList = [];
        for (var key in fileNames) {
            var value = fileNames[key];
            aliases[key] = value;
            resList.push(value);
        }
        this.load(resList, cb);
    },
    loadAliases: function (url, cb) {
        var self = this, dict = self.getRes(url);
        if (!dict) {
            self.load(url, function (err, results) {
                self._handleAliases(results[0]["filenames"], cb);
            });
        } else
            self._handleAliases(dict["filenames"], cb);
    },
    register: function (extNames, loader) {
        if (!extNames || !loader) return;
        var self = this;
        if (typeof extNames == "string")
            return this._register[extNames.trim().toLowerCase()] = loader;
        for (var i = 0, li = extNames.length; i < li; i++) {
            self._register["." + extNames[i].trim().toLowerCase()] = loader;
        }
    },
    getRes: function (url) {
        return this.cache[url] || this.cache[this._aliases[url]];
    },
    release: function (url) {
        var cache = this.cache, aliases = this._aliases;
        delete cache[url];
        delete cache[aliases[url]];
        delete aliases[url];
    },
    releaseAll: function () {
        var locCache = this.cache, aliases = this._aliases;
        for (var key in locCache)
            delete locCache[key];
        for (var key in aliases)
            delete aliases[key];
    }
};
cc.formatStr = function(){
    var args = arguments;
    var l = args.length;
    if(l < 1)
        return "";
    var str = args[0];
    var needToFormat = true;
    if(typeof str == "object"){
        needToFormat = false;
    }
    for(var i = 1; i < l; ++i){
        var arg = args[i];
        if(needToFormat){
            while(true){
                var result = null;
                if(typeof arg == "number"){
                    result = str.match(/(%d)|(%s)/);
                    if(result){
                        str = str.replace(/(%d)|(%s)/, arg);
                        break;
                    }
                }
                result = str.match(/%s/);
                if(result)
                    str = str.replace(/%s/, arg);
                else
                    str += "    " + arg;
                break;
            }
        }else
            str += "    " + arg;
    }
    return str;
};
(function () {
    var win = window, hidden, visibilityChange, _undef = "undefined";
    if (!cc.isUndefined(document.hidden)) {
        hidden = "hidden";
        visibilityChange = "visibilitychange";
    } else if (!cc.isUndefined(document.mozHidden)) {
        hidden = "mozHidden";
        visibilityChange = "mozvisibilitychange";
    } else if (!cc.isUndefined(document.msHidden)) {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
    } else if (!cc.isUndefined(document.webkitHidden)) {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
    }
    var onHidden = function () {
        if (cc.eventManager && cc.game._eventHide)
            cc.eventManager.dispatchEvent(cc.game._eventHide);
    };
    var onShow = function () {
        if (cc.eventManager && cc.game._eventShow)
            cc.eventManager.dispatchEvent(cc.game._eventShow);
        if(cc.game._intervalId){
            window.cancelAnimationFrame(cc.game._intervalId);
            cc.game._runMainLoop();
        }
    };
    if (hidden) {
        cc._addEventListener(document, visibilityChange, function () {
            if (document[hidden]) onHidden();
            else onShow();
        }, false);
    } else {
        cc._addEventListener(win, "blur", onHidden, false);
        cc._addEventListener(win, "focus", onShow, false);
    }
    if(navigator.userAgent.indexOf("MicroMessenger") > -1){
        win.onfocus = function(){ onShow() };
    }
    if ("onpageshow" in window && "onpagehide" in window) {
        cc._addEventListener(win, "pagehide", onHidden, false);
        cc._addEventListener(win, "pageshow", onShow, false);
    }
    win = null;
    visibilityChange = null;
})();
cc.log = cc.warn = cc.error = cc.assert = function () {
};
cc.create3DContext = function (canvas, opt_attribs) {
    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    var context = null;
    for (var ii = 0; ii < names.length; ++ii) {
        try {
            context = canvas.getContext(names[ii], opt_attribs);
        } catch (e) {
        }
        if (context) {
            break;
        }
    }
    return context;
};
cc._initSys = function (config, CONFIG_KEY) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    cc.sys = {};
    var sys = cc.sys;
    sys.LANGUAGE_ENGLISH = "en";
    sys.LANGUAGE_CHINESE = "zh";
    sys.LANGUAGE_FRENCH = "fr";
    sys.LANGUAGE_ITALIAN = "it";
    sys.LANGUAGE_GERMAN = "de";
    sys.LANGUAGE_SPANISH = "es";
    sys.LANGUAGE_DUTCH = "du";
    sys.LANGUAGE_RUSSIAN = "ru";
    sys.LANGUAGE_KOREAN = "ko";
    sys.LANGUAGE_JAPANESE = "ja";
    sys.LANGUAGE_HUNGARIAN = "hu";
    sys.LANGUAGE_PORTUGUESE = "pt";
    sys.LANGUAGE_ARABIC = "ar";
    sys.LANGUAGE_NORWEGIAN = "no";
    sys.LANGUAGE_POLISH = "pl";
    sys.OS_WINDOWS = "Windows";
    sys.OS_IOS = "iOS";
    sys.OS_OSX = "OS X";
    sys.OS_UNIX = "UNIX";
    sys.OS_LINUX = "Linux";
    sys.OS_ANDROID = "Android";
    sys.OS_UNKNOWN = "Unknown";
    sys.WINDOWS = 0;
    sys.LINUX = 1;
    sys.MACOS = 2;
    sys.ANDROID = 3;
    sys.IPHONE = 4;
    sys.IPAD = 5;
    sys.BLACKBERRY = 6;
    sys.NACL = 7;
    sys.EMSCRIPTEN = 8;
    sys.TIZEN = 9;
    sys.WINRT = 10;
    sys.WP8 = 11;
    sys.MOBILE_BROWSER = 100;
    sys.DESKTOP_BROWSER = 101;
    sys.BROWSER_TYPE_WECHAT = "wechat";
    sys.BROWSER_TYPE_ANDROID = "androidbrowser";
    sys.BROWSER_TYPE_IE = "ie";
    sys.BROWSER_TYPE_QQ = "qqbrowser";
    sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    sys.BROWSER_TYPE_UC = "ucbrowser";
    sys.BROWSER_TYPE_360 = "360browser";
    sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    sys.BROWSER_TYPE_BAIDU = "baidubrowser";
    sys.BROWSER_TYPE_MAXTHON = "maxthon";
    sys.BROWSER_TYPE_OPERA = "opera";
    sys.BROWSER_TYPE_OUPENG = "oupeng";
    sys.BROWSER_TYPE_MIUI = "miuibrowser";
    sys.BROWSER_TYPE_FIREFOX = "firefox";
    sys.BROWSER_TYPE_SAFARI = "safari";
    sys.BROWSER_TYPE_CHROME = "chrome";
    sys.BROWSER_TYPE_UNKNOWN = "unknown";
    sys.isNative = false;
    var browserSupportWebGL = [sys.BROWSER_TYPE_BAIDU, sys.BROWSER_TYPE_OPERA, sys.BROWSER_TYPE_FIREFOX, sys.BROWSER_TYPE_CHROME, sys.BROWSER_TYPE_SAFARI];
    var osSupportWebGL = [sys.OS_IOS, sys.OS_WINDOWS, sys.OS_OSX, sys.OS_LINUX];
    var multipleAudioWhiteList = [
        sys.BROWSER_TYPE_BAIDU, sys.BROWSER_TYPE_OPERA, sys.BROWSER_TYPE_FIREFOX, sys.BROWSER_TYPE_CHROME, sys.BROWSER_TYPE_BAIDU_APP,
        sys.BROWSER_TYPE_SAFARI, sys.BROWSER_TYPE_UC, sys.BROWSER_TYPE_QQ, sys.BROWSER_TYPE_MOBILE_QQ, sys.BROWSER_TYPE_IE
    ];
    var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
    var ua = nav.userAgent.toLowerCase();
    sys.isMobile = ua.indexOf('mobile') != -1 || ua.indexOf('android') != -1;
    sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
    var currLanguage = nav.language;
    currLanguage = currLanguage ? currLanguage : nav.browserLanguage;
    currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
    sys.language = currLanguage;
    var browserType = sys.BROWSER_TYPE_UNKNOWN;
    var browserTypes = ua.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i)
        || ua.match(/chrome|safari/i);
    if (browserTypes && browserTypes.length > 0) {
        browserType = browserTypes[0].toLowerCase();
        if (browserType == 'micromessenger') {
            browserType = sys.BROWSER_TYPE_WECHAT;
        } else if (browserType === "safari" && (ua.match(/android.*applewebkit/)))
            browserType = sys.BROWSER_TYPE_ANDROID;
        else if (browserType == "trident") browserType = sys.BROWSER_TYPE_IE;
    }
    sys.browserType = browserType;
    var iOS = ( ua.match(/(iPad|iPhone|iPod)/i) ? true : false );
    var isAndroid = ua.match(/android/i) || nav.platform.match(/android/i) ? true : false;
    var osName = sys.OS_UNKNOWN;
    if (nav.appVersion.indexOf("Win") != -1) osName = sys.OS_WINDOWS;
    else if (iOS) osName = sys.OS_IOS;
    else if (nav.appVersion.indexOf("Mac") != -1) osName = sys.OS_OSX;
    else if (nav.appVersion.indexOf("X11") != -1) osName = sys.OS_UNIX;
    else if (isAndroid) osName = sys.OS_ANDROID;
    else if (nav.appVersion.indexOf("Linux") != -1) osName = sys.OS_LINUX;
    sys.os = osName;
    sys._supportMultipleAudio = multipleAudioWhiteList.indexOf(sys.browserType) > -1;
    var userRenderMode = parseInt(config[CONFIG_KEY.renderMode]);
    var renderType = cc._RENDER_TYPE_WEBGL;
    var tempCanvas = cc.newElement("Canvas");
    cc._supportRender = true;
    var notSupportGL = !window.WebGLRenderingContext || browserSupportWebGL.indexOf(sys.browserType) == -1 || osSupportWebGL.indexOf(sys.os) == -1;
    if (userRenderMode === 1 || (userRenderMode === 0 && notSupportGL) || (location.origin == "file://")) {
        renderType = cc._RENDER_TYPE_CANVAS;
    }
    sys._canUseCanvasNewBlendModes = function(){
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        var context = canvas.getContext('2d');
        context.fillStyle = '#000';
        context.fillRect(0,0,1,1);
        context.globalCompositeOperation = 'multiply';
        var canvas2 = document.createElement('canvas');
        canvas2.width = 1;
        canvas2.height = 1;
        var context2 = canvas2.getContext('2d');
        context2.fillStyle = '#fff';
        context2.fillRect(0,0,1,1);
        context.drawImage(canvas2, 0, 0, 1, 1);
        return context.getImageData(0,0,1,1).data[0] === 0;
    };
    sys._supportCanvasNewBlendModes = sys._canUseCanvasNewBlendModes();
    if (renderType == cc._RENDER_TYPE_WEBGL) {
        if (!win.WebGLRenderingContext
            || !cc.create3DContext(tempCanvas, {'stencil': true, 'preserveDrawingBuffer': true })) {
            if (userRenderMode == 0) renderType = cc._RENDER_TYPE_CANVAS;
            else cc._supportRender = false;
        }
    }
    if (renderType == cc._RENDER_TYPE_CANVAS) {
        try {
            tempCanvas.getContext("2d");
        } catch (e) {
            cc._supportRender = false;
        }
    }
    cc._renderType = renderType;
    try {
        sys._supportWebAudio = !!(new (win.AudioContext || win.webkitAudioContext || win.mozAudioContext)());
    } catch (e) {
        sys._supportWebAudio = false;
    }
    try {
        var localStorage = sys.localStorage = win.localStorage;
        localStorage.setItem("storage", "");
        localStorage.removeItem("storage");
        localStorage = null;
    } catch (e) {
        if (e.name === "SECURITY_ERR" || e.name === "QuotaExceededError") {
            cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option");
        }
        sys.localStorage = function () {
        };
    }
    var capabilities = sys.capabilities = {"canvas": true};
    if (cc._renderType == cc._RENDER_TYPE_WEBGL)
        capabilities["opengl"] = true;
    if (docEle['ontouchstart'] !== undefined || nav.msPointerEnabled)
        capabilities["touches"] = true;
    if (docEle['onmouseup'] !== undefined)
        capabilities["mouse"] = true;
    if (docEle['onkeyup'] !== undefined)
        capabilities["keyboard"] = true;
    if (win.DeviceMotionEvent || win.DeviceOrientationEvent)
        capabilities["accelerometer"] = true;
    sys.garbageCollect = function () {
    };
    sys.dumpRoot = function () {
    };
    sys.restartVM = function () {
    };
    sys.dump = function () {
        var self = this;
        var str = "";
        str += "isMobile : " + self.isMobile + "\r\n";
        str += "language : " + self.language + "\r\n";
        str += "browserType : " + self.browserType + "\r\n";
        str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
        str += "os : " + self.os + "\r\n";
        str += "platform : " + self.platform + "\r\n";
        cc.log(str);
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = false;
cc._setupCalled = false;
cc._setup = function (el, width, height) {
    if (cc._setupCalled) return;
    else cc._setupCalled = true;
    var win = window;
    var lastTime = new Date();
    var frameTime = 1000 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
    var stTime = function(callback){
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, frameTime - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(); },
            timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    var ctTime = function(id){
        clearTimeout(id);
    };
    if(cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT){
        win.requestAnimFrame = stTime;
        win.cancelAnimationFrame = ctTime;
    }else if(cc.game.config[cc.game.CONFIG_KEY.frameRate] != 60){
        win.requestAnimFrame = stTime;
        win.cancelAnimationFrame = ctTime;
    }else{
        win.requestAnimFrame = win.requestAnimationFrame ||
            win.webkitRequestAnimationFrame ||
            win.mozRequestAnimationFrame ||
            win.oRequestAnimationFrame ||
            win.msRequestAnimationFrame ||
            stTime;
        win.cancelAnimationFrame = window.cancelAnimationFrame ||
            window.cancelRequestAnimationFrame ||
            window.msCancelRequestAnimationFrame ||
            window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame ||
            window.webkitCancelRequestAnimationFrame ||
            window.msCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.oCancelAnimationFrame ||
            ctTime;
    }
    var element = cc.$(el) || cc.$('#' + el);
    var localCanvas, localContainer, localConStyle;
    if (element.tagName == "CANVAS") {
        width = width || element.width;
        height = height || element.height;
        localContainer = cc.container = cc.newElement("DIV");
        localCanvas = cc._canvas = element;
        localCanvas.parentNode.insertBefore(localContainer, localCanvas);
        localCanvas.appendTo(localContainer);
        localContainer.setAttribute('id', 'Cocos2dGameContainer');
    } else {//we must make a new canvas and place into this element
        if (element.tagName != "DIV") {
            cc.log("Warning: target element is not a DIV or CANVAS");
        }
        width = width || element.clientWidth;
        height = height || element.clientHeight;
        localContainer = cc.container = element;
        localCanvas = cc._canvas = cc.$(cc.newElement("CANVAS"));
        element.appendChild(localCanvas);
    }
    localCanvas.addClass("gameCanvas");
    localCanvas.setAttribute("width", width || 480);
    localCanvas.setAttribute("height", height || 320);
    localCanvas.setAttribute("tabindex", 99);
    localCanvas.style.outline = "none";
    localConStyle = localContainer.style;
    localConStyle.width = (width || 480) + "px";
    localConStyle.height = (height || 320) + "px";
    localConStyle.margin = "0 auto";
    localConStyle.position = 'relative';
    localConStyle.overflow = 'hidden';
    localContainer.top = '100%';
    if (cc._renderType == cc._RENDER_TYPE_WEBGL)
        cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, {
            'stencil': true,
            'preserveDrawingBuffer': true,
            'antialias': !cc.sys.isMobile,
            'alpha': false});
    if (cc._renderContext) {
        win.gl = cc._renderContext;
        cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext);
        cc._rendererInitialized = true;
        cc.textureCache._initializingRenderer();
        cc.shaderCache._init();
    } else {
        cc._renderContext = localCanvas.getContext("2d");
        cc._mainRenderContextBackup = cc._renderContext;
        cc._renderContext.translate(0, localCanvas.height);
        cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null;
    }
    cc._gameDiv = localContainer;
    cc.log(cc.ENGINE_VERSION);
    cc._setContextMenuEnable(false);
    if (cc.sys.isMobile) {
        var fontStyle = cc.newElement("style");
        fontStyle.type = "text/css";
        document.body.appendChild(fontStyle);
        fontStyle.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;"
            + "-webkit-tap-highlight-color:rgba(0,0,0,0);}";
    }
    cc.view = cc.EGLView._getInstance();
    cc.inputManager.registerSystemEvent(cc._canvas);
    cc.director = cc.Director._getInstance();
    if (cc.director.setOpenGLView)
        cc.director.setOpenGLView(cc.view);
    cc.winSize = cc.director.getWinSize();
    cc.saxParser = new cc.SAXParser();
    cc.plistParser = new cc.PlistParser();
};
cc._checkWebGLRenderMode = function () {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL)
        throw "This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = false;
cc._setContextMenuEnable = function (enabled) {
    cc._isContextMenuEnable = enabled;
    cc._canvas.oncontextmenu = function () {
        if (!cc._isContextMenuEnable) return false;
    };
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: false,//whether the prepare function has been called
    _prepared: false,//whether the engine has prepared
    _paused: true,//whether the game is paused
    _intervalId: null,//interval target of main
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function (frameRate) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        config[CONFIG_KEY.frameRate] = frameRate;
        if (self._intervalId)
            window.cancelAnimationFrame(self._intervalId);
        self._paused = true;
        self._runMainLoop();
    },
    _runMainLoop: function () {
        var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY,
            director = cc.director;
        director.setDisplayStats(config[CONFIG_KEY.showFPS]);
        callback = function () {
            if (!self._paused) {
                director.mainLoop();
                if(self._intervalId)
                    window.cancelAnimationFrame(self._intervalId);
                self._intervalId = window.requestAnimFrame(callback);
            }
        };
        window.requestAnimFrame(callback);
        self._paused = false;
    },
    run: function (id) {
        var self = this;
        var _run = function () {
            if (id) {
                self.config[self.CONFIG_KEY.id] = id;
            }
            if (!self._prepareCalled) {
                self.prepare(function () {
                    self._prepared = true;
                });
            }
            if (cc._supportRender) {
                self._checkPrepare = setInterval(function () {
                    if (self._prepared) {
                        cc._setup(self.config[self.CONFIG_KEY.id]);
                        self._runMainLoop();
                        self._eventHide = self._eventHide || new cc.EventCustom(self.EVENT_HIDE);
                        self._eventHide.setUserData(self);
                        self._eventShow = self._eventShow || new cc.EventCustom(self.EVENT_SHOW);
                        self._eventShow.setUserData(self);
                        self.onStart();
                        clearInterval(self._checkPrepare);
                    }
                }, 10);
            }
        };
        document.body ?
            _run() :
            cc._addEventListener(window, 'load', function () {
                this.removeEventListener('load', arguments.callee, false);
                _run();
            }, false);
    },
    _initConfig: function () {
        var self = this, CONFIG_KEY = self.CONFIG_KEY;
        var _init = function (cfg) {
            cfg[CONFIG_KEY.engineDir] = cfg[CONFIG_KEY.engineDir] || "frameworks/cocos2d-html5";
            if(cfg[CONFIG_KEY.debugMode] == null)
                cfg[CONFIG_KEY.debugMode] = 0;
            cfg[CONFIG_KEY.frameRate] = cfg[CONFIG_KEY.frameRate] || 60;
            if(cfg[CONFIG_KEY.renderMode] == null)
                cfg[CONFIG_KEY.renderMode] = 1;
            return cfg;
        };
        if (document["ccConfig"]) {
            self.config = _init(document["ccConfig"]);
        } else {
            try {
                var cocos_script = document.getElementsByTagName('script');
                for(var i=0;i<cocos_script.length;i++){
                    var _t = cocos_script[i].getAttribute('cocos');
                    if(_t == '' || _t){break;}
                }
                var _src, txt, _resPath;
                if(i < cocos_script.length){
                    _src = cocos_script[i].src;
                    if(_src){
                        _resPath = /(.*)\//.exec(_src)[0];
                        cc.loader.resPath = _resPath;
                        _src = cc.path.join(_resPath, 'project.json');
                    }
                    txt = cc.loader._loadTxtSync(_src);
                }
                if(!txt){
                    txt = cc.loader._loadTxtSync("project.json");
                }
                var data = JSON.parse(txt);
                self.config = _init(data || {});
            } catch (e) {
                cc.log("Failed to read or parse project.json");
                self.config = _init({});
            }
        }
        cc._initSys(self.config, CONFIG_KEY);
    },
    _jsAddedCache: {},
    _getJsListOfModule: function (moduleMap, moduleName, dir) {
        var jsAddedCache = this._jsAddedCache;
        if (jsAddedCache[moduleName]) return null;
        dir = dir || "";
        var jsList = [];
        var tempList = moduleMap[moduleName];
        if (!tempList) throw "can not find module [" + moduleName + "]";
        var ccPath = cc.path;
        for (var i = 0, li = tempList.length; i < li; i++) {
            var item = tempList[i];
            if (jsAddedCache[item]) continue;
            var extname = ccPath.extname(item);
            if (!extname) {
                var arr = this._getJsListOfModule(moduleMap, item, dir);
                if (arr) jsList = jsList.concat(arr);
            } else if (extname.toLowerCase() == ".js") jsList.push(ccPath.join(dir, item));
            jsAddedCache[item] = 1;
        }
        return jsList;
    },
    prepare: function (cb) {
        var self = this;
        var config = self.config, CONFIG_KEY = self.CONFIG_KEY, engineDir = config[CONFIG_KEY.engineDir], loader = cc.loader;
        if (!cc._supportRender) {
            throw "The renderer doesn't support the renderMode " + config[CONFIG_KEY.renderMode];
        }
        self._prepareCalled = true;
        var jsList = config[CONFIG_KEY.jsList] || [];
        if (cc.Class) {//is single file
            loader.loadJsWithImg("", jsList, function (err) {
                if (err) throw err;
                self._prepared = true;
                if (cb) cb();
            });
        } else {
            var ccModulesPath = cc.path.join(engineDir, "moduleConfig.json");
            loader.loadJson(ccModulesPath, function (err, modulesJson) {
                if (err) throw err;
                var modules = config["modules"] || [];
                var moduleMap = modulesJson["module"];
                var newJsList = [];
                if (cc._renderType == cc._RENDER_TYPE_WEBGL) modules.splice(0, 0, "shaders");
                else if (modules.indexOf("core") < 0) modules.splice(0, 0, "core");
                for (var i = 0, li = modules.length; i < li; i++) {
                    var arr = self._getJsListOfModule(moduleMap, modules[i], engineDir);
                    if (arr) newJsList = newJsList.concat(arr);
                }
                newJsList = newJsList.concat(jsList);
                cc.loader.loadJsWithImg(newJsList, function (err) {
                    if (err) throw err;
                    self._prepared = true;
                    if (cb) cb();
                });
            });
        }
    }
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function (oThis) {
    if (!cc.isFunction(this)) {
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }
    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis,
                aArgs.concat(Array.prototype.slice.call(arguments)));
        };
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
};

var cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,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";
cc._loaderImage = "data:image/jpeg;base64,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bAAAAAAATmd0dmJvb2wAAAAAAEVtbERib29sAAAAAABJbnRyYm9vbAAAAAAAQmNrZ09iamMAAAABAAAAAAAAUkdCQwAAAAMAAAAAUmQgIGRvdWJAb+AAAAAAAAAAAABHcm4gZG91YkBv4AAAAAAAAAAAAEJsICBkb3ViQG/gAAAAAAAAAAAAQnJkVFVudEYjUmx0AAAAAAAAAAAAAAAAQmxkIFVudEYjUmx0AAAAAAAAAAAAAAAAUnNsdFVudEYjUHhsQFIAAAAAAAAAAAAKdmVjdG9yRGF0YWJvb2wBAAAAAFBnUHNlbnVtAAAAAFBnUHMAAAAAUGdQQwAAAABMZWZ0VW50RiNSbHQAAAAAAAAAAAAAAABUb3AgVW50RiNSbHQAAAAAAAAAAAAAAABTY2wgVW50RiNQcmNAWQAAAAAAADhCSU0D7QAAAAAAEABIAAAAAQACAEgAAAABAAI4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0D8gAAAAAACgAA////////AAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAANDAAAABgAAAAAAAAAAAAAEOAAAB4AAAAAHAGwAbwBhAGQAaQBuAGcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAB4AAAAQ4AAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAQ4AAAAAFJnaHRsb25nAAAHgAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAAEOAAAAABSZ2h0bG9uZwAAB4AAAAADdXJsVEVYVAAAAAEAAAAAAABudWxsVEVYVAAAAAEAAAAAAABNc2dlVEVYVAAAAAEAAAAAAAZhbHRUYWdURVhUAAAAAQAAAAAADmNlbGxUZXh0SXNIVE1MYm9vbAEAAAAIY2VsbFRleHRURVhUAAAAAQAAAAAACWhvcnpBbGlnbmVudW0AAAAPRVNsaWNlSG9yekFsaWduAAAAB2RlZmF1bHQAAAAJdmVydEFsaWduZW51bQAAAA9FU2xpY2VWZXJ0QWxpZ24AAAAHZGVmYXVsdAAAAAtiZ0NvbG9yVHlwZWVudW0AAAARRVNsaWNlQkdDb2xvclR5cGUAAAAATm9uZQAAAAl0b3BPdXRzZXRsb25nAAAAAAAAAApsZWZ0T3V0c2V0bG9uZwAAAAAAAAAMYm90dG9tT3V0c2V0bG9uZwAAAAAAAAALcmlnaHRPdXRzZXRsb25nAAAAAAA4QklNBCgAAAAAAAwAAAACP/AAAAAAAAA4QklNBBEAAAAAAAEBADhCSU0EFAAAAAAABAAAAAE4QklNBAwAAAAAFaYAAAABAAAAoAAAAFoAAAHgAACowAAAFYoAGAAB/9j/7QAMQWRvYmVfQ00AAv/uAA5BZG9iZQBkgAAAAAH/2wCEAAwICAgJCAwJCQwRCwoLERUPDAwPFRgTExUTExgRDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBDQsLDQ4NEA4OEBQODg4UFA4ODg4UEQwMDAwMEREMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAFoAoAMBIgACEQEDEQH/3QAEAAr/xAE/AAABBQEBAQEBAQAAAAAAAAADAAECBAUGBwgJCgsBAAEFAQEBAQEBAAAAAAAAAAEAAgMEBQYHCAkKCxAAAQQBAwIEAgUHBggFAwwzAQACEQMEIRIxBUFRYRMicYEyBhSRobFCIyQVUsFiMzRygtFDByWSU/Dh8WNzNRaisoMmRJNUZEXCo3Q2F9JV4mXys4TD03Xj80YnlKSFtJXE1OT0pbXF1eX1VmZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3EQACAgECBAQDBAUGBwcGBTUBAAIRAyExEgRBUWFxIhMFMoGRFKGxQiPBUtHwMyRi4XKCkkNTFWNzNPElBhaisoMHJjXC0kSTVKMXZEVVNnRl4vKzhMPTdePzRpSkhbSVxNTk9KW1xdXl9VZmdoaWprbG1ub2JzdHV2d3h5ent8f/2gAMAwEAAhEDEQA/AOSbcQIl095017/1fd9L9x6k2x5MAfJN6jY4gwBr7iIH/S2t/wC36UmvZ3cAPIT2/wCl7f8APq/qLpgTp6v5f4TjV/VX22u1Bg+SLXiWuPOnmlU4mPpFwPu10j5fnf8Aqxb3RaqH5DRdAAGjS2dx/c2qURjwmZs1q1+YznFAyrYdHMq6VZb9FrnAD37Ru/taAe1Eb9XM10PbU87tAQR92pXXtZDG2W1+i6vc0MrJI2kw3Ruzdub+Zs/RqDry2/2sa+gDa2xrtWvB1pewj2/1lCcwPy4x9df+c5Z+KZiTwAddzp/jfpPD5PScjGlj63MDoJBEafm6lZtrQww5vHiF6U9znl24NfWOaXgjX8/a+Nr2/wBhYeZ9X/XvcMcBtRgtDj3In02n6TtqFQyDpjlX+A2+V+KgmswEdL4r0eMO2ByNddNEfDxPtVrKmnc+w7WjzPw3LayvqdkbHPY5jnM+m2SCD4bn/o3f5yxq23YVrXt/NIc0/DVpUIxmMwZASh1MTxfbF0oczjzQl7OQGQdz/mvimlhNjpsG4Q1rRp9JsOdu9X+Qg0fV+vGt32ltlHuII0MjSsPa6PpfnsWljdRrza6zUSxzdxyaz7iRp6bm/Ra33u/nG/QUrmEt9g31luywW+523+S1v0/5fqfmK1HHDSXCL6aOb955kEwyTIu7B6fy/Rc+/p/T7GFj6KydWlzQWmR9La6v6Oze36a5rqnSHYv6Wp5tpP0jGrTMbX/mrqnuMEteLYAbuIgkj3OPP0X/ANT/ANR5fULG/Zrt41e0sa3gAuO4bnP9/wCao+bwYsmM8UakATGQ0Lc5LNlhMVIyiSBKJ/8AQvleW8imCI6uHGf7ki1rYOmo7H+9YHCXctgWnkJbPFSMjy+KiT80CAoWrTtqUxKWpSgIJf/Q4lm92jKnEmBpoPFob/1VH/balFjYBaGz4eZ/tf2P9HYonNyD7WljJ02N89fT3fuO+nT+49Qba9ziXy7dqXO0BnT3f1vo2/uLc4obAyJ70Ixc3hl1AH1st7Gpe8ghxPERoPl/r/wS6Pp3S8x4DmgNgB0udrB+i7b/ADn+v+kqWV0twFlbnnaAZJgSI0c50/u/4b/2IXaGpuwGD6oHuOgc7971C3/pbf8Aja1cM/ahER3mNy4nxLmZQIgAPVeu6KgZVY9N1hsaD9M868taXtRLHVh763zqNzXOiXEDc5tYn9J6bW/RU8fa+tr3BweZIDgQ7n85jvzmu/sf9bsQogHJyyyWOJrLuGD6Ldu4b2Pf+f8A+o1Xuye/h+85F3I2KI09OhlNmCL8b2MdsdqdzyDA/lNc/bx9Dcqlpqda82bjUa5bVAkuMgtDX7LWuci2tprcbRW3+RMMaXOPu/rPe7/X+aVE52VY421tZY1sDY1o9Ro037dHO2O9nvY3/vifjiTZjt4muFlxQJsx28TVE/43qTWem8NsuYWA7Xem6vc8OcPbvZ7/AE7fzHv/AEizOvYePZiNLBusrG5thMHYfds+i2t/8jZ9BEf1pjIewvkSLCSHfS/Oqscfa5n5jNvpv/8APmV1brOPewM2F7mlxqvth1gH+jYGfQ/4z/ral4eGuPQdbLf5Xl84ywIBAien8v8AunALr6bAWnbB0dMf5qsV9Zzmw31XPg9+J+jrv+kqd1rHPOngDOpIGrtNHIMl0iJ0iX/+Qb/35ZpzShIiEjXm9D7UZgccQfMOs7rjrQfWqaXalr2iC1xEb+7P6u5irZufTk0tLGltgJ3nxEez3f1lnPc3gndrP+v5qdhc8xMDsmS5vJIGBN3oujyuOJEojhr7EbpmXGCPDUoZd4CPNa78HHe1paC0kDj3A+f+cqluC1urSHaT93faVDk5fINdD5MsM8D3Hm0ocdfyp4A8/BEsY5p9wLeNUMquY0yg2sUx80iUyaSuf//R4AN0Ajy2/wDov/v1Smyzb3nvP4b/APvlzFGmxzDu9Jt4LC0NeC4RHg1zf0+P9OrckaXtEvcGxDnOgkBrvo5Ej2uY/wCi9asSd4honsXQxcvYRyI+ZBA/6T62/wDb1C6bpv1gcyttLocBAa/UlojjT+da36dH+kr/AEH84uOrYyJra+0ztEEfSHFbTpusr/nWf8H7FYZcSwP3tbW36QbuaA76QY1zh+iruf7q37P0N/6NXceUGPDkAkNx/Fo81ymPMKkL/i+hWZuAahlOuYdgmWgvMkaenW39K7d/J+mz9EhZ2UxuL+ktY1tw+k33NIIafp/4Vu3939K+r9LX+lpXCV9RcOZeY3OcCHbRPurc7+X+dt/mL/0ijZ1Mt3Avhx7N+kBO6Nw9rff/ANt3f8FakJYRUuM6d6aEfgxEh6iaPa/S9Z1Hq+G6hmNXte3QixzQI2/6NjvoO93/AHz+bv8A0bdDvsstuLD7dgc4kkCZO33OG7973f8Abn+HXHHKte5rgS0wACfcY+h7WH83+T+Z/MqTMp9bSx1ry15HqtDz7tp/d+h/26z/ANHI/eYcJgB6T+lJsn4WBiOOJ1l1Pq66vV9Us6Kdzso77iIIxHy4/vi1z/0LP+vfpP8Awdcdkxuc4EsYSfYD2n6PqOHu9v8AIRmuyLHtqaNhJDWucD7Z0+iwP2t/qM/9FJZPSM+l4F9RDnTsOjg4Db7qyzduZ72f59f/AAahzSMwBGMjXds8rhhy/ollsnYSl+7+5FzzYGiAPmJ/87chudu5M+HYK4zEya7WvY70rKiHtsmC0tIc1zT/ACXJvspBHqAF1nuFhMtn+UG7fzv5xUzhyncEeezfGSA63+bWa1h3BvveI2gkCdDpH9b6KJSGB3AcIB18P3q3T+9+8pWVWWF7CHOeXDYwglwcSGw17fpt/d/sJg9jbfzp09QdjH07I/soCPDIX0KTKxo6jzIdtBgkHUwSTq57v+EVW76QgxuJnjnyj95WXw5ocwtsaOdZkTqPb/0VWua+dQQIII7mDorU9mrj3a1v0S3sBos9xk+SvPO7UcHUeKouGsBZ/MakN3FsVkkvIfekq7K//9Lg6W2NbWz1Cz1TvDgzcGiNoym2NP8AYsSbZFmyoBt1Z21EE2NJOhZ7936K/wDMQBda536Mlm+Q1jCQAXfTp2/uvRGm9zBWAGMI9OAJc4NO70nMbP6Rn+DctWMxoI3p13+yX6Hq9XE0jE7mten8vmZgs3l4YGNZLmNdy1w+nWwj/CVO91SiX1TvqBvLjNj7NGkknz/m7f8AwG5MWNB9R53Tq6x+sif5xrR/hK/8JuUHXn+uRIO7Rsk/mtb/AIOxAyreh12/l/0VCN7WWWwEzY/6PhoP5W4/S3/6T99nvTtyTj7hjvcxz2mt4rJG5pjdXZZ/hK//AD9Uq7nFw9xMCP8Ao6cfvVqd2Nfj5Bxshvo2tLWvafzd0PE7d35rt7VGZ/uj/C81/CNpG9L4fCPgxNztoaAA3u0cEH94/n+1Kpu4/Hv/AH/6/wDCJ6qvUt2NcI/fOgj96fzd/wDg/wCWtHCwgXeqHerWx7Qdo2uAd9B+1/7zv/Bf0Fn86nYsU8kh2uv5BGTJGALe6JhOsvrMEgHdwSPb7Y/z/wBHs/6x/wBxV0Vwqe2uxljmWfRbYzTg6tO8Da2yfd/g7N/qfo67cn7JHp9O2kWi0PsvgA7SQGa111+l7X7fZ/N/4X+gf0rHxrEJ+Yx9Ox+66tzD6mS1sBzme973Vke1r2fpm2/+hP0Leo1rUAqox2jv/wB089nyyzZiR+geGv8ApfNH1L2+2l3rHZMmRrrJ36/1t3/T9X0/1n7JVzGD7O8EAgiG1jazcSfbX7wGb32N2td/Y/4HHM61jamNa+BwCWuFjoOjdvuc13t/432f4S6j9eFfWy/c2ytxNRHpusb7WyA6KNu7dt/kN/4v1f0P20m/tTj0IJ0o3s0cllN3qVuYC6sMna2LGl36Rvu/P3f2/wD0asPNxHYzoAhnIce5H/kf3VvucXAPfaXt2mLHEHdGu71Gn2+/6f8ArddndRrccZ0j2t9zSBGyC1npnXd7t37n/kFX5nGJQJr1AXYdLlchjIRv0kgV/WcR1pDoGnHuOhg/99Ti+0CdxgQNddDP5pQ3QHcaeCjpGmh5c78m1ZBnIHd1eEEbJftDzzB8ygudJ07pHUQAmPHwTJSJ3NrgANluE7Wz8Byna0uIHf8AIFOwho2t4Hf+KAHU7KJ6P//T4B+xjALC1nHqCvVxH+Dva5Qde90zDSQ3e8Tuhv0LdwQhLS0MiRqw8gjvW9O7aTNYgHWsH/pVOWgZk7adK/l/L/wxqiIG+qnElxc90umS4a+4/n/1H/np6qjaXNaWM2tc4ix4aNBLqg530nP/AMCxQBB4E6HYPEfnVq3i0ltLsgVtulp2sJ1cz/Ce0f4Wn6SEImcvtlI76KmeGP4BqSI0+M94Hf8ArM/OR31VY7QyyouscAS0mGifzWFv0mv/AMG/8yxFoyBkPsryYc2wBz7Wt+htEMv9o+i3/CKLbXPYyh9YyWUuIBBIOz/RafRrs+lSnxhCrEr4rEeKN8NH1cUP1n6P6XrWmUroiq1lR/KXoT1OqpDbaYNVn02u5I+i7c393/B5Tf8Arq2Oi4uPZcTDmsAcXh5mGge5j9v85+5lM/Px/TymLKqeLLRbZtayjWyr0zDRG0Ptr9nqtZ/N5tbFv/V8hlpYGzYWgt26O3M3PjH3j33U1u34/wDgsrG/QWK/h2JFUB6f+6lH91z+dkY4pEXxVr/v/wBV07HWVkU2uGw7m+902O9rTZvez3fo2bPtPp/z1HodTo/SVWKtjVuwS+l9z7GtcXVPfAeNp3+ne6PT302P/nvoM9RmV/Qc3IViuwWgFjzFZDWbdNXHfT6G/wCi13vf038z1PX6ZcotaRYCCLK3NbsLBwTubU1rX/v/AKX7Kyz/ALsdIv8A8ApPNyQaBif8If1v0f7jC5rbIc+WtcQG7BGw6t3xPq+30/T9L+cr9P7J/P4/T7VRNz4pcRU8Bzm+u10tEfSc3b/pGv3f6L9J/g6cj9Qs2uYZxnzZY1jXn2OFbg8OAbRP8830qvo7vVtx/wBH/wAo4Vao5FjaDUL2DaAfUYxw+ie7X/Q/wnq7/wCas3+v/RsvL9Ixqmxhjem/aO3p4f0f7yO65jSTf6ZrBDqfTEndz9H27Nn57/0f/Wf0n2LJ6jlUmttFb3WQdz7H9z+axujd2z+r/wCo9HJwd+4VOhwfshwcNPEh/wCl3ez+X/N2f4fHs+1YeXT6NrmPc1+zR22Y3fnVz+9X+f8A+jP8LW5qcoxoDQ6cTpcpDGSDZ4hrwtZtTbCS6xtYnXd59mobyySGjdHB7DxTuJcRp8AP4JQ6YaJcdDH5FlHXQD693UHiWMESNARzPn2UQ0k6CSeAna2dew1PgrLG+mNxbBI0+P8Ar9NCMOLwCjKvNGQKmR+cfpFCgu1Oik4lxn/We6kBpAA/HSEj6jQ2Gyhp5l//1PORWTULACKXO27+zbB2VljX2V3Zl7fX1h53Hcx4+jfH5zFeyv5jO+j/ADdfH0OP/PqWJ9J30P6FX/U5d/P/APDLUx+3xaE1R3EeHj9XD80uD+U/6jTnx1sL8Cb4PTxf1mpjZbHZDhltG26G2OYNu1w/m7m/yP31AX/ZTYKrNd4gAGGu/wC5Fb/3fzdn7iJ0n+cH0P5t/PPH+F/7r/uIGD9K36X9Hf8AR+l/Z/k/98Ug9zhhZ/WXOtP1v9b5f6/H87H6OKX7lR/2fh/zf3Utd1hY1tfp0PJJDGyHF35wa6P0dWQ36H00tmN9lc9geN7m7qWuOg1H2cu936Xf+kp9VN1HnE5/o7fpfT5/19BQH8xd/O/Sr+j9Hv8A0n/u1/o0Na9VfIeHi/u/o/y9pOnS/mHFw/3v5f6xsvvcLftDyKrNumwlwcAPT9Z4t+nv/msuv2K5jZLW6D2PYQK2tJLhHFHrbv0Xpfz3T7P+srNq/nR/OfSdz9Pv/NfyP+5KlV/Re/8AMn6H9f8Awn/uurGLj4jXjf8Ae/S4v5f32DL7fCLvYf4n8v8A129biZWDkY/putaHu/nNxLQ7efdY17vo0Zdn8/t9/T879N6asPe+SAC6qwOJFv0hENvdc1vu+ltq6ixn0LPR6lSuVZ9L+0/+r/N/4T+T/wBzf+FR6+W/0jmvjn+bf9P/AIT/ALk/+a1T978f5RceQxcRozGpriiD6v6nqdfLzXY1jnZj2j02uDcZ305Ja8+o6v3Nt3+n9psZ9B/odUxv5xc9l9Qfc91jyS89tBABPsDfoM9z/o/zfqvs/wC02WhWfRb9Liv8j/8AVn/dJVD/ADjefzfpcfRP0v5H/usosnufoV9HQ5P7vehuVdhGP+Bw8X+G7GR1JtdAbW83WNY1gvB50A/R/Rf/AIP0/X/nP0Xpf0rDqyLcSx+525oB2jgidP6o9u3/AF/4t7/5130vnz9Fv+v/AGynr/mbefpD6P0uLfpf8D/pFU5n3NOKuH9Hh/Bu8r7VHg3/AEra59o2jnx5KZwnQfR7DQn5wpU/zrOPpt+lxyPpJu3388f6/vKiW42KqD6frPMAncCf+q/8ghWuk7Rppx/33+0r+V/Ms/rN+hzx/rs/4X1VnN/nHf1j/FTT4eAcG36X7yyN8R4vp2Xazv2H5Uz2kSPlojH6Dfh8kP8APb8e6jPDWi/W3//ZOEJJTQQhAAAAAABVAAAAAQEAAAAPAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwAAAAEwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAgAEMAUwA1AAAAAQA4QklNBAYAAAAAAAcAAgAAAAEBAP/hDqNodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpjcnM9Imh0dHA6Ly9ucy5hZG9iZS5jb20vY2FtZXJhLXJhdy1zZXR0aW5ncy8xLjAvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIGRjOmZvcm1hdD0iaW1hZ2UvanBlZyIgY3JzOkFscmVhZHlBcHBsaWVkPSJUcnVlIiBwaG90b3Nob3A6TGVnYWN5SVBUQ0RpZ2VzdD0iMDM4Q0Q5QjNEMjBDOEU0QjNGRjc5MjIwQzM5QzBDODciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHhtcDpDcmVhdGVEYXRlPSIyMDE3LTA4LTI0VDA5OjM1OjE4KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNy0wOC0yNFQwOTozODo1NyswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxNy0wOC0yNFQwOTozODo1NyswODowMCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzAwNDExRkY2Qzg4RTcxMUExRjNGMjZGN0VBRkYyRUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDM1NTdGOUQ2Qzg4RTcxMTkzRTI5NEI5RkNBMTJCQjciIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpEMzU1N0Y5RDZDODhFNzExOTNFMjk0QjlGQ0ExMkJCNyI+IDxkYzpyaWdodHM+IDxyZGY6QWx0PiA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPnRlZWtpZDwvcmRmOmxpPiA8L3JkZjpBbHQ+IDwvZGM6cmlnaHRzPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpEMzU1N0Y5RDZDODhFNzExOTNFMjk0QjlGQ0ExMkJCNyIgc3RFdnQ6d2hlbj0iMjAxNy0wOC0yNFQwOTozNjoxMyswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDozMDA0MTFGRjZDODhFNzExQTFGM0YyNkY3RUFGRjJFQyIgc3RFdnQ6d2hlbj0iMjAxNy0wOC0yNFQwOTozODo1NyswODowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+4ADkFkb2JlAGSAAAAAAf/bAIQACAYGCQYJDggIDhENCw0RFRIRERIVHBcXFxcXHBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEJCQkLCgsSCwsSFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgEOAeAAwEiAAIRAQMRAf/dAAQAeP/EAaIAAAAHAQEBAQEAAAAAAAAAAAQFAwIGAQAHCAkKCwEAAgIDAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAACAQMDAgQCBgcDBAIGAnMBAgMRBAAFIRIxQVEGE2EicYEUMpGhBxWxQiPBUtHhMxZi8CRygvElQzRTkqKyY3PCNUQnk6OzNhdUZHTD0uIIJoMJChgZhJRFRqS0VtNVKBry4/PE1OT0ZXWFlaW1xdXl9WZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+Ck5SVlpeYmZqbnJ2en5KjpKWmp6ipqqusra6voRAAICAQIDBQUEBQYECAMDbQEAAhEDBCESMUEFURNhIgZxgZEyobHwFMHR4SNCFVJicvEzJDRDghaSUyWiY7LCB3PSNeJEgxdUkwgJChgZJjZFGidkdFU38qOzwygp0+PzhJSktMTU5PRldYWVpbXF1eX1RlZmdoaWprbG1ub2R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+DlJWWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+v/aAAwDAQACEQMRAD8AgA0IFqg4vLZrAtGONh9cnrjri0lcVY538YQjAyxw5vLSnk4qnNCpAhao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";
cc.loader.loadBinary = function (url, cb) {
    var self = this;
    var xhr = this.getXMLHttpRequest(),
        errInfo = "load " + url + " failed!";
    xhr.open("GET", url, true);
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        xhr.setRequestHeader("Accept-Charset", "x-user-defined");
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                var fileContents = cc._convertResponseBodyToText(xhr["responseBody"]);
                cb(null, self._str2Uint8Array(fileContents));
            } else cb(errInfo);
        };
    } else {
        if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=x-user-defined");
        xhr.onload = function () {
            xhr.readyState == 4 && xhr.status == 200 ? cb(null, self._str2Uint8Array(xhr.responseText)) : cb(errInfo);
        };
    }
    xhr.send(null);
};
cc.loader._str2Uint8Array = function (strData) {
    if (!strData)
        return null;
    var arrData = new Uint8Array(strData.length);
    for (var i = 0; i < strData.length; i++) {
        arrData[i] = strData.charCodeAt(i) & 0xff;
    }
    return arrData;
};
cc.loader.loadBinarySync = function (url) {
    var self = this;
    var req = this.getXMLHttpRequest();
    var errInfo = "load " + url + " failed!";
    req.open('GET', url, false);
    var arrayInfo = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        req.setRequestHeader("Accept-Charset", "x-user-defined");
        req.send(null);
        if (req.status != 200) {
            cc.log(errInfo);
            return null;
        }
        var fileContents = cc._convertResponseBodyToText(req["responseBody"]);
        if (fileContents) {
            arrayInfo = self._str2Uint8Array(fileContents);
        }
    } else {
        if (req.overrideMimeType)
            req.overrideMimeType('text\/plain; charset=x-user-defined');
        req.send(null);
        if (req.status != 200) {
            cc.log(errInfo);
            return null;
        }
        arrayInfo = this._str2Uint8Array(req.responseText);
    }
    return arrayInfo;
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script =
        "<!-- IEBinaryToArray_ByteStr -->\r\n" +
            "Function IEBinaryToArray_ByteStr(Binary)\r\n" +
            "   IEBinaryToArray_ByteStr = CStr(Binary)\r\n" +
            "End Function\r\n" +
            "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n" +
            "   Dim lastIndex\r\n" +
            "   lastIndex = LenB(Binary)\r\n" +
            "   if lastIndex mod 2 Then\r\n" +
            "       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n" +
            "   Else\r\n" +
            "       IEBinaryToArray_ByteStr_Last = " + '""' + "\r\n" +
            "   End If\r\n" +
            "End Function\r\n";// +
    var myVBScript = cc.newElement('script');
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function (binary) {
        var byteMapping = {};
        for (var i = 0; i < 256; i++) {
            for (var j = 0; j < 256; j++) {
                byteMapping[ String.fromCharCode(i + j * 256) ] =
                    String.fromCharCode(i) + String.fromCharCode(j);
            }
        }
        var rawBytes = IEBinaryToArray_ByteStr(binary);
        var lastChr = IEBinaryToArray_ByteStr_Last(binary);
        return rawBytes.replace(/[\s\S]/g,
            function (match) {
                return byteMapping[match];
            }) + lastChr;
    };
}
var cc = cc || {};
var ClassManager = {
    id : (0|(Math.random()*998)),
    instanceId : (0|(Math.random()*998)),
    compileSuper : function(func, name, id){
        var str = func.toString();
        var pstart = str.indexOf('('), pend = str.indexOf(')');
        var params = str.substring(pstart+1, pend);
        params = params.trim();
        var bstart = str.indexOf('{'), bend = str.lastIndexOf('}');
        var str = str.substring(bstart+1, bend);
        while(str.indexOf('this._super')!= -1)
        {
            var sp = str.indexOf('this._super');
            var bp = str.indexOf('(', sp);
            var bbp = str.indexOf(')', bp);
            var superParams = str.substring(bp+1, bbp);
            superParams = superParams.trim();
            var coma = superParams? ',':'';
            str = str.substring(0, sp)+  'ClassManager['+id+'].'+name+'.call(this'+coma+str.substring(bp+1);
        }
        return Function(params, str);
    },
    getNewID : function(){
        return this.id++;
    },
    getNewInstanceId : function(){
        return this.instanceId++;
    }
};
ClassManager.compileSuper.ClassManager = ClassManager;
(function () {
    var fnTest = /\b_super\b/;
    var config = cc.game.config;
    var releaseMode = config[cc.game.CONFIG_KEY.classReleaseMode];
    if(releaseMode) {
        console.log("release Mode");
    }
    cc.Class = function () {
    };
    cc.Class.extend = function (props) {
        var _super = this.prototype;
        var prototype = Object.create(_super);
        var classId = ClassManager.getNewID();
        ClassManager[classId] = _super;
        var desc = { writable: true, enumerable: false, configurable: true };
	    prototype.__instanceId = null;
	    function Class() {
		    this.__instanceId = ClassManager.getNewInstanceId();
		    if (this.ctor)
			    this.ctor.apply(this, arguments);
	    }
	    Class.id = classId;
	    desc.value = classId;
	    Object.defineProperty(prototype, '__pid', desc);
	    Class.prototype = prototype;
	    desc.value = Class;
	    Object.defineProperty(Class.prototype, 'constructor', desc);
	    this.__getters__ && (Class.__getters__ = cc.clone(this.__getters__));
	    this.__setters__ && (Class.__setters__ = cc.clone(this.__setters__));
        for(var idx = 0, li = arguments.length; idx < li; ++idx) {
            var prop = arguments[idx];
            for (var name in prop) {
                var isFunc = (typeof prop[name] === "function");
                var override = (typeof _super[name] === "function");
                var hasSuperCall = fnTest.test(prop[name]);
                if (releaseMode && isFunc && override && hasSuperCall) {
                    desc.value = ClassManager.compileSuper(prop[name], name, classId);
                    Object.defineProperty(prototype, name, desc);
                } else if (isFunc && override && hasSuperCall) {
                    desc.value = (function (name, fn) {
                        return function () {
                            var tmp = this._super;
                            this._super = _super[name];
                            var ret = fn.apply(this, arguments);
                            this._super = tmp;
                            return ret;
                        };
                    })(name, prop[name]);
                    Object.defineProperty(prototype, name, desc);
                } else if (isFunc) {
                    desc.value = prop[name];
                    Object.defineProperty(prototype, name, desc);
                } else {
                    prototype[name] = prop[name];
                }
                if (isFunc) {
                    var getter, setter, propertyName;
                    if (this.__getters__ && this.__getters__[name]) {
                        propertyName = this.__getters__[name];
                        for (var i in this.__setters__) {
                            if (this.__setters__[i] == propertyName) {
                                setter = i;
                                break;
                            }
                        }
                        cc.defineGetterSetter(prototype, propertyName, prop[name], prop[setter] ? prop[setter] : prototype[setter], name, setter);
                    }
                    if (this.__setters__ && this.__setters__[name]) {
                        propertyName = this.__setters__[name];
                        for (var i in this.__getters__) {
                            if (this.__getters__[i] == propertyName) {
                                getter = i;
                                break;
                            }
                        }
                        cc.defineGetterSetter(prototype, propertyName, prop[getter] ? prop[getter] : prototype[getter], prop[name], getter, name);
                    }
                }
            }
        }
        Class.extend = cc.Class.extend;
        Class.implement = function (prop) {
            for (var name in prop) {
                prototype[name] = prop[name];
            }
        };
        return Class;
    };
})();
cc.defineGetterSetter = function (proto, prop, getter, setter, getterName, setterName){
    if (proto.__defineGetter__) {
        getter && proto.__defineGetter__(prop, getter);
        setter && proto.__defineSetter__(prop, setter);
    } else if (Object.defineProperty) {
        var desc = { enumerable: false, configurable: true };
        getter && (desc.get = getter);
        setter && (desc.set = setter);
        Object.defineProperty(proto, prop, desc);
    } else {
        throw new Error("browser does not support getters");
    }
    if(!getterName && !setterName) {
        var hasGetter = (getter != null), hasSetter = (setter != undefined), props = Object.getOwnPropertyNames(proto);
        for (var i = 0; i < props.length; i++) {
            var name = props[i];
            if( (proto.__lookupGetter__ ? proto.__lookupGetter__(name)
                                        : Object.getOwnPropertyDescriptor(proto, name))
                || typeof proto[name] !== "function" )
                continue;
            var func = proto[name];
            if (hasGetter && func === getter) {
                getterName = name;
                if(!hasSetter || setterName) break;
            }
            if (hasSetter && func === setter) {
                setterName = name;
                if(!hasGetter || getterName) break;
            }
        }
    }
    var ctor = proto.constructor;
    if (getterName) {
        if (!ctor.__getters__) {
            ctor.__getters__ = {};
        }
        ctor.__getters__[getterName] = prop;
    }
    if (setterName) {
        if (!ctor.__setters__) {
            ctor.__setters__ = {};
        }
        ctor.__setters__[setterName] = prop;
    }
};
cc.clone = function (obj) {
    var newObj = (obj.constructor) ? new obj.constructor : {};
    for (var key in obj) {
        var copy = obj[key];
        if (((typeof copy) == "object") && copy &&
            !(copy instanceof cc.Node) && !(copy instanceof HTMLElement)) {
            newObj[key] = cc.clone(copy);
        } else {
            newObj[key] = copy;
        }
    }
    return newObj;
};
cc.Point = function (x, y) {
    this.x = x || 0;
    this.y = y || 0;
};
cc.p = function (x, y) {
    if (x == undefined)
        return {x: 0, y: 0};
    if (y == undefined)
        return {x: x.x, y: x.y};
    return {x: x, y: y};
};
cc.pointEqualToPoint = function (point1, point2) {
    return point1 && point2 && (point1.x === point2.x) && (point1.y === point2.y);
};
cc.Size = function (width, height) {
    this.width = width || 0;
    this.height = height || 0;
};
cc.size = function (w, h) {
    if (w === undefined)
        return {width: 0, height: 0};
    if (h === undefined)
        return {width: w.width, height: w.height};
    return {width: w, height: h};
};
cc.sizeEqualToSize = function (size1, size2) {
    return (size1 && size2 && (size1.width == size2.width) && (size1.height == size2.height));
};
cc.Rect = function (x, y, width, height) {
    this.x = x||0;
    this.y = y||0;
    this.width = width||0;
    this.height = height||0;
};
cc.rect = function (x, y, w, h) {
    if (x === undefined)
        return {x: 0, y: 0, width: 0, height: 0};
    if (y === undefined)
        return {x: x.x, y: x.y, width: x.width, height: x.height};
    return {x: x, y: y, width: w, height: h };
};
cc.rectEqualToRect = function (rect1, rect2) {
    return rect1 && rect2 && (rect1.x === rect2.x) && (rect1.y === rect2.y) && (rect1.width === rect2.width) && (rect1.height === rect2.height);
};
cc._rectEqualToZero = function(rect){
    return rect && (rect.x === 0) && (rect.y === 0) && (rect.width === 0) && (rect.height === 0);
};
cc.rectContainsRect = function (rect1, rect2) {
    if (!rect1 || !rect2)
        return false;
    return !((rect1.x >= rect2.x) || (rect1.y >= rect2.y) ||
        ( rect1.x + rect1.width <= rect2.x + rect2.width) ||
        ( rect1.y + rect1.height <= rect2.y + rect2.height));
};
cc.rectGetMaxX = function (rect) {
    return (rect.x + rect.width);
};
cc.rectGetMidX = function (rect) {
    return (rect.x + rect.width / 2.0);
};
cc.rectGetMinX = function (rect) {
    return rect.x;
};
cc.rectGetMaxY = function (rect) {
    return(rect.y + rect.height);
};
cc.rectGetMidY = function (rect) {
    return rect.y + rect.height / 2.0;
};
cc.rectGetMinY = function (rect) {
    return rect.y;
};
cc.rectContainsPoint = function (rect, point) {
    return (point.x >= cc.rectGetMinX(rect) && point.x <= cc.rectGetMaxX(rect) &&
        point.y >= cc.rectGetMinY(rect) && point.y <= cc.rectGetMaxY(rect)) ;
};
cc.rectIntersectsRect = function (ra, rb) {
    var maxax = ra.x + ra.width,
        maxay = ra.y + ra.height,
        maxbx = rb.x + rb.width,
        maxby = rb.y + rb.height;
    return !(maxax < rb.x || maxbx < ra.x || maxay < rb.y || maxby < ra.y);
};
cc.rectOverlapsRect = function (rectA, rectB) {
    return !((rectA.x + rectA.width < rectB.x) ||
        (rectB.x + rectB.width < rectA.x) ||
        (rectA.y + rectA.height < rectB.y) ||
        (rectB.y + rectB.height < rectA.y));
};
cc.rectUnion = function (rectA, rectB) {
    var rect = cc.rect(0, 0, 0, 0);
    rect.x = Math.min(rectA.x, rectB.x);
    rect.y = Math.min(rectA.y, rectB.y);
    rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
    rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
    return rect;
};
cc.rectIntersection = function (rectA, rectB) {
    var intersection = cc.rect(
        Math.max(cc.rectGetMinX(rectA), cc.rectGetMinX(rectB)),
        Math.max(cc.rectGetMinY(rectA), cc.rectGetMinY(rectB)),
        0, 0);
    intersection.width = Math.min(cc.rectGetMaxX(rectA), cc.rectGetMaxX(rectB)) - cc.rectGetMinX(intersection);
    intersection.height = Math.min(cc.rectGetMaxY(rectA), cc.rectGetMaxY(rectB)) - cc.rectGetMinY(intersection);
    return intersection;
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function () {
        if (window.DOMParser) {
            this._isSupportDOMParser = true;
            this._parser = new DOMParser();
        } else {
            this._isSupportDOMParser = false;
        }
    },
    parse : function(xmlTxt){
        return this._parseXML(xmlTxt);
    },
    _parseXML: function (textxml) {
        var xmlDoc;
        if (this._isSupportDOMParser) {
            xmlDoc = this._parser.parseFromString(textxml, "text/xml");
        } else {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = "false";
            xmlDoc.loadXML(textxml);
        }
        return xmlDoc;
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse : function (xmlTxt) {
        var xmlDoc = this._parseXML(xmlTxt);
        var plist = xmlDoc.documentElement;
        if (plist.tagName != 'plist')
            throw "Not a plist file!";
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == 1)
                break;
        }
        xmlDoc = null;
        return this._parseNode(node);
    },
    _parseNode: function (node) {
        var data = null, tagName = node.tagName;
        if(tagName == "dict"){
            data = this._parseDict(node);
        }else if(tagName == "array"){
            data = this._parseArray(node);
        }else if(tagName == "string"){
            if (node.childNodes.length == 1)
                data = node.firstChild.nodeValue;
            else {
                data = "";
                for (var i = 0; i < node.childNodes.length; i++)
                    data += node.childNodes[i].nodeValue;
            }
        }else if(tagName == "false"){
            data = false;
        }else if(tagName == "true"){
            data = true;
        }else if(tagName == "real"){
            data = parseFloat(node.firstChild.nodeValue);
        }else if(tagName == "integer"){
            data = parseInt(node.firstChild.nodeValue, 10);
        }
        return data;
    },
    _parseArray: function (node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1)
                continue;
            data.push(this._parseNode(child));
        }
        return data;
    },
    _parseDict: function (node) {
        var data = {};
        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1)
                continue;
            if (child.tagName == 'key')
                key = child.firstChild.nodeValue;
            else
                data[key] = this._parseNode(child);
        }
        return data;
    }
});
cc._txtLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadTxt(realUrl, cb);
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadJson(realUrl, cb);
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.cache[url] =  cc.loader.loadImg(realUrl, function(err, img){
            if(err)
                return cb(err);
            cc.textureCache.handleLoadedTexture(url);
            cb(null, img);
        });
    }
};
cc.loader.register(["png", "jpg", "bmp","jpeg","gif", "ico"], cc._imgLoader);
cc._serverImgLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.cache[url] =  cc.loader.loadImg(res.src, function(err, img){
            if(err)
                return cb(err);
            cc.textureCache.handleLoadedTexture(url);
            cb(null, img);
        });
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadTxt(realUrl, function(err, txt){
            if(err)
                return cb(err);
            cb(null, cc.plistParser.parse(txt));
        });
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE : {
        ".eot" : "embedded-opentype",
        ".ttf" : "truetype",
        ".woff" : "woff",
        ".svg" : "svg"
    },
    _loadFont : function(name, srcs, type){
        var doc = document, path = cc.path, TYPE = this.TYPE, fontStyle = cc.newElement("style");
        fontStyle.type = "text/css";
        doc.body.appendChild(fontStyle);
        var fontStr = "@font-face { font-family:" + name + "; game-src:";
        if(srcs instanceof Array){
            for(var i = 0, li = srcs.length; i < li; i++){
                var src = srcs[i];
                type = path.extname(src).toLowerCase();
                fontStr += "url('" + srcs[i] + "') format('" + TYPE[type] + "')";
                fontStr += (i == li - 1) ? ";" : ",";
            }
        }else{
            fontStr += "url('" + srcs + "') format('" + TYPE[type] + "');";
        }
        fontStyle.textContent += fontStr + "};";
        var preloadDiv = cc.newElement("div");
        var _divStyle =  preloadDiv.style;
        _divStyle.fontFamily = name;
        preloadDiv.innerHTML = ".";
        _divStyle.position = "absolute";
        _divStyle.left = "-100px";
        _divStyle.top = "-100px";
        doc.body.appendChild(preloadDiv);
    },
    load : function(realUrl, url, res, cb){
        var self = this;
        var type = res.type, name = res.name, srcs = res.srcs;
        if(cc.isString(res)){
            type = cc.path.extname(res);
            name = cc.path.basename(res, type);
            self._loadFont(name, res, type);
        }else{
            self._loadFont(name, srcs);
        }
        cb(null, true);
    }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadBinary(realUrl, cb);
    }
};
cc._csbLoader = {
    load: function(realUrl, url, res, cb){
        cc.loader.loadCsb(realUrl, cb);
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window["CocosEngine"] = cc.ENGINE_VERSION = "Cocos2d-JS v3.1";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function (x) {
    var parent = (this == cc) ? document : this;
    var el = (x instanceof HTMLElement) ? x : parent.querySelector(x);
    if (el) {
        el.find = el.find || cc.$;
        el.hasClass = el.hasClass || function (cls) {
            return this.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
        };
        el.addClass = el.addClass || function (cls) {
            if (!this.hasClass(cls)) {
                if (this.className) {
                    this.className += " ";
                }
                this.className += cls;
            }
            return this;
        };
        el.removeClass = el.removeClass || function (cls) {
            if (this.hasClass(cls)) {
                this.className = this.className.replace(cls, '');
            }
            return this;
        };
        el.remove = el.remove || function () {
            if (this.parentNode)
                this.parentNode.removeChild(this);
            return this;
        };
        el.appendTo = el.appendTo || function (x) {
            x.appendChild(this);
            return this;
        };
        el.prependTo = el.prependTo || function (x) {
            ( x.childNodes[0]) ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
            return this;
        };
        el.transforms = el.transforms || function () {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this;
        };
        el.position = el.position || {x: 0, y: 0};
        el.rotation = el.rotation || 0;
        el.scale = el.scale || {x: 1, y: 1};
        el.skew = el.skew || {x: 0, y: 0};
        el.translates = function (x, y) {
            this.position.x = x;
            this.position.y = y;
            this.transforms();
            return this
        };
        el.rotate = function (x) {
            this.rotation = x;
            this.transforms();
            return this
        };
        el.resize = function (x, y) {
            this.scale.x = x;
            this.scale.y = y;
            this.transforms();
            return this
        };
        el.setSkew = function (x, y) {
            this.skew.x = x;
            this.skew.y = y;
            this.transforms();
            return this
        };
    }
    return el;
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = true;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = true;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = false;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = false;
        break;
    default:
        cc.$.pfx = "webkit";
        cc.$.hd = true;
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = (cc.$.hd) ? function (a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = (cc.$.hd) ? function (a) {
    return "rotateZ(" + a + "deg) ";
} : function (a) {
    return "rotate(" + a + "deg) ";
};
cc.$.scale = function (a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
};
cc.$new = function (x) {
    return cc.$(document.createElement(x))
};
cc.$.findpos = function (obj) {
    var curleft = 0;
    var curtop = 0;
    do {
        curleft += obj.offsetLeft;
        curtop += obj.offsetTop;
    } while (obj = obj.offsetParent);
    return {x: curleft, y: curtop};
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat('3.402823466e+38F');
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 0xffffffff;
cc.swap = function (x, y, ref) {
    if (cc.isObject(ref) && !cc.isUndefined(ref.x) && !cc.isUndefined(ref.y)) {
        var tmp = ref[x];
        ref[x] = ref[y];
        ref[y] = tmp;
    } else
        cc.log(cc._LogInfos.swap);
};
cc.lerp = function (a, b, r) {
    return a + (b - a) * r;
};
cc.rand = function () {
	return Math.random() * 0xffffff;
};
cc.randomMinus1To1 = function () {
    return (Math.random() - 0.5) * 2;
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function (angle) {
    return angle * cc.RAD;
};
cc.radiansToDegrees = function (angle) {
    return angle * cc.DEG;
};
cc.radiansToDegress = function (angle) {
    cc.log(cc._LogInfos.radiansToDegress);
    return angle * cc.DEG;
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 0x0302;
cc.BLEND_DST = 0x0303;
cc.nodeDrawSetup = function (node) {
    if (node._shaderProgram) {
        node._shaderProgram.use();
        node._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
    }
};
cc.enableDefaultGLStates = function () {
};
cc.disableDefaultGLStates = function () {
};
cc.incrementGLDraws = function (addNumber) {
    cc.g_NumberOfDraws += addNumber;
};
cc.FLT_EPSILON = 0.0000001192092896;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.director.getContentScaleFactor();
} : function () {
    return 1;
};
cc.pointPointsToPixels = function (points) {
    var scale = cc.contentScaleFactor();
    return cc.p(points.x * scale, points.y * scale);
};
cc.pointPixelsToPoints = function (pixels) {
	var scale = cc.contentScaleFactor();
	return cc.p(pixels.x / scale, pixels.y / scale);
};
cc._pointPixelsToPointsOut = function(pixels, outPoint){
	var scale = cc.contentScaleFactor();
	outPoint.x = pixels.x / scale;
	outPoint.y = pixels.y / scale;
};
cc.sizePointsToPixels = function (sizeInPoints) {
    var scale = cc.contentScaleFactor();
    return cc.size(sizeInPoints.width * scale, sizeInPoints.height * scale);
};
cc.sizePixelsToPoints = function (sizeInPixels) {
    var scale = cc.contentScaleFactor();
    return cc.size(sizeInPixels.width / scale, sizeInPixels.height / scale);
};
cc._sizePixelsToPointsOut = function (sizeInPixels, outSize) {
    var scale = cc.contentScaleFactor();
    outSize.width = sizeInPixels.width / scale;
    outSize.height = sizeInPixels.height / scale;
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (pixel) {
    var scale = cc.contentScaleFactor();
    return cc.rect(pixel.x / scale, pixel.y / scale,
        pixel.width / scale, pixel.height / scale);
} : function (p) {
    return p;
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (point) {
   var scale = cc.contentScaleFactor();
    return cc.rect(point.x * scale, point.y * scale,
        point.width * scale, point.height * scale);
} : function (p) {
    return p;
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 0x0302;
cc.SRC_ALPHA_SATURATE = 0x308;
cc.SRC_COLOR = 0x300;
cc.DST_ALPHA = 0x304;
cc.DST_COLOR = 0x306;
cc.ONE_MINUS_SRC_ALPHA = 0x0303;
cc.ONE_MINUS_SRC_COLOR = 0x301;
cc.ONE_MINUS_DST_ALPHA = 0x305;
cc.ONE_MINUS_DST_COLOR = 0x0307;
cc.ONE_MINUS_CONSTANT_ALPHA	= 0x8004;
cc.ONE_MINUS_CONSTANT_COLOR	= 0x8002;
cc.checkGLErrorDebug = function () {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var _error = cc._renderContext.getError();
        if (_error) {
            cc.log(cc._LogInfos.checkGLErrorDebug, _error);
        }
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1 << 0;
cc.VERTEX_ATTRIB_FLAG_COLOR = 1 << 1;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 1 << 2;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = ( cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS );
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 0xc0c05001;
cc.ZOOM_ACTION_TAG = 0xc0c05002;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function (arr, type) {
    if (arr && arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
            if (!(arr[i] instanceof  type)) {
                cc.log("element type is wrong!");
                return false;
            }
        }
    }
    return true;
};
cc.arrayRemoveObject = function (arr, delObj) {
    for (var i = 0, l = arr.length; i < l; i++) {
        if (arr[i] == delObj) {
            arr.splice(i, 1);
            break;
        }
    }
};
cc.arrayRemoveArray = function (arr, minusArr) {
    for (var i = 0, l = minusArr.length; i < l; i++) {
        cc.arrayRemoveObject(arr, minusArr[i]);
    }
};
cc.arrayAppendObjectsToIndex = function(arr, addObjs,index){
    arr.splice.apply(arr, [index, 0].concat(addObjs));
    return arr;
};
cc.copyArray = function(arr){
    var i, len = arr.length, arr_clone = new Array(len);
    for (i = 0; i < len; i += 1)
        arr_clone[i] = arr[i];
    return arr_clone;
};
cc._tmp.PrototypeColor = function () {
    var _p = cc.color;
    _p._getWhite = function () {
        return _p(255, 255, 255);
    };
    _p._getYellow = function () {
        return _p(255, 255, 0);
    };
    _p._getBlue = function () {
        return  _p(0, 0, 255);
    };
    _p._getGreen = function () {
        return _p(0, 255, 0);
    };
    _p._getRed = function () {
        return _p(255, 0, 0);
    };
    _p._getMagenta = function () {
        return _p(255, 0, 255);
    };
    _p._getBlack = function () {
        return _p(0, 0, 0);
    };
    _p._getOrange = function () {
        return _p(255, 127, 0);
    };
    _p._getGray = function () {
        return _p(166, 166, 166);
    };
    _p.WHITE;
    cc.defineGetterSetter(_p, "WHITE", _p._getWhite);
    _p.YELLOW;
    cc.defineGetterSetter(_p, "YELLOW", _p._getYellow);
    _p.BLUE;
    cc.defineGetterSetter(_p, "BLUE", _p._getBlue);
    _p.GREEN;
    cc.defineGetterSetter(_p, "GREEN", _p._getGreen);
    _p.RED;
    cc.defineGetterSetter(_p, "RED", _p._getRed);
    _p.MAGENTA;
    cc.defineGetterSetter(_p, "MAGENTA", _p._getMagenta);
    _p.BLACK;
    cc.defineGetterSetter(_p, "BLACK", _p._getBlack);
    _p.ORANGE;
    cc.defineGetterSetter(_p, "ORANGE", _p._getOrange);
    _p.GRAY;
    cc.defineGetterSetter(_p, "GRAY", _p._getGray);
    cc.BlendFunc._disable = function(){
        return new cc.BlendFunc(cc.ONE, cc.ZERO);
    };
    cc.BlendFunc._alphaPremultiplied = function(){
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._alphaNonPremultiplied = function(){
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._additive = function(){
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE);
    };
    cc.BlendFunc.DISABLE;
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.BlendFunc.ALPHA_PREMULTIPLIED;
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.BlendFunc.ADDITIVE;
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
};
cc.Color = function (r, g, b, a) {
    this.r = r || 0;
    this.g = g || 0;
    this.b = b || 0;
    this.a = (a == null) ? 255 : a;
};
cc.color = function (r, g, b, a) {
    if (r === undefined)
        return {r: 0, g: 0, b: 0, a: 255};
    if (cc.isString(r))
        return cc.hexToColor(r);
    if (cc.isObject(r))
        return {r: r.r, g: r.g, b: r.b, a: (r.a == null) ? 255 : r.a};
    return  {r: r, g: g, b: b, a: (a == null ? 255 : a)};
};
cc.colorEqual = function (color1, color2) {
    return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
};
cc.Acceleration = function (x, y, z, timestamp) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.timestamp = timestamp || 0;
};
cc.Vertex2F = function (x1, y1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
};
cc.vertex2 = function (x, y) {
    return new cc.Vertex2F(x, y);
};
cc.Vertex3F = function (x1, y1, z1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
    this.z = z1 || 0;
};
cc.vertex3 = function (x, y, z) {
    return new cc.Vertex3F(x, y, z);
};
cc.Tex2F = function (u1, v1) {
    this.u = u1 || 0;
    this.v = v1 || 0;
};
cc.tex2 = function (u, v) {
    return new cc.Tex2F(u, v);
};
cc.BlendFunc = function (src1, dst1) {
    this.src = src1;
    this.dst = dst1;
};
cc.blendFuncDisable = function () {
    return new cc.BlendFunc(cc.ONE, cc.ZERO);
};
cc.hexToColor = function (hex) {
    hex = hex.replace(/^#?/, "0x");
    var c = parseInt(hex);
    var r = c >> 16;
    var g = (c >> 8) % 256;
    var b = c % 256;
    return cc.color(r, g, b);
};
cc.colorToHex = function (color) {
    var hR = color.r.toString(16), hG = color.g.toString(16), hB = color.b.toString(16);
    return "#" + (color.r < 16 ? ("0" + hR) : hR) + (color.g < 16 ? ("0" + hG) : hG) + (color.b < 16 ? ("0" + hB) : hB);
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | (Math.random() * 10));
    },
    __getKey: function () {
        this.__currId++;
        return "key_" + this.__currId;
    },
    setObject: function (value, key) {
        if (key == null)
            return;
        var keyId = this.__getKey();
        this._keyMapTb[keyId] = key;
        this._valueMapTb[keyId] = value;
    },
    objectForKey: function (key) {
        if (key == null)
            return null;
        var locKeyMapTb = this._keyMapTb;
        for (var keyId in locKeyMapTb) {
            if (locKeyMapTb[keyId] === key)
                return this._valueMapTb[keyId];
        }
        return null;
    },
    valueForKey: function (key) {
        return this.objectForKey(key);
    },
    removeObjectForKey: function (key) {
        if (key == null)
            return;
        var locKeyMapTb = this._keyMapTb;
        for (var keyId in locKeyMapTb) {
            if (locKeyMapTb[keyId] === key) {
                delete this._valueMapTb[keyId];
                delete locKeyMapTb[keyId];
                return;
            }
        }
    },
    removeObjectsForKeys: function (keys) {
        if (keys == null)
            return;
        for (var i = 0; i < keys.length; i++)
            this.removeObjectForKey(keys[i]);
    },
    allKeys: function () {
        var keyArr = [], locKeyMapTb = this._keyMapTb;
        for (var key in locKeyMapTb)
            keyArr.push(locKeyMapTb[key]);
        return keyArr;
    },
    removeAllObjects: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
    },
    count: function () {
        return this.allKeys().length;
    }
});
cc.FontDefinition = function () {
    var _t = this;
    _t.fontName = "Arial";
    _t.fontSize = 12;
    _t.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    _t.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    _t.fillStyle = cc.color(255, 255, 255, 255);
    _t.boundingWidth = 0;
    _t.boundingHeight = 0;
    _t.strokeEnabled = false;
    _t.strokeStyle = cc.color(255, 255, 255, 255);
    _t.lineWidth = 1;
    _t.shadowEnabled = false;
    _t.shadowOffsetX = 0;
    _t.shadowOffsetY = 0;
    _t.shadowBlur = 0;
    _t.shadowOpacity = 1.0;
};
if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
    cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js");
    cc._tmp.WebGLColor();
    delete cc._tmp.WebGLColor;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
	_retinaEnabled: false,
    _autoFullScreen: true,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: false,
    _captured: false,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: false,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1.0,
    __resizeWithBrowserSize: false,
    _isAdjustViewPort: true,
    _targetDensityDPI: null,
    ctor: function () {
        var _t = this, d = document, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
        _t._frame = (cc.container.parentNode === d.body) ? d.documentElement : cc.container.parentNode;
        _t._frameSize = cc.size(0, 0);
        _t._initFrameSize();
        var w = cc._canvas.width, h = cc._canvas.height;
        _t._designResolutionSize = cc.size(w, h);
        _t._originalDesignResolutionSize = cc.size(w, h);
        _t._viewPortRect = cc.rect(0, 0, w, h);
        _t._visibleRect = cc.rect(0, 0, w, h);
        _t._contentTranslateLeftTop = {left: 0, top: 0};
        _t._viewName = "Cocos2dHTML5";
	    var sys = cc.sys;
        _t.enableRetina(sys.os == sys.OS_IOS || sys.os == sys.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
        _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
        _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
        _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
        _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
        _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
        _t._hDC = cc._canvas;
        _t._hRC = cc._renderContext;
        _t._targetDensityDPI = cc.DENSITYDPI_HIGH;
    },
    _resizeEvent: function () {
        var width = this._originalDesignResolutionSize.width;
        var height = this._originalDesignResolutionSize.height;
        if (this._resizeCallback) {
            this._initFrameSize();
            this._resizeCallback.call();
        }
        if (width > 0)
            this.setDesignResolutionSize(width, height, this._resolutionPolicy);
    },
    setTargetDensityDPI: function(densityDPI){
        this._targetDensityDPI = densityDPI;
        this._setViewPortMeta();
    },
    getTargetDensityDPI: function(){
        return this._targetDensityDPI;
    },
    resizeWithBrowserSize: function (enabled) {
        var adjustSize, _t = this;
        if (enabled) {
            if (!_t.__resizeWithBrowserSize) {
                _t.__resizeWithBrowserSize = true;
                adjustSize = _t._resizeEvent.bind(_t);
                cc._addEventListener(window, 'resize', adjustSize, false);
            }
        } else {
            if (_t.__resizeWithBrowserSize) {
                _t.__resizeWithBrowserSize = true;
                adjustSize = _t._resizeEvent.bind(_t);
                window.removeEventListener('resize', adjustSize, false);
            }
        }
    },
    setResizeCallback: function (callback) {
        if (cc.isFunction(callback) || callback == null) {
            this._resizeCallback = callback;
        }
    },
    _initFrameSize: function () {
        var locFrameSize = this._frameSize;
        locFrameSize.width = this._frame.clientWidth;
        locFrameSize.height = this._frame.clientHeight;
    },
    _adjustSizeKeepCanvasSize: function () {
        var designWidth = this._originalDesignResolutionSize.width;
        var designHeight = this._originalDesignResolutionSize.height;
        if (designWidth > 0)
            this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
    },
    _setViewPortMeta: function () {
        if (this._isAdjustViewPort) {
            var vp = document.getElementById("cocosMetaElement");
            if(vp){
                document.head.removeChild(vp);
            }
            var viewportMetas,
                elems = document.getElementsByName("viewport"),
                currentVP = elems ? elems[0] : null,
                content;
            vp = cc.newElement("meta");
            vp.id = "cocosMetaElement";
            vp.name = "viewport";
            vp.content = "";
            if (cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX) {
                viewportMetas = {"width": "device-width", "initial-scale": "1.0"};
            }else{
                viewportMetas = {"width": "device-width", "user-scalable": "no", "maximum-scale": "1.0", "initial-scale": "1.0"};
            }
            if(cc.sys.isMobile)
                viewportMetas["target-densitydpi"] = this._targetDensityDPI;
            content = currentVP ? currentVP.content : "";
            for (var key in viewportMetas) {
                var pattern = new RegExp(key);
                if (!pattern.test(content)) {
                    content += "," + key + "=" + viewportMetas[key];
                }
            }
            if(content != "")
                content = content.substr(1);
            vp.content = content;
            if (currentVP)
                currentVP.content = content;
            document.head.appendChild(vp);
        }
    },
    _setScaleXYForRenderTexture: function () {
        var scaleFactor = cc.contentScaleFactor();
        this._scaleX = scaleFactor;
        this._scaleY = scaleFactor;
    },
    _resetScale: function () {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY;
    },
    _adjustSizeToBrowser: function () {
    },
    initialize: function () {
        this._initialized = true;
    },
    adjustViewPort: function (enabled) {
        this._isAdjustViewPort = enabled;
    },
	enableRetina: function(enabled) {
		this._retinaEnabled = enabled ? true : false;
	},
	isRetinaEnabled: function() {
		return this._retinaEnabled;
	},
    enableAutoFullScreen: function(enabled) {
        this._autoFullScreen = enabled ? true : false;
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen;
    },
    end: function () {
    },
    isOpenGLReady: function () {
        return (this._hDC != null && this._hRC != null);
    },
    setFrameZoomFactor: function (zoomFactor) {
        this._frameZoomFactor = zoomFactor;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection());
    },
    swapBuffers: function () {
    },
    setIMEKeyboardState: function (isOpen) {
    },
    setContentTranslateLeftTop: function (offsetLeft, offsetTop) {
        this._contentTranslateLeftTop = {left: offsetLeft, top: offsetTop};
    },
    getContentTranslateLeftTop: function () {
        return this._contentTranslateLeftTop;
    },
    getFrameSize: function () {
        return cc.size(this._frameSize.width, this._frameSize.height);
    },
    setFrameSize: function (width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        this._frame.style.width = width + "px";
        this._frame.style.height = height + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection());
    },
    centerWindow: function () {
    },
    getVisibleSize: function () {
        return cc.size(this._visibleRect.width,this._visibleRect.height);
    },
    getVisibleOrigin: function () {
        return cc.p(this._visibleRect.x,this._visibleRect.y);
    },
    canSetContentScaleFactor: function () {
        return true;
    },
    getResolutionPolicy: function () {
        return this._resolutionPolicy;
    },
    setResolutionPolicy: function (resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) {
            _t._resolutionPolicy = resolutionPolicy;
        }
        else {
            var _locPolicy = cc.ResolutionPolicy;
            if(resolutionPolicy === _locPolicy.EXACT_FIT)
                _t._resolutionPolicy = _t._rpExactFit;
            if(resolutionPolicy === _locPolicy.SHOW_ALL)
                _t._resolutionPolicy = _t._rpShowAll;
            if(resolutionPolicy === _locPolicy.NO_BORDER)
                _t._resolutionPolicy = _t._rpNoBorder;
            if(resolutionPolicy === _locPolicy.FIXED_HEIGHT)
                _t._resolutionPolicy = _t._rpFixedHeight;
            if(resolutionPolicy === _locPolicy.FIXED_WIDTH)
                _t._resolutionPolicy = _t._rpFixedWidth;
        }
    },
    setDesignResolutionSize: function (width, height, resolutionPolicy) {
        if (isNaN(width) || width == 0 || isNaN(height) || height == 0) {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
            return;
        }
        var _t = this;
        _t.setResolutionPolicy(resolutionPolicy);
        var policy = _t._resolutionPolicy;
        if (policy)
            policy.preApply(_t);
        else {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
            return;
        }
        if (cc.sys.isMobile)
            _t._setViewPortMeta();
        _t._initFrameSize();
        _t._designResolutionSize = cc.size(width, height);
        _t._originalDesignResolutionSize = cc.size(width, height);
        var result = policy.apply(_t, _t._designResolutionSize);
        if (result.scale && result.scale.length == 2) {
            _t._scaleX = result.scale[0];
            _t._scaleY = result.scale[1];
        }
        if (result.viewport) {
            var vp = _t._viewPortRect = result.viewport, visible = _t._visibleRect;
            visible.width = cc._canvas.width / _t._scaleX;
            visible.height = cc._canvas.height / _t._scaleY;
            visible.x = -vp.x / _t._scaleX;
            visible.y = -vp.y / _t._scaleY;
        }
        var director = cc.director;
        director._winSizeInPoints.width = _t._designResolutionSize.width;
        director._winSizeInPoints.height = _t._designResolutionSize.height;
        policy.postApply(_t);
        cc.winSize.width = director._winSizeInPoints.width;
        cc.winSize.height = director._winSizeInPoints.height;
        if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
            director._createStatsLabel();
            director.setGLDefaultValues();
        }
        _t._originalScaleX = _t._scaleX;
        _t._originalScaleY = _t._scaleY;
        if (cc.DOM)
            cc.DOM._resetEGLViewDiv();
        cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
    },
    getDesignResolutionSize: function () {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
    },
    setViewPortInPoints: function (x, y, w, h) {
        var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc._renderContext.viewport((x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor),
            (y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor),
            (w * locScaleX * locFrameZoomFactor),
            (h * locScaleY * locFrameZoomFactor));
    },
    setScissorInPoints: function (x, y, w, h) {
        var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc._renderContext.scissor((x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor),
            (y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor),
            (w * locScaleX * locFrameZoomFactor),
            (h * locScaleY * locFrameZoomFactor));
    },
    isScissorEnabled: function () {
        var gl = cc._renderContext;
        return gl.isEnabled(gl.SCISSOR_TEST);
    },
    getScissorRect: function () {
        var gl = cc._renderContext, scaleX = this._scaleX, scaleY = this._scaleY;
        var boxArr = gl.getParameter(gl.SCISSOR_BOX);
        return cc.rect((boxArr[0] - this._viewPortRect.x) / scaleX, (boxArr[1] - this._viewPortRect.y) / scaleY,
            boxArr[2] / scaleX, boxArr[3] / scaleY);
    },
    setViewName: function (viewName) {
        if (viewName != null && viewName.length > 0) {
            this._viewName = viewName;
        }
    },
    getViewName: function () {
        return this._viewName;
    },
    getViewPortRect: function () {
        return this._viewPortRect;
    },
    getScaleX: function () {
        return this._scaleX;
    },
    getScaleY: function () {
        return this._scaleY;
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio;
    },
    convertToLocationInView: function (tx, ty, relatedPos) {
        return {x: this._devicePixelRatio * (tx - relatedPos.left), y: this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty)};
    },
    _convertMouseToLocationInView: function(point, relatedPos) {
        var locViewPortRect = this._viewPortRect, _t = this;
        point.x = ((_t._devicePixelRatio * (point.x - relatedPos.left)) - locViewPortRect.x) / _t._scaleX;
        point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - point.y) - locViewPortRect.y) / _t._scaleY;
    },
    _convertTouchesWithScale: function(touches){
        var locViewPortRect = this._viewPortRect, locScaleX = this._scaleX, locScaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for( var i = 0; i < touches.length; i ++){
            selTouch = touches[i];
            selPoint = selTouch._point;
	        selPrePoint = selTouch._prevPoint;
            selTouch._setPoint((selPoint.x - locViewPortRect.x) / locScaleX,
                (selPoint.y - locViewPortRect.y) / locScaleY);
            selTouch._setPrevPoint((selPrePoint.x - locViewPortRect.x) / locScaleX,
                (selPrePoint.y - locViewPortRect.y) / locScaleY);
        }
    }
});
cc.EGLView._getInstance = function () {
    if (!this._instance) {
        this._instance = this._instance || new cc.EGLView();
        this._instance.initialize();
    }
    return this._instance;
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function (view) {
    },
    apply: function (view, designedResolution) {
    },
    postApply: function (view) {
    },
    _setupContainer: function (view, w, h) {
        var frame = view._frame;
        if (cc.view._autoFullScreen && cc.sys.isMobile && frame == document.documentElement) {
            cc.screen.autoFullScreen(frame);
        }
        var locCanvasElement = cc._canvas, locContainer = cc.container;
        locContainer.style.width = locCanvasElement.style.width = w + "px";
        locContainer.style.height = locCanvasElement.style.height = h + "px";
        var devicePixelRatio = view._devicePixelRatio = 1;
        if (view.isRetinaEnabled())
            devicePixelRatio = view._devicePixelRatio = window.devicePixelRatio || 1;
        locCanvasElement.width = w * devicePixelRatio;
        locCanvasElement.height = h * devicePixelRatio;
        var body = document.body, style;
        if (body && (style = body.style)) {
            style.paddingTop = style.paddingTop || "0px";
            style.paddingRight = style.paddingRight || "0px";
            style.paddingBottom = style.paddingBottom || "0px";
            style.paddingLeft = style.paddingLeft || "0px";
            style.borderTop = style.borderTop || "0px";
            style.borderRight = style.borderRight || "0px";
            style.borderBottom = style.borderBottom || "0px";
            style.borderLeft = style.borderLeft || "0px";
            style.marginTop = style.marginTop || "0px";
            style.marginRight = style.marginRight || "0px";
            style.marginBottom = style.marginBottom || "0px";
            style.marginLeft = style.marginLeft || "0px";
        }
    },
    _fixContainer: function () {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function (containerW, containerH, contentW, contentH, scaleX, scaleY) {
	    Math.abs(containerW - contentW) < 2 && (contentW = containerW);
	    Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect(Math.round((containerW - contentW) / 2),
                               Math.round((containerH - contentH) / 2),
                               contentW, contentH);
        if (cc._renderType == cc._RENDER_TYPE_CANVAS)
            cc._renderContext.translate(viewport.x, viewport.y + contentH);
        this._result.scale = [scaleX, scaleY];
        this._result.viewport = viewport;
        return this._result;
    },
    preApply: function (view) {
    },
    apply: function (view, designedResolution) {
        return {"scale": [1, 1]};
    },
    postApply: function (view) {
    }
});
(function () {
    var EqualToFrame = cc.ContainerStrategy.extend({
        apply: function (view) {
            this._setupContainer(view, view._frameSize.width, view._frameSize.height);
        }
    });
    var ProportionalToFrame = cc.ContainerStrategy.extend({
        apply: function (view, designedResolution) {
            var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.container.style,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = frameW / designW, scaleY = frameH / designH,
                containerW, containerH;
            scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, containerH = frameH);
            var offx = Math.round((frameW - containerW) / 2);
            var offy = Math.round((frameH - containerH) / 2);
            containerW = frameW - 2 * offx;
            containerH = frameH - 2 * offy;
            this._setupContainer(view, containerW, containerH);
            containerStyle.marginLeft = offx + "px";
            containerStyle.marginRight = offx + "px";
            containerStyle.marginTop = offy + "px";
            containerStyle.marginBottom = offy + "px";
        }
    });
    var EqualToWindow = EqualToFrame.extend({
        preApply: function (view) {
	        this._super(view);
            view._frame = document.documentElement;
        },
        apply: function (view) {
            this._super(view);
            this._fixContainer();
        }
    });
    var ProportionalToWindow = ProportionalToFrame.extend({
        preApply: function (view) {
	        this._super(view);
            view._frame = document.documentElement;
        },
        apply: function (view, designedResolution) {
            this._super(view, designedResolution);
            this._fixContainer();
        }
    });
    var OriginalContainer = cc.ContainerStrategy.extend({
        apply: function (view) {
            this._setupContainer(view, cc._canvas.width, cc._canvas.height);
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
    var ExactFit = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
    });
    var ShowAll = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = containerW / designW, scaleY = containerH / designH, scale = 0,
                contentW, contentH;
	        scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale)
                : (scale = scaleY, contentW = designW * scale, contentH = containerH);
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
    });
    var NoBorder = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = containerW / designW, scaleY = containerH / designH, scale,
                contentW, contentH;
            scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH)
                : (scale = scaleX, contentW = containerW, contentH = designH * scale);
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
    });
    var FixedHeight = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designH = designedResolution.height, scale = containerH / designH,
                contentW = containerW, contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function (view) {
            cc.director._winSizeInPoints = view.getVisibleSize();
        }
    });
    var FixedWidth = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, scale = containerW / designW,
                contentW = containerW, contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function (view) {
            cc.director._winSizeInPoints = view.getVisibleSize();
        }
    });
    cc.ContentStrategy.EXACT_FIT = new ExactFit();
    cc.ContentStrategy.SHOW_ALL = new ShowAll();
    cc.ContentStrategy.NO_BORDER = new NoBorder();
    cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
    cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
})();
cc.ResolutionPolicy = cc.Class.extend({
	_containerStrategy: null,
    _contentStrategy: null,
    ctor: function (containerStg, contentStg) {
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
    },
    preApply: function (view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
    },
    apply: function (view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
    },
    postApply: function (view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
    },
    setContainerStrategy: function (containerStg) {
        if (containerStg instanceof cc.ContainerStrategy)
            this._containerStrategy = containerStg;
    },
    setContentStrategy: function (contentStg) {
        if (contentStg instanceof cc.ContentStrategy)
            this._contentStrategy = contentStg;
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: false,
    _preOnFullScreenChange: null,
    _touchEvent: "",
	_fn: null,
	_fnMap: [
		[
			'requestFullscreen',
			'exitFullscreen',
			'fullscreenchange',
			'fullscreenEnabled',
			'fullscreenElement'
		],
		[
			'requestFullScreen',
			'exitFullScreen',
			'fullScreenchange',
			'fullScreenEnabled',
			'fullScreenElement'
		],
		[
			'webkitRequestFullScreen',
			'webkitCancelFullScreen',
			'webkitfullscreenchange',
			'webkitIsFullScreen',
			'webkitCurrentFullScreenElement'
		],
		[
			'mozRequestFullScreen',
			'mozCancelFullScreen',
			'mozfullscreenchange',
			'mozFullScreen',
			'mozFullScreenElement'
		],
		[
			'msRequestFullscreen',
			'msExitFullscreen',
			'MSFullscreenChange',
			'msFullscreenEnabled',
			'msFullscreenElement'
		]
	],
    init: function () {
	    this._fn = {};
	    var i, val, map = this._fnMap, valL;
	    for (i = 0, l = map.length; i < l; i++ ) {
		    val = map[ i ];
		    if ( val && val[1] in document ) {
			    for ( i = 0, valL = val.length; i < valL; i++ ) {
				    this._fn[ map[0][ i ] ] = val[ i ];
			    }
			    break;
		    }
	    }
		this._supportsFullScreen = (this._fn.requestFullscreen != undefined);
        this._touchEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
    },
    fullScreen: function() {
	    return this._supportsFullScreen && document[ this._fn.fullscreenEnabled ];
    },
    requestFullScreen: function (element, onFullScreenChange) {
	    if (!this._supportsFullScreen) return;
	    element = element || document.documentElement;
	    element[ this._fn.requestFullscreen ]();
	    if (onFullScreenChange) {
		    var eventName = this._fn.fullscreenchange;
		    if (this._preOnFullScreenChange)
			    document.removeEventListener(eventName, this._preOnFullScreenChange);
		    this._preOnFullScreenChange = onFullScreenChange;
            cc._addEventListener(document, eventName, onFullScreenChange, false);
	    }
        return element[ this._fn.requestFullscreen ]();
    },
    exitFullScreen: function () {
        return this._supportsFullScreen ? document[ this._fn.exitFullscreen ]() : true;
    },
    autoFullScreen: function (element, onFullScreenChange) {
	    element = element || document.body;
	    var touchTarget = cc._canvas || element;
        var theScreen = this;
        function callback() {
            theScreen.requestFullScreen(element, onFullScreenChange);
            touchTarget.removeEventListener(theScreen._touchEvent, callback);
        }
        this.requestFullScreen(element, onFullScreenChange);
        cc._addEventListener(touchTarget, this._touchEvent, callback);
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft:cc.p(0,0),
    topRight:cc.p(0,0),
    top:cc.p(0,0),
    bottomLeft:cc.p(0,0),
    bottomRight:cc.p(0,0),
    bottom:cc.p(0,0),
    center:cc.p(0,0),
    left:cc.p(0,0),
    right:cc.p(0,0),
    width:0,
    height:0,
    init:function(visibleRect){
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x,
            b = visibleRect.y,
            t = b + h,
            r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w/2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w/2;
        this.bottom.y = b;
        this.center.x = l + w/2;
        this.center.y = b + h/2;
        this.left.x = l;
        this.left.y = b + h/2;
        this.right.x = r;
        this.right.y = b + h/2;
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: false,
    _isRegisterEvent: false,
    _preTouchPoint: cc.p(0,0),
    _prevMousePoint: cc.p(0,0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict:{},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: false,
    _accelInterval: 1/30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function () {
        var temp = this._indexBitsUsed;
        for (var i = 0; i < this._maxTouches; i++) {
            if (!(temp & 0x00000001)) {
                this._indexBitsUsed |= (1 << i);
                return i;
            }
            temp >>= 1;
        }
        return -1;
    },
    _removeUsedIndexBit: function (index) {
        if (index < 0 || index >= this._maxTouches)
            return;
        var temp = 1 << index;
        temp = ~temp;
        this._indexBitsUsed &= temp;
    },
    _glView: null,
    handleTouchesBegin: function (touches) {
        var selTouch, index, curTouch, touchID, handleTouches = [], locTouchIntDict = this._touchesIntegerDict;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = locTouchIntDict[touchID];
            if(index == null){
                var unusedIndex = this._getUnUsedIndex();
                if (unusedIndex == -1) {
                    cc.log(cc._LogInfos.inputManager_handleTouchesBegin, unusedIndex);
                    continue;
                }
                curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
                curTouch._setPrevPoint(selTouch._prevPoint);
                locTouchIntDict[touchID] = unusedIndex;
                handleTouches.push(curTouch);
            }
        }
        if(handleTouches.length > 0){
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.BEGAN;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesMove: function(touches){
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = this._touchesIntegerDict[touchID];
            if(index == null){
                continue;
            }
            if(locTouches[index]){
                locTouches[index]._setPoint(selTouch._point);
                locTouches[index]._setPrevPoint(selTouch._prevPoint);
                handleTouches.push(locTouches[index]);
            }
        }
        if(handleTouches.length > 0){
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.MOVED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesEnd: function(touches){
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if(handleTouches.length > 0) {
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.ENDED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesCancel: function(touches){
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if(handleTouches.length > 0) {
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.CANCELLED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    getSetOfTouchesEndOrCancel: function(touches) {
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = locTouchesIntDict[touchID];
            if(index == null){
                continue;
            }
            if(locTouches[index]){
                locTouches[index]._setPoint(selTouch._point);
                locTouches[index]._setPrevPoint(selTouch._prevPoint);
                handleTouches.push(locTouches[index]);
                this._removeUsedIndexBit(index);
                delete locTouchesIntDict[touchID];
            }
        }
        return handleTouches;
    },
    getHTMLElementPosition: function (element) {
        var docElem = document.documentElement;
        var win = window;
        var box = null;
        if (cc.isFunction(element.getBoundingClientRect)) {
            box = element.getBoundingClientRect();
        } else {
            if (element instanceof HTMLCanvasElement) {
                box = {
                    left: 0,
                    top: 0,
                    width: element.width,
                    height: element.height
                };
            } else {
                box = {
                    left: 0,
                    top: 0,
                    width: parseInt(element.style.width),
                    height: parseInt(element.style.height)
                };
            }
        }
        return {
            left: box.left + win.pageXOffset - docElem.clientLeft,
            top: box.top + win.pageYOffset - docElem.clientTop,
            width: box.width,
            height: box.height
        };
    },
    getPreTouch: function(touch){
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
            if (locPreTouchPool[i].getID() == id) {
                preTouch = locPreTouchPool[i];
                break;
            }
        }
        if (!preTouch)
            preTouch = touch;
        return preTouch;
    },
    setPreTouch: function(touch){
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
            if (locPreTouchPool[i].getID() == id) {
                locPreTouchPool[i] = touch;
                find = true;
                break;
            }
        }
        if (!find) {
            if (locPreTouchPool.length <= 50) {
                locPreTouchPool.push(touch);
            } else {
                locPreTouchPool[this._preTouchPoolPointer] = touch;
                this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
            }
        }
    },
    getTouchByXY: function(tx, ty, pos){
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x,  location.y);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
    },
    getMouseEvent: function(location, pos, eventType){
        var locPreMouse = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(location, pos);
        var mouseEvent = new cc.EventMouse(eventType);
        mouseEvent.setLocation(location.x, location.y);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        return mouseEvent;
    },
    getPointByEvent: function(event, pos){
        if (event.pageX != null)
            return {x: event.pageX, y: event.pageY};
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        return {x: event.clientX, y: event.clientY};
    },
    getTouchesByEvent: function(event, pos){
        var touchArr = [], locView = this._glView;
        var touch_event, touch, preLocation;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
            touch_event = event.changedTouches[i];
            if (touch_event) {
                var location;
                if (cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType)
                    location = locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos);
                else
                    location = locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
                if (touch_event.identifier != null) {
                    touch = new cc.Touch(location.x, location.y, touch_event.identifier);
                    preLocation = this.getPreTouch(touch).getLocation();
                    touch._setPrevPoint(preLocation.x, preLocation.y);
                    this.setPreTouch(touch);
                } else {
                    touch = new cc.Touch(location.x, location.y);
                    touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                }
                locPreTouch.x = location.x;
                locPreTouch.y = location.y;
                touchArr.push(touch);
            }
        }
        return touchArr;
    },
    registerSystemEvent: function(element){
        if(this._isRegisterEvent) return;
        var locView = this._glView = cc.view;
        var selfPointer = this;
        var supportMouse = ('mouse' in cc.sys.capabilities), supportTouches = ('touches' in cc.sys.capabilities);
        if (supportMouse) {
            cc._addEventListener(window, 'mousedown', function () {
                selfPointer._mousePressed = true;
            }, false);
            cc._addEventListener(window, 'mouseup', function (event) {
                var savePressed = selfPointer._mousePressed;
                selfPointer._mousePressed = false;
                if(!savePressed)
                    return;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if (!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), location)){
                    if(!supportTouches)
                        selfPointer.handleTouchesEnd([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                    var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.UP);
                    mouseEvent.setButton(event.button);
                    cc.eventManager.dispatchEvent(mouseEvent);
                }
            }, false);
            cc._addEventListener(element,"mousedown", function (event) {
                selfPointer._mousePressed = true;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesBegin([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.DOWN);
                mouseEvent.setButton(event.button);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
                element.focus();
            }, false);
            cc._addEventListener(element, "mouseup", function (event) {
                selfPointer._mousePressed = false;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesEnd([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.UP);
                mouseEvent.setButton(event.button);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "mousemove", function (event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesMove([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.MOVE);
                if(selfPointer._mousePressed)
                    mouseEvent.setButton(event.button);
                else
                    mouseEvent.setButton(null);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "mousewheel", function (event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.SCROLL);
                mouseEvent.setButton(event.button);
                mouseEvent.setScrollData(0, event.wheelDelta);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "DOMMouseScroll", function(event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.SCROLL);
                mouseEvent.setButton(event.button);
                mouseEvent.setScrollData(0, event.detail * -120);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
        }
        if(window.navigator.msPointerEnabled){
            var _pointerEventsMap = {
                "MSPointerDown"     : selfPointer.handleTouchesBegin,
                "MSPointerMove"     : selfPointer.handleTouchesMove,
                "MSPointerUp"       : selfPointer.handleTouchesEnd,
                "MSPointerCancel"   : selfPointer.handleTouchesCancel
            };
            for(var eventName in _pointerEventsMap){
                (function(_pointerEvent, _touchEvent){
                    cc._addEventListener(element, _pointerEvent, function (event){
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.documentElement.scrollLeft;
                        pos.top -= document.documentElement.scrollTop;
                        _touchEvent.call(selfPointer, [selfPointer.getTouchByXY(event.clientX, event.clientY, pos)]);
                        event.stopPropagation();
                    }, false);
                })(eventName, _pointerEventsMap[eventName]);
            }
        }
        if(supportTouches) {
            cc._addEventListener(element,"touchstart", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesBegin(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
                element.focus();
            }, false);
            cc._addEventListener(element, "touchmove", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesMove(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "touchend", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesEnd(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "touchcancel", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesCancel(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
        }
        this._registerKeyboardEvent();
        this._registerAccelerometerEvent();
        this._isRegisterEvent = true;
    },
    _registerKeyboardEvent: function(){},
    _registerAccelerometerEvent: function(){},
    update:function(dt){
        if(this._accelCurTime > this._accelInterval){
            this._accelCurTime -= this._accelInterval;
            cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
    }
};
cc.AffineTransform = function (a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
};
cc.affineTransformMake = function (a, b, c, d, tx, ty) {
    return {a: a, b: b, c: c, d: d, tx: tx, ty: ty};
};
cc.pointApplyAffineTransform = function (point, t) {
    return {x: t.a * point.x + t.c * point.y + t.tx, y: t.b * point.x + t.d * point.y + t.ty};
};
cc._pointApplyAffineTransform = function (x, y, t) {
    return {x: t.a * x + t.c * y + t.tx,
        y: t.b * x + t.d * y + t.ty};
};
cc.sizeApplyAffineTransform = function (size, t) {
    return {width: t.a * size.width + t.c * size.height, height: t.b * size.width + t.d * size.height};
};
cc.affineTransformMakeIdentity = function () {
    return {a: 1.0, b: 0.0, c: 0.0, d: 1.0, tx: 0.0, ty: 0.0};
};
cc.affineTransformIdentity = function () {
    return {a: 1.0, b: 0.0, c: 0.0, d: 1.0, tx: 0.0, ty: 0.0};
};
cc.rectApplyAffineTransform = function (rect, anAffineTransform) {
    var top = cc.rectGetMinY(rect);
    var left = cc.rectGetMinX(rect);
    var right = cc.rectGetMaxX(rect);
    var bottom = cc.rectGetMaxY(rect);
    var topLeft = cc._pointApplyAffineTransform(left, top, anAffineTransform);
    var topRight = cc._pointApplyAffineTransform(right, top, anAffineTransform);
    var bottomLeft = cc._pointApplyAffineTransform(left, bottom, anAffineTransform);
    var bottomRight = cc._pointApplyAffineTransform(right, bottom, anAffineTransform);
    var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    return cc.rect(minX, minY, (maxX - minX), (maxY - minY));
};
cc._rectApplyAffineTransformIn = function(rect, anAffineTransform){
    var top = cc.rectGetMinY(rect);
    var left = cc.rectGetMinX(rect);
    var right = cc.rectGetMaxX(rect);
    var bottom = cc.rectGetMaxY(rect);
    var topLeft = cc._pointApplyAffineTransform(left, top, anAffineTransform);
    var topRight = cc._pointApplyAffineTransform(right, top, anAffineTransform);
    var bottomLeft = cc._pointApplyAffineTransform(left, bottom, anAffineTransform);
    var bottomRight = cc._pointApplyAffineTransform(right, bottom, anAffineTransform);
    var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    rect.x = minX;
    rect.y = minY;
    rect.width = maxX - minX;
    rect.height = maxY - minY;
    return rect;
};
cc.affineTransformTranslate = function (t, tx, ty) {
    return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx + t.a * tx + t.c * ty,
        ty: t.ty + t.b * tx + t.d * ty
    };
};
cc.affineTransformScale = function (t, sx, sy) {
    return {a: t.a * sx, b: t.b * sx, c: t.c * sy, d: t.d * sy, tx: t.tx, ty: t.ty};
};
cc.affineTransformRotate = function (aTransform, anAngle) {
    var fSin = Math.sin(anAngle);
    var fCos = Math.cos(anAngle);
    return {a: aTransform.a * fCos + aTransform.c * fSin,
        b: aTransform.b * fCos + aTransform.d * fSin,
        c: aTransform.c * fCos - aTransform.a * fSin,
        d: aTransform.d * fCos - aTransform.b * fSin,
        tx: aTransform.tx,
        ty: aTransform.ty};
};
cc.affineTransformConcat = function (t1, t2) {
    return {a: t1.a * t2.a + t1.b * t2.c,
        b: t1.a * t2.b + t1.b * t2.d,
        c: t1.c * t2.a + t1.d * t2.c,
        d: t1.c * t2.b + t1.d * t2.d,
        tx: t1.tx * t2.a + t1.ty * t2.c + t2.tx,
        ty: t1.tx * t2.b + t1.ty * t2.d + t2.ty};
};
cc.affineTransformEqualToTransform = function (t1, t2) {
    return ((t1.a === t2.a) && (t1.b === t2.b) && (t1.c === t2.c) && (t1.d === t2.d) && (t1.tx === t2.tx) && (t1.ty === t2.ty));
};
cc.affineTransformInvert = function (t) {
    var determinant = 1 / (t.a * t.d - t.b * t.c);
    return {a: determinant * t.d, b: -determinant * t.b, c: -determinant * t.c, d: determinant * t.a,
        tx: determinant * (t.c * t.ty - t.d * t.tx), ty: determinant * (t.b * t.tx - t.a * t.ty)};
};
cc.POINT_EPSILON = parseFloat('1.192092896e-07F');
cc.pNeg = function (point) {
    return cc.p(-point.x, -point.y);
};
cc.pAdd = function (v1, v2) {
    return cc.p(v1.x + v2.x, v1.y + v2.y);
};
cc.pSub = function (v1, v2) {
    return cc.p(v1.x - v2.x, v1.y - v2.y);
};
cc.pMult = function (point, floatVar) {
    return cc.p(point.x * floatVar, point.y * floatVar);
};
cc.pMidpoint = function (v1, v2) {
    return cc.pMult(cc.pAdd(v1, v2), 0.5);
};
cc.pDot = function (v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};
cc.pCross = function (v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
};
cc.pPerp = function (point) {
    return cc.p(-point.y, point.x);
};
cc.pRPerp = function (point) {
    return cc.p(point.y, -point.x);
};
cc.pProject = function (v1, v2) {
    return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
};
cc.pRotate = function (v1, v2) {
    return cc.p(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
};
cc.pUnrotate = function (v1, v2) {
    return cc.p(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
};
cc.pLengthSQ = function (v) {
    return cc.pDot(v, v);
};
cc.pDistanceSQ = function(point1, point2){
    return cc.pLengthSQ(cc.pSub(point1,point2));
};
cc.pLength = function (v) {
    return Math.sqrt(cc.pLengthSQ(v));
};
cc.pDistance = function (v1, v2) {
    return cc.pLength(cc.pSub(v1, v2));
};
cc.pNormalize = function (v) {
    return cc.pMult(v, 1.0 / cc.pLength(v));
};
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a));
};
cc.pToAngle = function (v) {
    return Math.atan2(v.y, v.x);
};
cc.clampf = function (value, min_inclusive, max_inclusive) {
    if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
    }
    return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};
cc.pClamp = function (p, min_inclusive, max_inclusive) {
    return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
};
cc.pFromSize = function (s) {
    return cc.p(s.width, s.height);
};
cc.pCompOp = function (p, opFunc) {
    return cc.p(opFunc(p.x), opFunc(p.y));
};
cc.pLerp = function (a, b, alpha) {
    return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
};
cc.pFuzzyEqual = function (a, b, variance) {
    if (a.x - variance <= b.x && b.x <= a.x + variance) {
        if (a.y - variance <= b.y && b.y <= a.y + variance)
            return true;
    }
    return false;
};
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y);
};
cc.pAngleSigned = function (a, b) {
    var a2 = cc.pNormalize(a);
    var b2 = cc.pNormalize(b);
    var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
    if (Math.abs(angle) < cc.POINT_EPSILON)
        return 0.0;
    return angle;
};
cc.pAngle = function (a, b) {
    var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    if (Math.abs(angle) < cc.POINT_EPSILON) return 0.0;
    return angle;
};
cc.pRotateByAngle = function (v, pivot, angle) {
    var r = cc.pSub(v, pivot);
    var cosa = Math.cos(angle), sina = Math.sin(angle);
    var t = r.x;
    r.x = t * cosa - r.y * sina + pivot.x;
    r.y = t * sina + r.y * cosa + pivot.y;
    return r;
};
cc.pLineIntersect = function (A, B, C, D, retP) {
    if ((A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)) {
        return false;
    }
    var BAx = B.x - A.x;
    var BAy = B.y - A.y;
    var DCx = D.x - C.x;
    var DCy = D.y - C.y;
    var ACx = A.x - C.x;
    var ACy = A.y - C.y;
    var denom = DCy * BAx - DCx * BAy;
    retP.x = DCx * ACy - DCy * ACx;
    retP.y = BAx * ACy - BAy * ACx;
    if (denom == 0) {
        if (retP.x == 0 || retP.y == 0) {
            return true;
        }
        return false;
    }
    retP.x = retP.x / denom;
    retP.y = retP.y / denom;
    return true;
};
cc.pSegmentIntersect = function (A, B, C, D) {
    var retP = cc.p(0, 0);
    if (cc.pLineIntersect(A, B, C, D, retP))
        if (retP.x >= 0.0 && retP.x <= 1.0 && retP.y >= 0.0 && retP.y <= 1.0)
            return true;
    return false;
};
cc.pIntersectPoint = function (A, B, C, D) {
    var retP = cc.p(0, 0);
    if (cc.pLineIntersect(A, B, C, D, retP)) {
        var P = cc.p(0, 0);
        P.x = A.x + retP.x * (B.x - A.x);
        P.y = A.y + retP.x * (B.y - A.y);
        return P;
    }
    return cc.p(0,0);
};
cc.pSameAs = function (A, B) {
    if ((A != null) && (B != null)) {
        return (A.x == B.x && A.y == B.y);
    }
    return false;
};
cc.pZeroIn = function(v) {
    v.x = 0;
    v.y = 0;
};
cc.pIn = function(v1, v2) {
    v1.x = v2.x;
    v1.y = v2.y;
};
cc.pMultIn = function(point, floatVar) {
    point.x *= floatVar;
    point.y *= floatVar;
};
cc.pSubIn = function(v1, v2) {
    v1.x -= v2.x;
    v1.y -= v2.y;
};
cc.pAddIn = function(v1, v2) {
    v1.x += v2.x;
    v1.y += v2.y;
};
cc.pNormalizeIn = function(v) {
    cc.pMultIn(v, 1.0 / Math.sqrt(v.x * v.x + v.y * v.y));
};
cc.Touch = cc.Class.extend({
    _point:null,
    _prevPoint:null,
    _id:0,
    _startPointCaptured: false,
    _startPoint:null,
    ctor:function (x, y, id) {
        this._point = cc.p(x || 0, y || 0);
        this._id = id || 0;
    },
    getLocation:function () {
        return {x: this._point.x, y: this._point.y};
    },
	getLocationX: function () {
		return this._point.x;
	},
	getLocationY: function () {
		return this._point.y;
	},
    getPreviousLocation:function () {
        return {x: this._prevPoint.x, y: this._prevPoint.y};
    },
    getStartLocation: function() {
        return {x: this._startPoint.x, y: this._startPoint.y};
    },
    getDelta:function () {
        return cc.pSub(this._point, this._prevPoint);
    },
    getLocationInView: function() {
        return {x: this._point.x, y: this._point.y};
    },
    getPreviousLocationInView: function(){
        return {x: this._prevPoint.x, y: this._prevPoint.y};
    },
    getStartLocationInView: function(){
        return {x: this._startPoint.x, y: this._startPoint.y};
    },
    getID:function () {
        return this._id;
    },
    getId:function () {
        cc.log("getId is deprecated. Please use getID instead.")
        return this._id;
    },
    setTouchInfo:function (id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.p(x || 0, y || 0);
        this._id = id;
        if(!this._startPointCaptured){
            this._startPoint = cc.p(this._point);
            this._startPointCaptured = true;
        }
    },
    _setPoint: function(x, y){
        if(y === undefined){
            this._point.x = x.x;
            this._point.y = x.y;
        }else{
            this._point.x = x;
            this._point.y = y;
        }
    },
    _setPrevPoint:function (x, y) {
        if(y === undefined)
            this._prevPoint = cc.p(x.x, x.y);
        else
            this._prevPoint = cc.p(x || 0, y || 0);
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: false,
    _currentTarget: null,
    _setCurrentTarget: function (target) {
        this._currentTarget = target;
    },
    ctor: function (type) {
        this._type = type;
    },
    getType: function () {
        return this._type;
    },
    stopPropagation: function () {
        this._isStopped = true;
    },
    isStopped: function () {
        return this._isStopped;
    },
    getCurrentTarget: function () {
        return this._currentTarget;
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function (eventName) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = eventName;
    },
    setUserData: function (data) {
        this._userData = data;
    },
    getUserData: function () {
        return this._userData;
    },
    getEventName: function () {
        return this._eventName;
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function (eventType) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = eventType;
    },
    setScrollData: function (scrollX, scrollY) {
        this._scrollX = scrollX;
        this._scrollY = scrollY;
    },
    getScrollX: function () {
        return this._scrollX;
    },
    getScrollY: function () {
        return this._scrollY;
    },
    setLocation: function (x, y) {
        this._x = x;
        this._y = y;
    },
    getLocation: function () {
        return {x: this._x, y: this._y};
    },
	getLocationInView: function() {
		return {x: this._x, y: cc.view._designResolutionSize.height - this._y};
	},
    _setPrevCursor: function (x, y) {
        this._prevX = x;
        this._prevY = y;
    },
    getDelta: function () {
        return {x: this._x - this._prevX, y: this._y - this._prevY};
    },
    getDeltaX: function () {
        return this._x - this._prevX;
    },
    getDeltaY: function () {
        return this._y - this._prevY;
    },
    setButton: function (button) {
        this._button = button;
    },
    getButton: function () {
        return this._button;
    },
    getLocationX: function () {
        return this._x;
    },
    getLocationY: function () {
        return this._y;
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function (arr) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = arr || [];
    },
    getEventCode: function () {
        return this._eventCode;
    },
    getTouches: function () {
        return this._touches;
    },
    _setEventCode: function (eventCode) {
        this._eventCode = eventCode;
    },
    _setTouches: function (touches) {
        this._touches = touches;
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {BEGAN: 0, MOVED: 1, ENDED: 2, CANCELLED: 3};
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: false,
    _fixedPriority: 0,
    _node: null,
    _paused: true,
    _isEnabled: true,
    ctor: function (type, listenerID, callback) {
        this._onEvent = callback;
        this._type = type || 0;
        this._listenerID = listenerID || "";
    },
    _setPaused: function (paused) {
        this._paused = paused;
    },
    _isPaused: function () {
        return this._paused;
    },
    _setRegistered: function (registered) {
        this._registered = registered;
    },
    _isRegistered: function () {
        return this._registered;
    },
    _getType: function () {
        return this._type;
    },
    _getListenerID: function () {
        return this._listenerID;
    },
    _setFixedPriority: function (fixedPriority) {
        this._fixedPriority = fixedPriority;
    },
    _getFixedPriority: function () {
        return this._fixedPriority;
    },
    _setSceneGraphPriority: function (node) {
        this._node = node;
    },
    _getSceneGraphPriority: function () {
        return this._node;
    },
    checkAvailable: function () {
        return this._onEvent != null;
    },
    clone: function () {
        return null;
    },
    setEnabled: function(enabled){
        this._isEnabled = enabled;
    },
    isEnabled: function(){
        return this._isEnabled;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function (listenerId, callback) {
        this._onCustomEvent = callback;
        var selfPointer = this;
        var listener = function (event) {
            if (selfPointer._onCustomEvent != null)
                selfPointer._onCustomEvent(event);
        };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, listenerId, listener);
    },
    checkAvailable: function () {
        return (cc.EventListener.prototype.checkAvailable.call(this) && this._onCustomEvent != null);
    },
    clone: function () {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
    }
});
cc._EventListenerCustom.create = function (eventName, callback) {
    return new cc._EventListenerCustom(eventName, callback);
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function () {
        var selfPointer = this;
        var listener = function (event) {
            var eventType = cc.EventMouse;
            switch (event._eventType) {
                case eventType.DOWN:
                    if (selfPointer.onMouseDown)
                        selfPointer.onMouseDown(event);
                    break;
                case eventType.UP:
                    if (selfPointer.onMouseUp)
                        selfPointer.onMouseUp(event);
                    break;
                case eventType.MOVE:
                    if (selfPointer.onMouseMove)
                        selfPointer.onMouseMove(event);
                    break;
                case eventType.SCROLL:
                    if (selfPointer.onMouseScroll)
                        selfPointer.onMouseScroll(event);
                    break;
                default:
                    break;
            }
        };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, listener);
    },
    clone: function () {
        var eventListener = new cc._EventListenerMouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
    },
    checkAvailable: function () {
        return true;
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function () {
    return new cc._EventListenerMouse();
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: false,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = [];
    },
    setSwallowTouches: function (needSwallow) {
        this.swallowTouches = needSwallow;
    },
    clone: function () {
        var eventListener = new cc._EventListenerTouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
    },
    checkAvailable: function () {
        if(!this.onTouchBegan){
            cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable);
            return false;
        }
        return true;
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function () {
    return new cc._EventListenerTouchOneByOne();
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function(){
       cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
    },
    clone: function(){
        var eventListener = new cc._EventListenerTouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
    },
    checkAvailable: function(){
        if (this.onTouchesBegan == null && this.onTouchesMoved == null
            && this.onTouchesEnded == null && this.onTouchesCancelled == null) {
            cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable);
            return false;
        }
        return true;
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function(){
     return new cc._EventListenerTouchAllAtOnce();
};
cc.EventListener.create = function(argObj){
    cc.assert(argObj&&argObj.event, cc._LogInfos.EventListener_create);
    var listenerType = argObj.event;
    delete argObj.event;
    var listener = null;
    if(listenerType === cc.EventListener.TOUCH_ONE_BY_ONE)
        listener = new cc._EventListenerTouchOneByOne();
    else if(listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE)
        listener = new cc._EventListenerTouchAllAtOnce();
    else if(listenerType === cc.EventListener.MOUSE)
        listener = new cc._EventListenerMouse();
    else if(listenerType === cc.EventListener.CUSTOM){
        listener = new cc._EventListenerCustom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
    } else if(listenerType === cc.EventListener.KEYBOARD)
        listener = new cc._EventListenerKeyboard();
    else if(listenerType === cc.EventListener.ACCELERATION){
        listener = new cc._EventListenerAcceleration(argObj.callback);
        delete argObj.callback;
    }
    for(var key in argObj) {
        listener[key] = argObj[key];
    }
    return listener;
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function () {
        this._fixedListeners = [];
        this._sceneGraphListeners = [];
    },
    size: function () {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
    },
    empty: function () {
        return (this._fixedListeners.length === 0) && (this._sceneGraphListeners.length === 0);
    },
    push: function (listener) {
        if (listener._getFixedPriority() == 0)
            this._sceneGraphListeners.push(listener);
        else
            this._fixedListeners.push(listener);
    },
    clearSceneGraphListeners: function () {
        this._sceneGraphListeners.length = 0;
    },
    clearFixedListeners: function () {
        this._fixedListeners.length = 0;
    },
    clear: function () {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
    },
    getFixedPriorityListeners: function () {
        return this._fixedListeners;
    },
    getSceneGraphPriorityListeners: function () {
        return this._sceneGraphListeners;
    }
});
cc.__getListenerID = function (event) {
    var eventType = cc.Event, getType = event.getType();
    if(getType === eventType.ACCELERATION)
        return cc._EventListenerAcceleration.LISTENER_ID;
    if(getType === eventType.CUSTOM)
        return event.getEventName();
    if(getType === eventType.KEYBOARD)
        return cc._EventListenerKeyboard.LISTENER_ID;
    if(getType === eventType.MOUSE)
        return cc._EventListenerMouse.LISTENER_ID;
    if(getType === eventType.TOUCH){
        cc.log(cc._LogInfos.__getListenerID);
    }
    return "";
};
cc.eventManager = {
    DIRTY_NONE:0,
    DIRTY_FIXED_PRIORITY:1 <<0,
    DIRTY_SCENE_GRAPH_PRIORITY : 1<< 1,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: false,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs:[cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function (node) {
        if (this._nodeListenersMap[node.__instanceId] != null)
            this._dirtyNodes.push(node);
        var _children = node.getChildren();
        for(var i = 0, len = _children.length; i < len; i++)
            this._setDirtyForNode(_children[i]);
    },
    pauseTarget: function (node, recursive) {
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners) {
            for ( i = 0, len = listeners.length; i < len; i++)
                listeners[i]._setPaused(true);
        }
        if (recursive === true) {
            var locChildren = node.getChildren();
            for ( i = 0, len = locChildren.length; i< len; i++)
                this.pauseTarget(locChildren[i], true);
        }
    },
    resumeTarget: function (node, recursive) {
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners){
            for ( i = 0, len = listeners.length; i < len; i++)
                listeners[i]._setPaused(false);
        }
        this._setDirtyForNode(node);
        if (recursive === true) {
            var locChildren = node.getChildren();
            for ( i = 0, len = locChildren.length; i< len; i++)
                this.resumeTarget(locChildren[i], true);
        }
    },
    _addListener: function (listener) {
        if (this._inDispatch === 0)
            this._forceAddEventListener(listener);
        else
            this._toAddedListeners.push(listener);
    },
    _forceAddEventListener: function (listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
            listeners = new cc._EventListenerVector();
            this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (listener._getFixedPriority() == 0) {
            this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
            var node = listener._getSceneGraphPriority();
            if (node == null)
                cc.log(cc._LogInfos.eventManager__forceAddEventListener);
            this._associateNodeAndEventListener(node, listener);
            if (node.isRunning())
                this.resumeTarget(node);
        } else
            this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
    },
    _getListeners: function (listenerID) {
        return this._listenersMap[listenerID];
    },
    _updateDirtyFlagForSceneGraph: function () {
        if (this._dirtyNodes.length == 0)
            return;
        var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
        for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
            selListeners = locNodeListenersMap[locDirtyNodes[i].__instanceId];
            if (selListeners) {
                for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
                    selListener = selListeners[j];
                    if (selListener)
                        this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                }
            }
        }
        this._dirtyNodes.length = 0;
    },
    _removeAllListenersInVector: function (listenerVector) {
        if (!listenerVector)
            return;
        var selListener;
        for (var i = 0; i < listenerVector.length;) {
            selListener = listenerVector[i];
            selListener._setRegistered(false);
            if (selListener._getSceneGraphPriority() != null){
                this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                selListener._setSceneGraphPriority(null);
            }
            if (this._inDispatch === 0)
                cc.arrayRemoveObject(listenerVector, selListener);
            else
                ++i;
        }
    },
    _removeListenersForListenerID: function (listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
            var fixedPriorityListeners = listeners.getFixedPriorityListeners();
            var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(sceneGraphPriorityListeners);
            this._removeAllListenersInVector(fixedPriorityListeners);
            delete this._priorityDirtyFlagMap[listenerID];
            if (!this._inDispatch) {
                listeners.clear();
                delete this._listenersMap[listenerID];
            }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = 0; i < locToAddedListeners.length;) {
            listener = locToAddedListeners[i];
            if (listener && listener._getListenerID() == listenerID)
                cc.arrayRemoveObject(locToAddedListeners, listener);
            else
                ++i;
        }
    },
    _sortEventListeners: function (listenerID) {
        var dirtyFlag = this.DIRTY_NONE,  locFlagMap = this._priorityDirtyFlagMap;
        if (locFlagMap[listenerID])
            dirtyFlag = locFlagMap[listenerID];
        if (dirtyFlag != this.DIRTY_NONE) {
            locFlagMap[listenerID] = this.DIRTY_NONE;
            if (dirtyFlag & this.DIRTY_FIXED_PRIORITY)
                this._sortListenersOfFixedPriority(listenerID);
            if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY){
                var rootNode = cc.director.getRunningScene();
                if(rootNode)
                    this._sortListenersOfSceneGraphPriority(listenerID, rootNode);
                else
                    locFlagMap[listenerID] = this.DIRTY_SCENE_GRAPH_PRIORITY;
            }
        }
    },
    _sortListenersOfSceneGraphPriority: function (listenerID, rootNode) {
        var listeners = this._getListeners(listenerID);
        if (!listeners)
            return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if(!sceneGraphListener || sceneGraphListener.length === 0)
            return;
        this._nodePriorityIndex = 0;
        this._nodePriorityMap = {};
        this._visitTarget(rootNode, true);
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
    },
    _sortEventListenersOfSceneGraphPriorityDes : function(l1, l2){
        var locNodePriorityMap = cc.eventManager._nodePriorityMap;
        if(!l1 || !l2 || !l1._getSceneGraphPriority() || !l2._getSceneGraphPriority())
            return -1;
        return locNodePriorityMap[l2._getSceneGraphPriority().__instanceId] - locNodePriorityMap[l1._getSceneGraphPriority().__instanceId];
    },
    _sortListenersOfFixedPriority: function (listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners)
            return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if(!fixedListeners || fixedListeners.length === 0)
            return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len;) {
            if (fixedListeners[index]._getFixedPriority() >= 0)
                break;
            ++index;
        }
        listeners.gt0Index = index;
    },
    _sortListenersOfFixedPriorityAsc: function (l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
    },
    _onUpdateListeners: function (listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners)
            return;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener;
        if (sceneGraphPriorityListeners) {
            for (i = 0; i < sceneGraphPriorityListeners.length;) {
                selListener = sceneGraphPriorityListeners[i];
                if (!selListener._isRegistered()) {
                    cc.arrayRemoveObject(sceneGraphPriorityListeners, selListener);
                } else
                    ++i;
            }
        }
        if (fixedPriorityListeners) {
            for (i = 0; i < fixedPriorityListeners.length;) {
                selListener = fixedPriorityListeners[i];
                if (!selListener._isRegistered())
                    cc.arrayRemoveObject(fixedPriorityListeners, selListener);
                else
                    ++i;
            }
        }
        if (sceneGraphPriorityListeners && sceneGraphPriorityListeners.length === 0)
            listeners.clearSceneGraphListeners();
        if (fixedPriorityListeners && fixedPriorityListeners.length === 0)
            listeners.clearFixedListeners();
    },
    _updateListeners: function (event) {
        var locInDispatch = this._inDispatch;
        cc.assert(locInDispatch > 0, cc._LogInfos.EventManager__updateListeners);
        if (event.getType() == cc.Event.TOUCH) {
            this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
            this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        } else
            this._onUpdateListeners(cc.__getListenerID(event));
        if(locInDispatch > 1)
            return;
        cc.assert(locInDispatch == 1, cc._LogInfos.EventManager__updateListeners_2);
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) {
            if (locListenersMap[selKey].empty()) {
                delete locPriorityDirtyFlagMap[selKey];
                delete locListenersMap[selKey];
            }
        }
        var locToAddedListeners = this._toAddedListeners;
        if (locToAddedListeners.length !== 0) {
            for (var i = 0, len = locToAddedListeners.length; i < len; i++)
                this._forceAddEventListener(locToAddedListeners[i]);
            this._toAddedListeners.length = 0;
        }
    },
    _onTouchEventCallback: function(listener, argsObj){
        if (!listener._isRegistered)
            return false;
        var event = argsObj.event, selTouch = argsObj.selTouch;
        event._setCurrentTarget(listener._node);
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), eventCode = cc.EventTouch.EventCode;
        if (getCode == eventCode.BEGAN) {
            if (listener.onTouchBegan) {
                isClaimed = listener.onTouchBegan(selTouch, event);
                if (isClaimed && listener._registered)
                    listener._claimedTouches.push(selTouch);
            }
        } else if (listener._claimedTouches.length > 0
            && ((removedIdx = listener._claimedTouches.indexOf(selTouch)) != -1)) {
            isClaimed = true;
            if(getCode === eventCode.MOVED && listener.onTouchMoved){
                listener.onTouchMoved(selTouch, event);
            } else if(getCode === eventCode.ENDED){
                if (listener.onTouchEnded)
                    listener.onTouchEnded(selTouch, event);
                if (listener._registered)
                    listener._claimedTouches.splice(removedIdx, 1);
            } else if(getCode === eventCode.CANCELLED){
                if (listener.onTouchCancelled)
                    listener.onTouchCancelled(selTouch, event);
                if (listener._registered)
                    listener._claimedTouches.splice(removedIdx, 1);
            }
        }
        if (event.isStopped()) {
            cc.eventManager._updateListeners(event);
            return true;
        }
        if (isClaimed && listener._registered && listener.swallowTouches) {
            if (argsObj.needsMutableSet)
                argsObj.touches.splice(selTouch, 1);
            return true;
        }
        return false;
    },
    _dispatchTouchEvent: function (event) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var oneByOneListeners = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        var allAtOnceListeners = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null == oneByOneListeners && null == allAtOnceListeners)
            return;
        var originalTouches = event.getTouches(), mutableTouches = cc.copyArray(originalTouches);
        var oneByOneArgsObj = {event: event, needsMutableSet: (oneByOneListeners && allAtOnceListeners), touches: mutableTouches, selTouch: null};
        if (oneByOneListeners) {
            for (var i = 0; i < originalTouches.length; i++) {
                oneByOneArgsObj.selTouch = originalTouches[i];
                this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                if (event.isStopped())
                    return;
            }
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
            this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {event: event, touches: mutableTouches});
            if (event.isStopped())
                return;
        }
        this._updateListeners(event);
    },
    _onTouchesEventCallback: function (listener, callbackParams) {
        if (!listener._registered)
            return false;
        var eventCode = cc.EventTouch.EventCode, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event._setCurrentTarget(listener._node);
        if(getCode == eventCode.BEGAN && listener.onTouchesBegan)
            listener.onTouchesBegan(touches, event);
        else if(getCode == eventCode.MOVED && listener.onTouchesMoved)
            listener.onTouchesMoved(touches, event);
        else if(getCode == eventCode.ENDED && listener.onTouchesEnded)
            listener.onTouchesEnded(touches, event);
        else if(getCode == eventCode.CANCELLED && listener.onTouchesCancelled)
            listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
            cc.eventManager._updateListeners(event);
            return true;
        }
        return false;
    },
    _associateNodeAndEventListener: function (node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (!listeners) {
            listeners = [];
            this._nodeListenersMap[node.__instanceId] = listeners;
        }
        listeners.push(listener);
    },
    _dissociateNodeAndEventListener: function (node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (listeners) {
            cc.arrayRemoveObject(listeners, listener);
            if (listeners.length === 0)
                delete this._nodeListenersMap[node.__instanceId];
        }
    },
    _dispatchEventToListeners: function (listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners) {
            if (fixedPriorityListeners.length !== 0) {
                for (; i < listeners.gt0Index; ++i) {
                    selListener = fixedPriorityListeners[i];
                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                        shouldStopPropagation = true;
                        break;
                    }
                }
            }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) {
            for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
                selListener = sceneGraphPriorityListeners[j];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = true;
                    break;
                }
            }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) {
            for (; i < fixedPriorityListeners.length; ++i) {
                selListener = fixedPriorityListeners[i];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = true;
                    break;
                }
            }
        }
    },
    _setDirty: function (listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        if (locDirtyFlagMap[listenerID] == null)
            locDirtyFlagMap[listenerID] = flag;
        else
            locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
    },
    _visitTarget: function (node, isRootNode) {
        var children = node.getChildren(), i = 0;
        var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
        if (childrenCount > 0) {
            var child;
            for (; i < childrenCount; i++) {
                child = children[i];
                if (child && child.getLocalZOrder() < 0)
                    this._visitTarget(child, false);
                else
                    break;
            }
            if (locNodeListenersMap[node.__instanceId] != null) {
                if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()])
                    locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
            }
            for (; i < childrenCount; i++) {
                child = children[i];
                if (child)
                    this._visitTarget(child, false);
            }
        } else {
            if (locNodeListenersMap[node.__instanceId] != null) {
                if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()])
                    locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
            }
        }
        if (isRootNode) {
            var globalZOrders = [];
            for (var selKey in locGlobalZOrderNodeMap)
                globalZOrders.push(selKey);
            globalZOrders.sort(this._sortNumberAsc);
            var zOrdersLen = globalZOrders.length, selZOrders, j, locNodePriorityMap = this._nodePriorityMap;
            for (i = 0; i < zOrdersLen; i++) {
                selZOrders = locGlobalZOrderNodeMap[globalZOrders[i]];
                for (j = 0; j < selZOrders.length; j++)
                    locNodePriorityMap[selZOrders[j]] = ++this._nodePriorityIndex;
            }
            this._globalZOrderNodeMap = {};
        }
    },
    _sortNumberAsc : function (a, b) {
        return a - b;
    },
    addListener: function (listener, nodeOrPriority) {
        cc.assert(listener && nodeOrPriority, cc._LogInfos.eventManager_addListener_2);
        if(!(listener instanceof cc.EventListener)){
            cc.assert(!cc.isNumber(nodeOrPriority), cc._LogInfos.eventManager_addListener_3);
            listener = cc.EventListener.create(listener);
        } else {
            if(listener._isRegistered()){
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return;
            }
        }
        if (!listener.checkAvailable())
            return;
        if (cc.isNumber(nodeOrPriority)) {
            if (nodeOrPriority == 0) {
                cc.log(cc._LogInfos.eventManager_addListener);
                return;
            }
            listener._setSceneGraphPriority(null);
            listener._setFixedPriority(nodeOrPriority);
            listener._setRegistered(true);
            listener._setPaused(false);
            this._addListener(listener);
        } else {
            listener._setSceneGraphPriority(nodeOrPriority);
            listener._setFixedPriority(0);
            listener._setRegistered(true);
            this._addListener(listener);
        }
        return listener;
    },
    addCustomListener: function (eventName, callback) {
        var listener = new cc._EventListenerCustom(eventName, callback);
        this.addListener(listener, 1);
        return listener;
    },
    removeListener: function (listener) {
        if (listener == null)
            return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
            var listeners = locListener[selKey];
            var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
            isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
            if (isFound){
               this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            }else{
                isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
                if (isFound)
                    this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
            }
            if (listeners.empty()) {
                delete this._priorityDirtyFlagMap[listener._getListenerID()];
                delete locListener[selKey];
            }
            if (isFound)
                break;
        }
        if (!isFound) {
            var locToAddedListeners = this._toAddedListeners;
            for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                var selListener = locToAddedListeners[i];
                if (selListener == listener) {
                    cc.arrayRemoveObject(locToAddedListeners, selListener);
                    break;
                }
            }
        }
    },
    _removeListenerInVector : function(listeners, listener){
        if (listeners == null)
            return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
            var selListener = listeners[i];
            if (selListener == listener) {
                selListener._setRegistered(false);
                if (selListener._getSceneGraphPriority() != null){
                    this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                    selListener._setSceneGraphPriority(null);
                }
                if (this._inDispatch == 0)
                    cc.arrayRemoveObject(listeners, selListener);
                return true;
            }
        }
        return false;
    },
    removeListeners: function (listenerType, recursive) {
        var _t = this;
        if (listenerType instanceof cc.Node) {
            delete _t._nodePriorityMap[listenerType.__instanceId];
            cc.arrayRemoveObject(_t._dirtyNodes, listenerType);
            var listeners = _t._nodeListenersMap[listenerType.__instanceId], i;
            if (listeners) {
                var listenersCopy = cc.copyArray(listeners);
                for (i = 0; i < listenersCopy.length; i++)
                    _t.removeListener(listenersCopy[i]);
                listenersCopy.length = 0;
            }
            var locToAddedListeners = _t._toAddedListeners;
            for (i = 0; i < locToAddedListeners.length; ) {
                var listener = locToAddedListeners[i];
                if (listener._getSceneGraphPriority() == listenerType) {
                    listener._setSceneGraphPriority(null);
                    listener._setRegistered(false);
                    locToAddedListeners.splice(i, 1);
                } else
                    ++i;
            }
            if (recursive === true) {
                var locChildren = listenerType.getChildren(), len;
                for (i = 0, len = locChildren.length; i< len; i++)
                    _t.removeListeners(locChildren[i], true);
            }
        } else {
            if (listenerType == cc.EventListener.TOUCH_ONE_BY_ONE)
                _t._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID);
            else if (listenerType == cc.EventListener.TOUCH_ALL_AT_ONCE)
                _t._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
            else if (listenerType == cc.EventListener.MOUSE)
                _t._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID);
            else if (listenerType == cc.EventListener.ACCELERATION)
                _t._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID);
            else if (listenerType == cc.EventListener.KEYBOARD)
                _t._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID);
            else
                cc.log(cc._LogInfos.eventManager_removeListeners);
        }
    },
    removeCustomListeners: function (customEventName) {
        this._removeListenersForListenerID(customEventName);
    },
    removeAllListeners: function () {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners){
            if(locInternalCustomEventIDs.indexOf(selKey) === -1)
                this._removeListenersForListenerID(selKey);
        }
    },
    setPriority: function (listener, fixedPriority) {
        if (listener == null)
            return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
            var selListeners = locListeners[selKey];
            var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
            if (fixedPriorityListeners) {
                var found = fixedPriorityListeners.indexOf(listener);
                if (found != -1) {
                    if(listener._getSceneGraphPriority() != null)
                        cc.log(cc._LogInfos.eventManager_setPriority);
                    if (listener._getFixedPriority() !== fixedPriority) {
                        listener._setFixedPriority(fixedPriority);
                        this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                    }
                    return;
                }
            }
        }
    },
    setEnabled: function (enabled) {
        this._isEnabled = enabled;
    },
    isEnabled: function () {
        return this._isEnabled;
    },
    dispatchEvent: function (event) {
        if (!this._isEnabled)
            return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if(!event || !event.getType)
            throw "event is undefined";
        if (event.getType() == cc.Event.TOUCH) {
            this._dispatchTouchEvent(event);
            this._inDispatch--;
            return;
        }
        var listenerID = cc.__getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (selListeners != null)
            this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
        this._updateListeners(event);
        this._inDispatch--;
    },
    _onListenerCallback: function(listener, event){
        event._setCurrentTarget(listener._getSceneGraphPriority());
        listener._onEvent(event);
        return event.isStopped();
    },
    dispatchCustomEvent: function (eventName, optionalUserData) {
        var ev = new cc.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
    }
};
cc.EventHelper = function(){};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function ( object ) {
        object.addEventListener = cc.EventHelper.prototype.addEventListener;
        object.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        object.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        object.dispatchEvent = cc.EventHelper.prototype.dispatchEvent;
    },
    addEventListener: function ( type, listener, target ) {
        if ( this._listeners === undefined )
            this._listeners = {};
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined )
            listeners[ type ] = [];
        if ( !this.hasEventListener(type, listener, target))
            listeners[ type ].push( {callback:listener, eventTarget: target} );
    },
    hasEventListener: function ( type, listener, target ) {
        if ( this._listeners === undefined )
            return false;
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined ) {
            for(var i = 0, len = listeners.length; i < len ; i++){
                var selListener = listeners[i];
                if(selListener.callback == listener && selListener.eventTarget == target)
                    return true;
            }
        }
        return false;
    },
    removeEventListener: function( type, target){
        if ( this._listeners === undefined )
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[ type ];
        if ( listenerArray !== undefined ) {
            for(var i = 0; i < listenerArray.length ; ){
                var selListener = listenerArray[i];
                if(selListener.eventTarget == target)
                    listenerArray.splice( i, 1 );
                else
                    i++
            }
        }
    },
    dispatchEvent: function ( event, clearAfterDispatch ) {
        if ( this._listeners === undefined )
            return;
        if(clearAfterDispatch == null)
            clearAfterDispatch = true;
        var listeners = this._listeners;
        var listenerArray = listeners[ event];
        if ( listenerArray !== undefined ) {
            var array = [];
            var length = listenerArray.length;
            for ( var i = 0; i < length; i ++ ) {
                array[ i ] = listenerArray[ i ];
            }
            for ( i = 0; i < length; i ++ ) {
                array[ i ].callback.call( array[i].eventTarget, this );
            }
            if(clearAfterDispatch)
                listenerArray.length = 0;
        }
    }
};
cc._tmp.PrototypeCCNode = function () {
    var _p = cc.Node.prototype;
    cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
    cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
    _p.width;
    cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
    _p.height;
    cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
    _p.anchorX;
    cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
    _p.anchorY;
    cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
    _p.skewX;
    cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
    _p.skewY;
    cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
    _p.zIndex;
    cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
    _p.vertexZ;
    cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
    _p.rotation;
    cc.defineGetterSetter(_p, "rotation", _p.getRotation, _p.setRotation);
    _p.rotationX;
    cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
    _p.rotationY;
    cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
    _p.scale;
    cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
    _p.scaleX;
    cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX);
    _p.scaleY;
    cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY);
    _p.children;
    cc.defineGetterSetter(_p, "children", _p.getChildren);
    _p.childrenCount;
    cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
    _p.parent;
    cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
    _p.visible;
    cc.defineGetterSetter(_p, "visible", _p.isVisible, _p.setVisible);
    _p.running;
    cc.defineGetterSetter(_p, "running", _p.isRunning);
    _p.ignoreAnchor;
    cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
    _p.tag;
    _p.userData;
    _p.userObject;
    _p.arrivalOrder;
    _p.actionManager;
    cc.defineGetterSetter(_p, "actionManager", _p.getActionManager, _p.setActionManager);
    _p.scheduler;
    cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
    _p.shaderProgram;
    cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
    _p.opacity;
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    _p.opacityModifyRGB;
    cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB);
    _p.cascadeOpacity;
    cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
    _p.color;
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    _p.cascadeColor;
    cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0.0,
    _rotationX: 0,
    _rotationY: 0.0,
    _scaleX: 1.0,
    _scaleY: 1.0,
    _position: null,
    _normalizedPosition:null,
    _usingNormalizedPosition: false,
    _normalizedPositionDirty: false,
    _skewX: 0.0,
    _skewY: 0.0,
    _children: null,
    _visible: true,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: false,
    _parent: null,
    _ignoreAnchorPointForPosition: false,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: true,
    _inverseDirty: true,
    _cacheDirty: false,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _transformWorld: null,
    _inverse: null,
    _reorderChildDirty: false,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: false,
    _additionalTransformDirty: false,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: false,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: false,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: false,
    _cascadeOpacityEnabled: false,
    _hashOfName: 0,
    _curLevel: -1,
    _rendererCmd:null,
    _renderCmdDirty: false,
    _initNode: function () {
        var _t = this;
        _t._anchorPoint = cc.p(0, 0);
        _t._anchorPointInPoints = cc.p(0, 0);
        _t._contentSize = cc.size(0, 0);
        _t._position = cc.p(0, 0);
        _t._normalizedPosition = cc.p(0,0);
        _t._children = [];
        _t._transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        _t._transformWorld = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        var director = cc.director;
        _t._actionManager = director.getActionManager();
        _t._scheduler = director.getScheduler();
        _t._initializedNode = true;
        _t._additionalTransform = cc.affineTransformMakeIdentity();
        if (cc.ComponentContainer) {
            _t._componentContainer = new cc.ComponentContainer(_t);
        }
        this._displayedOpacity = 255;
        this._realOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeColorEnabled = false;
        this._cascadeOpacityEnabled = false;
    },
    init: function () {
        if (this._initializedNode === false)
            this._initNode();
        return true;
    },
    _arrayMakeObjectsPerformSelector: function (array, callbackType) {
        if (!array || array.length === 0)
            return;
        var i, len = array.length, node;
        var nodeCallbackType = cc.Node._StateCallbackType;
        switch (callbackType) {
            case nodeCallbackType.onEnter:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onEnter();
                }
                break;
            case nodeCallbackType.onExit:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onExit();
                }
                break;
            case nodeCallbackType.onEnterTransitionDidFinish:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onEnterTransitionDidFinish();
                }
                break;
            case nodeCallbackType.cleanup:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.cleanup();
                }
                break;
            case nodeCallbackType.updateTransform:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.updateTransform();
                }
                break;
            case nodeCallbackType.onExitTransitionDidStart:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onExitTransitionDidStart();
                }
                break;
            case nodeCallbackType.sortAllChildren:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.sortAllChildren();
                }
                break;
            default :
                cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector);
                break;
        }
    },
    setNodeDirty: null,
    attr: function (attrs) {
        for (var key in attrs) {
            this[key] = attrs[key];
        }
    },
    getSkewX: function () {
        return this._skewX;
    },
    setSkewX: function (newSkewX) {
        this._skewX = newSkewX;
        this.setNodeDirty();
    },
    getSkewY: function () {
        return this._skewY;
    },
    setSkewY: function (newSkewY) {
        this._skewY = newSkewY;
        this.setNodeDirty();
    },
    setLocalZOrder: function (localZOrder) {
        this._localZOrder = localZOrder;
        if (this._parent)
            this._parent.reorderChild(this, localZOrder);
        cc.eventManager._setDirtyForNode(this);
    },
    _setLocalZOrder: function (localZOrder) {
        this._localZOrder = localZOrder;
    },
    getLocalZOrder: function () {
        return this._localZOrder;
    },
    getZOrder: function () {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder();
    },
    setZOrder: function (z) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(z);
    },
    setGlobalZOrder: function (globalZOrder) {
        if (this._globalZOrder != globalZOrder) {
            this._globalZOrder = globalZOrder;
            cc.eventManager._setDirtyForNode(this);
        }
    },
    getGlobalZOrder: function () {
        return this._globalZOrder;
    },
    getVertexZ: function () {
        return this._vertexZ;
    },
    setVertexZ: function (Var) {
        this._vertexZ = Var;
    },
    getRotation: function () {
        if (this._rotationX !== this._rotationY)
            cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX;
    },
    setRotation: function (newRotation) {
        this._rotationX = this._rotationY = newRotation;
        this._rotationRadiansX = this._rotationX * 0.017453292519943295;
        this._rotationRadiansY = this._rotationY * 0.017453292519943295;
        this.setNodeDirty();
    },
    getRotationX: function () {
        return this._rotationX;
    },
    setRotationX: function (rotationX) {
        this._rotationX = rotationX;
        this._rotationRadiansX = this._rotationX * 0.017453292519943295;
        this.setNodeDirty();
    },
    getRotationY: function () {
        return this._rotationY;
    },
    setRotationY: function (rotationY) {
        this._rotationY = rotationY;
        this._rotationRadiansY = this._rotationY * 0.017453292519943295;
        this.setNodeDirty();
    },
    getScale: function () {
        if (this._scaleX !== this._scaleY)
            cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX;
    },
    setScale: function (scale, scaleY) {
        this._scaleX = scale;
        this._scaleY = (scaleY || scaleY === 0) ? scaleY : scale;
        this.setNodeDirty();
    },
    getScaleX: function () {
        return this._scaleX;
    },
    setScaleX: function (newScaleX) {
        this._scaleX = newScaleX;
        this.setNodeDirty();
    },
    getScaleY: function () {
        return this._scaleY;
    },
    setScaleY: function (newScaleY) {
        this._scaleY = newScaleY;
        this.setNodeDirty();
    },
    setPosition: function (newPosOrxValue, yValue) {
        var locPosition = this._position;
        if (yValue === undefined) {
            locPosition.x = newPosOrxValue.x;
            locPosition.y = newPosOrxValue.y;
        } else {
            locPosition.x = newPosOrxValue;
            locPosition.y = yValue;
        }
        this.setNodeDirty();
        this._usingNormalizedPosition = false;
    },
    setNormalizedPosition: function(posOrX, y){
        var locPosition = this._normalizedPosition;
        if (y === undefined) {
            locPosition.x = posOrX.x;
            locPosition.y = posOrX.y;
        } else {
            locPosition.x = posOrX;
            locPosition.y = y;
        }
        this.setNodeDirty();
        this._normalizedPositionDirty = this._usingNormalizedPosition = true;
    },
    getPosition: function () {
        return cc.p(this._position);
    },
    getNormalizedPosition: function(){
        return cc.p(this._normalizedPosition);
    },
    getPositionX: function () {
        return this._position.x;
    },
    setPositionX: function (x) {
        this._position.x = x;
        this.setNodeDirty();
    },
    getPositionY: function () {
        return  this._position.y;
    },
    setPositionY: function (y) {
        this._position.y = y;
        this.setNodeDirty();
    },
    getChildrenCount: function () {
        return this._children.length;
    },
    getChildren: function () {
        return this._children;
    },
    isVisible: function () {
        return this._visible;
    },
    setVisible: function (visible) {
        if(this._visible != visible){
            this._visible = visible;
            if(visible) this.setNodeDirty();
            cc.renderer.childrenOrderDirty = true;
        }
    },
    getAnchorPoint: function () {
        return cc.p(this._anchorPoint);
    },
    setAnchorPoint: function (point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (y === undefined) {
            if ((point.x === locAnchorPoint.x) && (point.y === locAnchorPoint.y))
                return;
            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
        } else {
            if ((point === locAnchorPoint.x) && (y === locAnchorPoint.y))
                return;
            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
        }
        var locAPP = this._anchorPointInPoints, locSize = this._contentSize;
        locAPP.x = locSize.width * locAnchorPoint.x;
        locAPP.y = locSize.height * locAnchorPoint.y;
        this.setNodeDirty();
    },
    _getAnchor: function () {
        return this._anchorPoint;
    },
    _setAnchor: function (p) {
        var x = p.x, y = p.y;
        if (this._anchorPoint.x !== x) {
            this._anchorPoint.x = x;
            this._anchorPointInPoints.x = this._contentSize.width * x;
        }
        if (this._anchorPoint.y !== y) {
            this._anchorPoint.y = y;
            this._anchorPointInPoints.y = this._contentSize.height * y;
        }
        this.setNodeDirty();
    },
    _getAnchorX: function () {
        return this._anchorPoint.x;
    },
    _setAnchorX: function (x) {
        if (this._anchorPoint.x === x) return;
        this._anchorPoint.x = x;
        this._anchorPointInPoints.x = this._contentSize.width * x;
        this.setNodeDirty();
    },
    _getAnchorY: function () {
        return this._anchorPoint.y;
    },
    _setAnchorY: function (y) {
        if (this._anchorPoint.y === y) return;
        this._anchorPoint.y = y;
        this._anchorPointInPoints.y = this._contentSize.height * y;
        this.setNodeDirty();
    },
    getAnchorPointInPoints: function () {
        return cc.p(this._anchorPointInPoints);
    },
    _getWidth: function () {
        return this._contentSize.width;
    },
    _setWidth: function (width) {
        this._contentSize.width = width;
        this._anchorPointInPoints.x = width * this._anchorPoint.x;
        this.setNodeDirty();
    },
    _getHeight: function () {
        return this._contentSize.height;
    },
    _setHeight: function (height) {
        this._contentSize.height = height;
        this._anchorPointInPoints.y = height * this._anchorPoint.y;
        this.setNodeDirty();
    },
    getContentSize: function () {
        return cc.size(this._contentSize);
    },
    setContentSize: function (size, height) {
        var locContentSize = this._contentSize;
        if (height === undefined) {
            if ((size.width === locContentSize.width) && (size.height === locContentSize.height))
                return;
            locContentSize.width = size.width;
            locContentSize.height = size.height;
        } else {
            if ((size === locContentSize.width) && (height === locContentSize.height))
                return;
            locContentSize.width = size;
            locContentSize.height = height;
        }
        var locAPP = this._anchorPointInPoints, locAnchorPoint = this._anchorPoint;
        locAPP.x = locContentSize.width * locAnchorPoint.x;
        locAPP.y = locContentSize.height * locAnchorPoint.y;
        this.setNodeDirty();
    },
    isRunning: function () {
        return this._running;
    },
    getParent: function () {
        return this._parent;
    },
    setParent: function (parent) {
        this._parent = parent;
    },
    isIgnoreAnchorPointForPosition: function () {
        return this._ignoreAnchorPointForPosition;
    },
    ignoreAnchorPointForPosition: function (newValue) {
        if (newValue != this._ignoreAnchorPointForPosition) {
            this._ignoreAnchorPointForPosition = newValue;
            this.setNodeDirty();
        }
    },
    getTag: function () {
        return this.tag;
    },
    setTag: function (tag) {
        this.tag = tag;
    },
    setName: function(name){
         this._name = name;
    },
    getName: function(){
        return this._name;
    },
    getUserData: function () {
        return this.userData;
    },
    setUserData: function (Var) {
        this.userData = Var;
    },
    getUserObject: function () {
        return this.userObject;
    },
    setUserObject: function (newValue) {
        if (this.userObject != newValue) {
            this.userObject = newValue;
        }
    },
    getOrderOfArrival: function () {
        return this.arrivalOrder;
    },
    setOrderOfArrival: function (Var) {
        this.arrivalOrder = Var;
    },
    getActionManager: function () {
        if (!this._actionManager) {
            this._actionManager = cc.director.getActionManager();
        }
        return this._actionManager;
    },
    setActionManager: function (actionManager) {
        if (this._actionManager != actionManager) {
            this.stopAllActions();
            this._actionManager = actionManager;
        }
    },
    getScheduler: function () {
        if (!this._scheduler) {
            this._scheduler = cc.director.getScheduler();
        }
        return this._scheduler;
    },
    setScheduler: function (scheduler) {
        if (this._scheduler != scheduler) {
            this.unscheduleAllCallbacks();
            this._scheduler = scheduler;
        }
    },
    boundingBox: function(){
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox();
    },
    getBoundingBox: function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
    },
    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup);
    },
    getChildByTag: function (aTag) {
        var __children = this._children;
        if (__children != null) {
            for (var i = 0; i < __children.length; i++) {
                var node = __children[i];
                if (node && node.tag == aTag)
                    return node;
            }
        }
        return null;
    },
    getChildByName: function(name){
        if(!name){
            cc.log("Invalid name");
            return null;
        }
        var locChildren = this._children;
        for(var i = 0, len = locChildren.length; i < len; i++){
           if(locChildren[i]._name == name)
            return locChildren[i];
        }
        return null;
    },
    addChild: function (child, localZOrder, tag) {
        localZOrder = localZOrder === undefined ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if(cc.isUndefined(tag)){
            tag = undefined;
            name = child._name;
        } else if(cc.isString(tag)){
            name = tag;
            tag = undefined;
        } else if(cc.isNumber(tag)){
            setTag = true;
            name = "";
        }
        cc.assert(child, cc._LogInfos.Node_addChild_3);
        cc.assert(child._parent === null, "child already added. It can't be added again");
        this._addChildHelper(child, localZOrder, tag, name, setTag);
    },
    _addChildHelper: function(child, localZOrder, tag, name, setTag){
        if(!this._children)
            this._children = [];
        this._insertChild(child, localZOrder);
        if(setTag)
            child.setTag(tag);
        else
            child.setName(name);
        child.setParent(this);
        child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if( this._running ){
            child.onEnter();
            if (this._isTransitionFinished)
                child.onEnterTransitionDidFinish();
        }
        if (this._cascadeColorEnabled)
            this._enableCascadeColor();
        if (this._cascadeOpacityEnabled)
            this._enableCascadeOpacity();
    },
    removeFromParent: function (cleanup) {
        if (this._parent) {
            if (cleanup == null)
                cleanup = true;
            this._parent.removeChild(this, cleanup);
        }
    },
    removeFromParentAndCleanup: function (cleanup) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(cleanup);
    },
    removeChild: function (child, cleanup) {
        if (this._children.length === 0)
            return;
        if (cleanup == null)
            cleanup = true;
        if (this._children.indexOf(child) > -1)
            this._detachChild(child, cleanup);
        this.setNodeDirty();
        cc.renderer.childrenOrderDirty = true;
    },
    removeChildByTag: function (tag, cleanup) {
        if (tag === cc.NODE_TAG_INVALID)
            cc.log(cc._LogInfos.Node_removeChildByTag);
        var child = this.getChildByTag(tag);
        if (child == null)
            cc.log(cc._LogInfos.Node_removeChildByTag_2, tag);
        else
            this.removeChild(child, cleanup);
    },
    removeAllChildrenWithCleanup: function (cleanup) {
        this.removeAllChildren(cleanup);
    },
    removeAllChildren: function (cleanup) {
        var __children = this._children;
        if (__children != null) {
            if (cleanup == null)
                cleanup = true;
            for (var i = 0; i < __children.length; i++) {
                var node = __children[i];
                if (node) {
                    if (this._running) {
                        node.onExitTransitionDidStart();
                        node.onExit();
                    }
                    if (cleanup)
                        node.cleanup();
                    node.parent = null;
                }
            }
            this._children.length = 0;
        }
    },
    _detachChild: function (child, doCleanup) {
        if (this._running) {
            child.onExitTransitionDidStart();
            child.onExit();
        }
        if (doCleanup)
            child.cleanup();
        child.parent = null;
        child._cachedParent = null;
        cc.arrayRemoveObject(this._children, child);
    },
    _insertChild: function (child, z) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        this._children.push(child);
        child._setLocalZOrder(z);
    },
    reorderChild: function (child, zOrder) {
        cc.assert(child, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        child.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        child._setLocalZOrder(zOrder);
        this.setNodeDirty();
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var _children = this._children;
            var len = _children.length, i, j, tmp;
            for(i=1; i<len; i++){
                tmp = _children[i];
                j = i - 1;
                while(j >= 0){
                    if(tmp._localZOrder < _children[j]._localZOrder){
                        _children[j+1] = _children[j];
                    }else if(tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder){
                        _children[j+1] = _children[j];
                    }else{
                        break;
                    }
                    j--;
                }
                _children[j+1] = tmp;
            }
            this._reorderChildDirty = false;
        }
    },
    draw: function (ctx) {
    },
    transformAncestors: function () {
        if (this._parent != null) {
            this._parent.transformAncestors();
            this._parent.transform();
        }
    },
    onEnter: function () {
        this._isTransitionFinished = false;
        this._running = true;//should be running before resumeSchedule
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnter);
        this.resume();
    },
    onEnterTransitionDidFinish: function () {
        this._isTransitionFinished = true;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnterTransitionDidFinish);
    },
    onExitTransitionDidStart: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExitTransitionDidStart);
    },
    onExit: function () {
        this._running = false;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExit);
        this.removeAllComponents();
    },
    runAction: function (action) {
        cc.assert(action, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(action, this, !this._running);
        return action;
    },
    stopAllActions: function () {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this);
    },
    stopAction: function (action) {
        this.actionManager.removeAction(action);
    },
    stopActionByTag: function (tag) {
        if (tag === cc.ACTION_TAG_INVALID) {
            cc.log(cc._LogInfos.Node_stopActionByTag);
            return;
        }
        this.actionManager.removeActionByTag(tag, this);
    },
    getActionByTag: function (tag) {
        if (tag === cc.ACTION_TAG_INVALID) {
            cc.log(cc._LogInfos.Node_getActionByTag);
            return null;
        }
        return this.actionManager.getActionByTag(tag, this);
    },
    getNumberOfRunningActions: function () {
        return this.actionManager.numberOfRunningActionsInTarget(this);
    },
    scheduleUpdate: function () {
        this.scheduleUpdateWithPriority(0);
    },
    scheduleUpdateWithPriority: function (priority) {
        this.scheduler.scheduleUpdateForTarget(this, priority, !this._running);
    },
    unscheduleUpdate: function () {
        this.scheduler.unscheduleUpdateForTarget(this);
    },
    schedule: function (callback_fn, interval, repeat, delay) {
        interval = interval || 0;
        cc.assert(callback_fn, cc._LogInfos.Node_schedule);
        cc.assert(interval >= 0, cc._LogInfos.Node_schedule_2);
        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        this.scheduler.scheduleCallbackForTarget(this, callback_fn, interval, repeat, delay, !this._running);
    },
    scheduleOnce: function (callback_fn, delay) {
        this.schedule(callback_fn, 0.0, 0, delay);
    },
    unschedule: function (callback_fn) {
        if (!callback_fn)
            return;
        this.scheduler.unscheduleCallbackForTarget(this, callback_fn);
    },
    unscheduleAllCallbacks: function () {
        this.scheduler.unscheduleAllCallbacksForTarget(this);
    },
    resumeSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume();
    },
    resume: function () {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause();
    },
    pause: function () {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this);
    },
    setAdditionalTransform: function (additionalTransform) {
        this._additionalTransform = additionalTransform;
        this._transformDirty = true;
        this._additionalTransformDirty = true;
    },
    getParentToNodeTransform: function () {
        if (this._inverseDirty) {
            this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform());
            this._inverseDirty = false;
        }
        return this._inverse;
    },
    parentToNodeTransform: function () {
        return this.getParentToNodeTransform();
    },
    getNodeToWorldTransform: function () {
        var t = this.getNodeToParentTransform();
        for (var p = this._parent; p != null; p = p.parent)
            t = cc.affineTransformConcat(t, p.getNodeToParentTransform());
        return t;
    },
    nodeToWorldTransform: function(){
        return this.getNodeToWorldTransform();
    },
    getWorldToNodeTransform: function () {
        return cc.affineTransformInvert(this.getNodeToWorldTransform());
    },
    worldToNodeTransform: function () {
        return this.getWorldToNodeTransform();
    },
    convertToNodeSpace: function (worldPoint) {
        return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
    },
    convertToWorldSpace: function (nodePoint) {
        nodePoint = nodePoint || cc.p(0,0);
        return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
    },
    convertToNodeSpaceAR: function (worldPoint) {
        return cc.pSub(this.convertToNodeSpace(worldPoint), this._anchorPointInPoints);
    },
    convertToWorldSpaceAR: function (nodePoint) {
        nodePoint = nodePoint || cc.p(0,0);
        var pt = cc.pAdd(nodePoint, this._anchorPointInPoints);
        return this.convertToWorldSpace(pt);
    },
    _convertToWindowSpace: function (nodePoint) {
        var worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.director.convertToUI(worldPoint);
    },
    convertTouchToNodeSpace: function (touch) {
        var point = touch.getLocation();
        return this.convertToNodeSpace(point);
    },
    convertTouchToNodeSpaceAR: function (touch) {
        var point = touch.getLocation();
        point = cc.director.convertToGL(point);
        return this.convertToNodeSpaceAR(point);
    },
    update: function (dt) {
        if (this._componentContainer && !this._componentContainer.isEmpty())
            this._componentContainer.visit(dt);
    },
    updateTransform: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform);
    },
    retain: function () {
    },
    release: function () {
    },
    getComponent: function (name) {
        if(this._componentContainer)
            return this._componentContainer.getComponent(name);
        return null;
    },
    addComponent: function (component) {
        if(this._componentContainer)
            this._componentContainer.add(component);
    },
    removeComponent: function (component) {
        if(this._componentContainer)
            return this._componentContainer.remove(component);
        return false;
    },
    removeAllComponents: function () {
        if(this._componentContainer)
            this._componentContainer.removeAll();
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function(){
        return this.getNodeToParentTransform();
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function () {
        if (this._cacheDirty === false) {
            this._cacheDirty = true;
            var cachedP = this._cachedParent;
            cachedP && cachedP != this && cachedP._setNodeDirtyForCache();
        }
    },
    _setCachedParent: function(cachedParent){
        if(this._cachedParent ==  cachedParent)
            return;
        this._cachedParent = cachedParent;
        var children = this._children;
        for(var i = 0, len = children.length; i < len; i++)
            children[i]._setCachedParent(cachedParent);
    },
    getCamera: function () {
        if (!this._camera) {
            this._camera = new cc.Camera();
        }
        return this._camera;
    },
    getGrid: function () {
        return this.grid;
    },
    setGrid: function (grid) {
        this.grid = grid;
    },
    getShaderProgram: function () {
        return this._shaderProgram;
    },
    setShaderProgram: function (newShaderProgram) {
        this._shaderProgram = newShaderProgram;
    },
    getGLServerState: function () {
        return this._glServerState;
    },
    setGLServerState: function (state) {
        this._glServerState = state;
    },
    getBoundingBoxToWorld: function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.getNodeToWorldTransform();
        rect = cc.rectApplyAffineTransform(rect, this.getNodeToWorldTransform());
        if (!this._children)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                if (childRect)
                    rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    },
    _getBoundingBoxToCurrentNode: function (parentTransform) {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = (parentTransform == null) ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
        rect = cc.rectApplyAffineTransform(rect, trans);
        if (!this._children)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                if (childRect)
                    rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    },
    _getNodeToParentTransformForWebGL: function () {
        var _t = this;
        if(_t._usingNormalizedPosition && _t._parent){
            var conSize = _t._parent._contentSize;
            _t._position.x = _t._normalizedPosition.x * conSize.width;
            _t._position.y = _t._normalizedPosition.y * conSize.height;
            _t._normalizedPositionDirty = false;
        }
        if (_t._transformDirty) {
            var x = _t._position.x;
            var y = _t._position.y;
            var apx = _t._anchorPointInPoints.x, napx = -apx;
            var apy = _t._anchorPointInPoints.y, napy = -apy;
            var scx = _t._scaleX, scy = _t._scaleY;
            if (_t._ignoreAnchorPointForPosition) {
                x += apx;
                y += apy;
            }
            var cx = 1, sx = 0, cy = 1, sy = 0;
            if (_t._rotationX !== 0 || _t._rotationY !== 0) {
                cx = Math.cos(-_t._rotationRadiansX);
                sx = Math.sin(-_t._rotationRadiansX);
                cy = Math.cos(-_t._rotationRadiansY);
                sy = Math.sin(-_t._rotationRadiansY);
            }
            var needsSkewMatrix = ( _t._skewX || _t._skewY );
            if (!needsSkewMatrix && (apx !== 0 || apy !== 0)) {
                x += cy * napx * scx + -sx * napy * scy;
                y += sy * napx * scx + cx * napy * scy;
            }
            var t = _t._transform;
            t.a = cy * scx;
            t.b = sy * scx;
            t.c = -sx * scy;
            t.d = cx * scy;
            t.tx = x;
            t.ty = y;
            if (needsSkewMatrix) {
                t = cc.affineTransformConcat({a: 1.0, b: Math.tan(cc.degreesToRadians(_t._skewY)),
                    c: Math.tan(cc.degreesToRadians(_t._skewX)), d: 1.0, tx: 0.0, ty: 0.0}, t);
                if (apx !== 0 || apy !== 0)
                    t = cc.affineTransformTranslate(t, napx, napy);
            }
            if (_t._additionalTransformDirty) {
                t = cc.affineTransformConcat(t, _t._additionalTransform);
                _t._additionalTransformDirty = false;
            }
            _t._transform = t;
            _t._transformDirty = false;
        }
        return _t._transform;
    },
    _updateColor: function(){
    },
    getOpacity: function () {
        return this._realOpacity;
    },
    getDisplayedOpacity: function () {
        return this._displayedOpacity;
    },
    setOpacity: function (opacity) {
        this._displayedOpacity = this._realOpacity = opacity;
        var parentOpacity = 255, locParent = this._parent;
        if (locParent && locParent.cascadeOpacity)
            parentOpacity = locParent.getDisplayedOpacity();
        this.updateDisplayedOpacity(parentOpacity);
        this._displayedColor.a = this._realColor.a = opacity;
    },
    updateDisplayedOpacity: function (parentOpacity) {
        this._displayedOpacity = this._realOpacity * parentOpacity / 255.0;
        if(this._rendererCmd && this._rendererCmd._opacity !== undefined)
            this._rendererCmd._opacity = this._displayedOpacity / 255;
        if (this._cascadeOpacityEnabled) {
            var selChildren = this._children;
            for (var i = 0; i < selChildren.length; i++) {
                var item = selChildren[i];
                if (item)
                    item.updateDisplayedOpacity(this._displayedOpacity);
            }
        }
    },
    isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled;
    },
    setCascadeOpacityEnabled: function (cascadeOpacityEnabled) {
        if (this._cascadeOpacityEnabled === cascadeOpacityEnabled)
            return;
        this._cascadeOpacityEnabled = cascadeOpacityEnabled;
        if (cascadeOpacityEnabled)
            this._enableCascadeOpacity();
        else
            this._disableCascadeOpacity();
    },
    _enableCascadeOpacity: function () {
        var parentOpacity = 255, locParent = this._parent;
        if (locParent && locParent.cascadeOpacity)
            parentOpacity = locParent.getDisplayedOpacity();
        this.updateDisplayedOpacity(parentOpacity);
    },
    _disableCascadeOpacity: function () {
        this._displayedOpacity = this._realOpacity;
        var selChildren = this._children;
        for (var i = 0; i < selChildren.length; i++) {
            var item = selChildren[i];
            if (item)
                item.updateDisplayedOpacity(255);
        }
    },
    getColor: function () {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
    },
    getDisplayedColor: function () {
        var tmpColor = this._displayedColor;
        return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
    },
    setColor: function (color) {
        var locDisplayedColor = this._displayedColor, locRealColor = this._realColor;
        locDisplayedColor.r = locRealColor.r = color.r;
        locDisplayedColor.g = locRealColor.g = color.g;
        locDisplayedColor.b = locRealColor.b = color.b;
        var parentColor, locParent = this._parent;
        if (locParent && locParent.cascadeColor)
            parentColor = locParent.getDisplayedColor();
        else
            parentColor = cc.color.WHITE;
        this.updateDisplayedColor(parentColor);
    },
    updateDisplayedColor: function (parentColor) {
        var locDispColor = this._displayedColor, locRealColor = this._realColor;
        locDispColor.r = 0 | (locRealColor.r * parentColor.r / 255.0);
        locDispColor.g = 0 | (locRealColor.g * parentColor.g / 255.0);
        locDispColor.b = 0 | (locRealColor.b * parentColor.b / 255.0);
        if (this._cascadeColorEnabled) {
            var selChildren = this._children;
            for (var i = 0; i < selChildren.length; i++) {
                var item = selChildren[i];
                if (item)
                    item.updateDisplayedColor(locDispColor);
            }
        }
    },
    isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled;
    },
    setCascadeColorEnabled: function (cascadeColorEnabled) {
        if (this._cascadeColorEnabled === cascadeColorEnabled)
            return;
        this._cascadeColorEnabled = cascadeColorEnabled;
        if (this._cascadeColorEnabled)
            this._enableCascadeColor();
        else
            this._disableCascadeColor();
    },
    _enableCascadeColor: function () {
        var parentColor , locParent = this._parent;
        if (locParent && locParent.cascadeColor)
            parentColor = locParent.getDisplayedColor();
        else
            parentColor = cc.color.WHITE;
        this.updateDisplayedColor(parentColor);
    },
    _disableCascadeColor: function () {
        var locDisplayedColor = this._displayedColor, locRealColor = this._realColor;
        locDisplayedColor.r = locRealColor.r;
        locDisplayedColor.g = locRealColor.g;
        locDisplayedColor.b = locRealColor.b;
        var selChildren = this._children, whiteColor = cc.color.WHITE;
        for (var i = 0; i < selChildren.length; i++) {
            var item = selChildren[i];
            if (item)
                item.updateDisplayedColor(whiteColor);
        }
    },
    setOpacityModifyRGB: function (opacityValue) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    _initRendererCmd: function(){
    },
    _transformForRenderer: null
});
cc.Node.create = function () {
    return new cc.Node();
};
cc.Node._StateCallbackType = {onEnter: 1, onExit: 2, cleanup: 3, onEnterTransitionDidFinish: 4, updateTransform: 5, onExitTransitionDidStart: 6, sortAllChildren: 7};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Node.prototype;
    _p.ctor = function () {
        this._initNode();
        this._initRendererCmd();
    };
    _p.setNodeDirty = function () {
        var _t = this;
        if(_t._transformDirty === false){
            _t._setNodeDirtyForCache();
            _t._renderCmdDiry = _t._transformDirty = _t._inverseDirty = true;
            cc.renderer.pushDirtyNode(this);
        }
    };
    _p.visit = function (ctx) {
        var _t = this;
        if (!_t._visible)
            return;
        if( _t._parent)
            _t._curLevel = _t._parent._curLevel + 1;
        var i, children = _t._children, child;
        _t.transform();
        var len = children.length;
        if (len > 0) {
            _t.sortAllChildren();
            for (i = 0; i < len; i++) {
                child = children[i];
                if (child._localZOrder < 0)
                    child.visit();
                else
                    break;
            }
            if(this._rendererCmd)
                cc.renderer.pushRenderCommand(this._rendererCmd);
            for (; i < len; i++) {
                children[i].visit();
            }
        } else{
            if(this._rendererCmd)
                cc.renderer.pushRenderCommand(this._rendererCmd);
        }
        this._cacheDirty = false;
    };
    _p._transformForRenderer = function () {
        var t = this.nodeToParentTransform(), worldT = this._transformWorld;
        if(this._parent){
            var pt = this._parent._transformWorld;
            worldT.a = t.a * pt.a + t.b * pt.c;
            worldT.b = t.a * pt.b + t.b * pt.d;
            worldT.c = t.c * pt.a + t.d * pt.c;
            worldT.d = t.c * pt.b + t.d * pt.d;
            if(!this._skewX || this._skewY){
                var plt = this._parent._transform;
                var xOffset = -(plt.b + plt.c) * t.ty ;
                var yOffset = -(plt.b + plt.c) * t.tx;
                worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx + xOffset);
                worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty + yOffset);
            }else{
                worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx);
                worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty);
            }
        } else {
            worldT.a = t.a;
            worldT.b = t.b;
            worldT.c = t.c;
            worldT.d = t.d;
            worldT.tx = t.tx;
            worldT.ty = t.ty;
        }
        this._renderCmdDiry = false;
        if(!this._children || this._children.length === 0)
            return;
        var i, len, locChildren = this._children;
        for(i = 0, len = locChildren.length; i< len; i++){
            locChildren[i]._transformForRenderer();
        }
    };
    _p.transform = function (ctx) {
        var t = this.getNodeToParentTransform(),
            worldT = this._transformWorld;
        if(this._parent){
            var pt = this._parent._transformWorld;
            worldT.a = t.a * pt.a + t.b * pt.c;
            worldT.b = t.a * pt.b + t.b * pt.d;
            worldT.c = t.c * pt.a + t.d * pt.c;
            worldT.d = t.c * pt.b + t.d * pt.d;
            var plt = this._parent._transform;
            var xOffset = -(plt.b + plt.c) * t.ty;
            var yOffset = -(plt.b + plt.c) * t.tx;
            worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx + xOffset);
            worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty + yOffset);
        } else {
            worldT.a = t.a;
            worldT.b = t.b;
            worldT.c = t.c;
            worldT.d = t.d;
            worldT.tx = t.tx;
            worldT.ty = t.ty;
        }
    };
    _p.getNodeToParentTransform = function () {
        var _t = this;
        if(_t._usingNormalizedPosition && _t._parent){
            var conSize = _t._parent._contentSize;
            _t._position.x = _t._normalizedPosition.x * conSize.width;
            _t._position.y = _t._normalizedPosition.y * conSize.height;
            _t._normalizedPositionDirty = false;
        }
        if (_t._transformDirty) {
            var t = _t._transform;// quick reference
            t.tx = _t._position.x;
            t.ty = _t._position.y;
            var Cos = 1, Sin = 0;
            if (_t._rotationX) {
                Cos = Math.cos(_t._rotationRadiansX);
                Sin = Math.sin(_t._rotationRadiansX);
            }
            t.a = t.d = Cos;
            t.b = -Sin;
            t.c = Sin;
            var lScaleX = _t._scaleX, lScaleY = _t._scaleY;
            var appX = _t._anchorPointInPoints.x, appY = _t._anchorPointInPoints.y;
            var sx = (lScaleX < 0.000001 && lScaleX > -0.000001) ? 0.000001 : lScaleX,
                sy = (lScaleY < 0.000001 && lScaleY > -0.000001) ? 0.000001 : lScaleY;
            if (_t._skewX || _t._skewY) {
                var skx = Math.tan(-_t._skewX * Math.PI / 180);
                var sky = Math.tan(-_t._skewY * Math.PI / 180);
                if(skx === Infinity){
                    skx = 99999999;
                }
                if(sky === Infinity){
                    sky = 99999999;
                }
                var xx = appY * skx * sx;
                var yy = appX * sky * sy;
                t.a = Cos + -Sin * sky;
                t.b = Cos * skx + -Sin;
                t.c = Sin + Cos * sky;
                t.d = Sin * skx + Cos;
                t.tx += Cos * xx + -Sin * yy;
                t.ty += Sin * xx + Cos * yy;
            }
            if (lScaleX !== 1 || lScaleY !== 1) {
                t.a *= sx;
                t.c *= sx;
                t.b *= sy;
                t.d *= sy;
            }
            t.tx += Cos * -appX * sx + -Sin * appY * sy;
            t.ty -= Sin * -appX * sx + Cos * appY * sy;
            if (_t._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
            }
            if (_t._additionalTransformDirty) {
                _t._transform = cc.affineTransformConcat(t, _t._additionalTransform);
                _t._additionalTransformDirty = false;
            }
            _t._transformDirty = false;
        }
        return _t._transform;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLCCNode), cc._LogInfos.MissingFile, "BaseNodesWebGL.js");
    cc._tmp.WebGLCCNode();
    delete cc._tmp.WebGLCCNode;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc._tmp.PrototypeTexture2D = function () {
    var _c = cc.Texture2D;
    _c.PVRImagesHavePremultipliedAlpha = function (haveAlphaPremultiplied) {
        cc.PVRHaveAlphaPremultiplied_ = haveAlphaPremultiplied;
    };
    _c.PIXEL_FORMAT_RGBA8888 = 2;
    _c.PIXEL_FORMAT_RGB888 = 3;
    _c.PIXEL_FORMAT_RGB565 = 4;
    _c.PIXEL_FORMAT_A8 = 5;
    _c.PIXEL_FORMAT_I8 = 6;
    _c.PIXEL_FORMAT_AI88 = 7;
    _c.PIXEL_FORMAT_RGBA4444 = 8;
    _c.PIXEL_FORMAT_RGB5A1 = 7;
    _c.PIXEL_FORMAT_PVRTC4 = 9;
    _c.PIXEL_FORMAT_PVRTC2 = 10;
    _c.PIXEL_FORMAT_DEFAULT = _c.PIXEL_FORMAT_RGBA8888;
    var _M = cc.Texture2D._M = {};
    _M[_c.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
    _M[_c.PIXEL_FORMAT_RGB888] = "RGB888";
    _M[_c.PIXEL_FORMAT_RGB565] = "RGB565";
    _M[_c.PIXEL_FORMAT_A8] = "A8";
    _M[_c.PIXEL_FORMAT_I8] = "I8";
    _M[_c.PIXEL_FORMAT_AI88] = "AI88";
    _M[_c.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    _M[_c.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    _M[_c.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    _M[_c.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    var _B = cc.Texture2D._B = {};
    _B[_c.PIXEL_FORMAT_RGBA8888] = 32;
    _B[_c.PIXEL_FORMAT_RGB888] = 24;
    _B[_c.PIXEL_FORMAT_RGB565] = 16;
    _B[_c.PIXEL_FORMAT_A8] = 8;
    _B[_c.PIXEL_FORMAT_I8] = 8;
    _B[_c.PIXEL_FORMAT_AI88] = 16;
    _B[_c.PIXEL_FORMAT_RGBA4444] = 16;
    _B[_c.PIXEL_FORMAT_RGB5A1] = 16;
    _B[_c.PIXEL_FORMAT_PVRTC4] = 4;
    _B[_c.PIXEL_FORMAT_PVRTC2] = 3;
    var _p = cc.Texture2D.prototype;
    _p.name;
    cc.defineGetterSetter(_p, "name", _p.getName);
    _p.pixelFormat;
    cc.defineGetterSetter(_p, "pixelFormat", _p.getPixelFormat);
    _p.pixelsWidth;
    cc.defineGetterSetter(_p, "pixelsWidth", _p.getPixelsWide);
    _p.pixelsHeight;
    cc.defineGetterSetter(_p, "pixelsHeight", _p.getPixelsHigh);
    _p.width;
    cc.defineGetterSetter(_p, "width", _p._getWidth);
    _p.height;
    cc.defineGetterSetter(_p, "height", _p._getHeight);
    _c.defaultPixelFormat = _c.PIXEL_FORMAT_DEFAULT;
};
cc._tmp.PrototypeTextureAtlas = function () {
    var _p = cc.TextureAtlas.prototype;
    _p.totalQuads;
    cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
    _p.capacity;
    cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
    _p.quads;
    cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
};
cc.ALIGN_CENTER = 0x33;
cc.ALIGN_TOP = 0x13;
cc.ALIGN_TOP_RIGHT = 0x12;
cc.ALIGN_RIGHT = 0x32;
cc.ALIGN_BOTTOM_RIGHT = 0x22;
cc.ALIGN_BOTTOM = 0x23;
cc.ALIGN_BOTTOM_LEFT = 0x21;
cc.ALIGN_LEFT = 0x31;
cc.ALIGN_TOP_LEFT = 0x11;
cc.PVRHaveAlphaPremultiplied_ = false;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    cc.Texture2D = cc.Class.extend({
        _contentSize: null,
        _isLoaded: false,
        _htmlElementObj: null,
        url: null,
        ctor: function () {
            this._contentSize = cc.size(0, 0);
            this._isLoaded = false;
            this._htmlElementObj = null;
        },
        getPixelsWide: function () {
            return this._contentSize.width;
        },
        getPixelsHigh: function () {
            return this._contentSize.height;
        },
        getContentSize: function () {
            var locScaleFactor = cc.contentScaleFactor();
            return cc.size(this._contentSize.width / locScaleFactor, this._contentSize.height / locScaleFactor);
        },
        _getWidth: function () {
            return this._contentSize.width / cc.contentScaleFactor();
        },
        _getHeight: function () {
            return this._contentSize.height / cc.contentScaleFactor();
        },
        getContentSizeInPixels: function () {
            return this._contentSize;
        },
        initWithElement: function (element) {
            if (!element)
                return;
            this._htmlElementObj = element;
        },
        getHtmlElementObj: function () {
            return this._htmlElementObj;
        },
        isLoaded: function () {
            return this._isLoaded;
        },
        handleLoadedTexture: function () {
            var self = this;
            if (self._isLoaded) return;
            if (!self._htmlElementObj) {
                var img = cc.loader.getRes(self.url);
                if (!img) return;
                self.initWithElement(img);
            }
            self._isLoaded = true;
            var locElement = self._htmlElementObj;
            self._contentSize.width = locElement.width;
            self._contentSize.height = locElement.height;
            self.dispatchEvent("load");
        },
        description: function () {
            return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">";
        },
        initWithData: function (data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
            return false;
        },
        initWithImage: function (uiImage) {
            return false;
        },
        initWithString: function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
            return false;
        },
        releaseTexture: function () {
        },
        getName: function () {
            return null;
        },
        getMaxS: function () {
            return 1;
        },
        setMaxS: function (maxS) {
        },
        getMaxT: function () {
            return 1;
        },
        setMaxT: function (maxT) {
        },
        getPixelFormat: function () {
            return null;
        },
        getShaderProgram: function () {
            return null;
        },
        setShaderProgram: function (shaderProgram) {
        },
        hasPremultipliedAlpha: function () {
            return false;
        },
        hasMipmaps: function () {
            return false;
        },
        releaseData: function (data) {
            data = null;
        },
        keepData: function (data, length) {
            return data;
        },
        drawAtPoint: function (point) {
        },
        drawInRect: function (rect) {
        },
        initWithETCFile: function (file) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile);
            return false;
        },
        initWithPVRFile: function (file) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
            return false;
        },
        initWithPVRTCData: function (data, level, bpp, hasAlpha, length, pixelFormat) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
            return false;
        },
        setTexParameters: function (texParams) {
        },
        setAntiAliasTexParameters: function () {
        },
        setAliasTexParameters: function () {
        },
        generateMipmap: function () {
        },
        stringForFormat: function () {
            return "";
        },
        bitsPerPixelForFormat: function (format) {
            return -1;
        },
        addLoadedEventListener: function (callback, target) {
            this.addEventListener("load", callback, target);
        },
        removeLoadedEventListener: function (target) {
            this.removeEventListener("load", target);
        }
    });
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js");
    cc._tmp.WebGLTexture2D();
    delete cc._tmp.WebGLTexture2D;
}
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: (0 | Math.random() * 1000),
    _loadedTexturesBefore: {},
    _initializingRenderer: function () {
        var selPath;
        var locLoadedTexturesBefore = this._loadedTexturesBefore, locTextures = this._textures;
        for (selPath in locLoadedTexturesBefore) {
            var tex2d = locLoadedTexturesBefore[selPath];
            tex2d.handleLoadedTexture();
            locTextures[selPath] = tex2d;
        }
        this._loadedTexturesBefore = {};
    },
    addPVRTCImage: function (filename) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage);
    },
    addETCImage: function (filename) {
        cc.log(cc._LogInfos.textureCache_addETCImage);
    },
    description: function () {
        return "<TextureCache | Number of textures = " + this._textures.length + ">";
    },
    textureForKey: function (textureKeyName) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(textureKeyName);
    },
    getTextureForKey: function(textureKeyName){
        return this._textures[textureKeyName] || this._textures[cc.loader._aliases[textureKeyName]];
    },
    getKeyByTexture: function (texture) {
        for (var key in this._textures) {
            if (this._textures[key] == texture) {
                return key;
            }
        }
        return null;
    },
    _generalTextureKey: function () {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq;
    },
    getTextureColors: function (texture) {
        var key = this.getKeyByTexture(texture);
        if (!key) {
            if (texture instanceof HTMLImageElement)
                key = texture.src;
            else
                key = this._generalTextureKey();
        }
        if (!this._textureColorsCache[key])
            this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture);
        return this._textureColorsCache[key];
    },
    addPVRImage: function (path) {
        cc.log(cc._LogInfos.textureCache_addPVRImage);
    },
    removeAllTextures: function () {
        var locTextures = this._textures;
        for (var selKey in locTextures) {
            if (locTextures[selKey])
                locTextures[selKey].releaseTexture();
        }
        this._textures = {};
    },
    removeTexture: function (texture) {
        if (!texture)
            return;
        var locTextures = this._textures;
        for (var selKey in locTextures) {
            if (locTextures[selKey] == texture) {
                locTextures[selKey].releaseTexture();
                delete(locTextures[selKey]);
            }
        }
    },
    removeTextureForKey: function (textureKeyName) {
        if (textureKeyName == null)
            return;
        if (this._textures[textureKeyName])
            delete(this._textures[textureKeyName]);
    },
    cacheImage: function (path, texture) {
        if (texture instanceof  cc.Texture2D) {
            this._textures[path] = texture;
            return;
        }
        var texture2d = new cc.Texture2D();
        texture2d.initWithElement(texture);
        texture2d.handleLoadedTexture();
        this._textures[path] = texture2d;
    },
    addUIImage: function (image, key) {
        cc.assert(image, cc._LogInfos.textureCache_addUIImage_2);
        if (key) {
            if (this._textures[key])
                return this._textures[key];
        }
        var texture = new cc.Texture2D();
        texture.initWithImage(image);
        if ((key != null) && (texture != null))
            this._textures[key] = texture;
        else
            cc.log(cc._LogInfos.textureCache_addUIImage);
        return texture;
    },
    dumpCachedTextureInfo: function () {
        var count = 0;
        var totalBytes = 0, locTextures = this._textures;
        for (var key in locTextures) {
            var selTexture = locTextures[key];
            count++;
            if (selTexture.getHtmlElementObj() instanceof  HTMLImageElement)
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, key, selTexture.getHtmlElementObj().src, selTexture.pixelsWidth, selTexture.pixelsHeight);
            else {
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, key, selTexture.pixelsWidth, selTexture.pixelsHeight);
            }
            totalBytes += selTexture.pixelsWidth * selTexture.pixelsHeight * 4;
        }
        var locTextureColorsCache = this._textureColorsCache;
        for (key in locTextureColorsCache) {
            var selCanvasColorsArr = locTextureColorsCache[key];
            for (var selCanvasKey in selCanvasColorsArr) {
                var selCanvas = selCanvasColorsArr[selCanvasKey];
                count++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, key, selCanvas.width, selCanvas.height);
                totalBytes += selCanvas.width * selCanvas.height * 4;
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, count, totalBytes / 1024, (totalBytes / (1024.0 * 1024.0)).toFixed(2));
    },
    _clear: function () {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = (0 | Math.random() * 1000);
        this._loadedTexturesBefore = {};
    }
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.textureCache;
    _p.handleLoadedTexture = function (url) {
        var locTexs = this._textures;
        var tex = locTexs[url];
        if (!tex) {
            tex = locTexs[url] = new cc.Texture2D();
            tex.url = url;
        }
        tex.handleLoadedTexture();
    };
    _p.addImage = function (url, cb, target) {
        cc.assert(url, cc._LogInfos.Texture2D_addImage);
        var locTexs = this._textures;
        var tex = locTexs[url] || locTexs[cc.loader._aliases[url]];
        if (tex) {
            cb && cb.call(target, tex);
            return tex;
        }
        tex = locTexs[url] = new cc.Texture2D();
        tex.url = url;
        if (!cc.loader.getRes(url)) {
            if (cc.loader._checkIsImageURL(url)) {
                cc.loader.load(url, function (err) {
                    cb && cb.call(target);
                });
            } else {
                cc.loader.loadImg(url, function (err, img) {
                    if (err)
                        return cb ? cb(err) : err;
                    cc.loader.cache[url] = img;
                    cc.textureCache.handleLoadedTexture(url);
                    cb && cb.call(target, tex);
                });
            }
        }
        else {
            tex.handleLoadedTexture();
        }
        return tex;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js");
    cc._tmp.WebGLTextureCache();
    delete cc._tmp.WebGLTextureCache;
}
cc.Scene = cc.Node.extend({
    _className:"Scene",
    ctor:function () {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = true;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize());
    }
});
cc.Scene.create = function () {
    return new cc.Scene();
};
cc.LoaderScene = cc.Scene.extend({
    _interval : null,
    _label : null,
    _className:"LoaderScene",
    init : function(){
        var self = this;
        var logoWidth = 160;
        var logoHeight = 200;
        var bgLayer = self._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        bgLayer.setPosition(cc.visibleRect.bottomLeft);
        self.addChild(bgLayer, 0);
        var fontSize = 24, lblHeight =  -logoHeight / 2 + 100;
        if(cc._loaderImage){
            cc.loader.loadImg(cc._loaderImage, {isCrossOrigin : false }, function(err, img){
                logoWidth = img.width;
                logoHeight = img.height;
                self._initStage(img, cc.visibleRect.center);
            });
            fontSize = 14;
            lblHeight = -logoHeight / 2 - 10;
        }
        var label = self._label = new cc.LabelTTF("Loading... 0%", "Arial", fontSize);
        label.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, lblHeight)));
        label.setColor(cc.color(180, 180, 180));
        bgLayer.addChild(this._label, 10);
        return true;
    },
    _initStage: function (img, centerPos) {
        var self = this;
        var texture2d = self._texture2d = new cc.Texture2D();
        texture2d.initWithElement(img);
        texture2d.handleLoadedTexture();
        var logo = self._logo = new cc.Sprite(texture2d);
        logo.setScale(cc.contentScaleFactor());
        logo.x = centerPos.x;
        logo.y = centerPos.y;
        self._bgLayer.addChild(logo, 10);
    },
    onEnter: function () {
        var self = this;
        cc.Node.prototype.onEnter.call(self);
        self.schedule(self._startLoading, 0.3);
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        var tmpStr = "Loading... 0%";
        this._label.setString(tmpStr);
    },
    initWithResources: function (resources, cb) {
        if(cc.isString(resources))
            resources = [resources];
        this.resources = resources || [];
        this.cb = cb;
    },
    _startLoading: function () {
        var self = this;
        self.unschedule(self._startLoading);
        var res = self.resources;
        cc.loader.load(res,
            function (result, count, loadedCount) {
                var percent = (loadedCount / count * 100) | 0;
                percent = Math.min(percent, 100);
                self._label.setString("Loading... " + percent + "%");
            }, function () {
                if (self.cb)
                    self.cb();
            });
    }
});
cc.LoaderScene.preload = function(resources, cb){
    var _cc = cc;
    if(!_cc.loaderScene) {
        _cc.loaderScene = new cc.LoaderScene();
        _cc.loaderScene.init();
    }
    _cc.loaderScene.initWithResources(resources, cb);
    cc.director.runScene(_cc.loaderScene);
    return _cc.loaderScene;
};
cc._tmp.PrototypeLayerColor = function () {
    var _p = cc.LayerColor.prototype;
    cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
    cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
};
cc._tmp.PrototypeLayerGradient = function () {
    var _p = cc.LayerGradient.prototype;
    _p.startColor;
    cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
    _p.endColor;
    cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
    _p.startOpacity;
    cc.defineGetterSetter(_p, "startOpacity", _p.getStartOpacity, _p.setStartOpacity);
    _p.endOpacity;
    cc.defineGetterSetter(_p, "endOpacity", _p.getEndOpacity, _p.setEndOpacity);
    _p.vector;
    cc.defineGetterSetter(_p, "vector", _p.getVector, _p.setVector);
};
cc.Layer = cc.Node.extend({
    _isBaked: false,
    _bakeSprite: null,
    _bakeRenderCmd: null,
    _className: "Layer",
    ctor: function () {
        var nodep = cc.Node.prototype;
        nodep.ctor.call(this);
        this._ignoreAnchorPointForPosition = true;
        nodep.setAnchorPoint.call(this, 0.5, 0.5);
        nodep.setContentSize.call(this, cc.winSize);
    },
    init: function(){
        var _t = this;
        _t._ignoreAnchorPointForPosition = true;
        _t.setAnchorPoint(0.5, 0.5);
        _t.setContentSize(cc.winSize);
        _t.cascadeOpacity = false;
        _t.cascadeColor = false;
        return true;
    },
    bake: null,
    unbake: null,
    _bakeRendering: null,
    isBaked: function(){
        return this._isBaked;
    },
    visit: null
});
cc.Layer.create = function () {
    return new cc.Layer();
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function(){
        if (!this._isBaked) {
            cc.renderer.childrenOrderDirty = true;
            this._isBaked = this._cacheDirty = true;
            if(!this._bakeRenderCmd && this._bakeRendering)
                this._bakeRenderCmd = new cc.CustomRenderCmdCanvas(this, this._bakeRendering);
            this._cachedParent = this;
            var children = this._children;
            for(var i = 0, len = children.length; i < len; i++)
                children[i]._setCachedParent(this);
            if (!this._bakeSprite){
                this._bakeSprite = new cc.BakeSprite();
                this._bakeSprite._parent = this;
            }
        }
    };
    p.unbake = function(){
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = true;
            this._isBaked = false;
            this._cacheDirty = true;
            this._cachedParent = null;
            var children = this._children;
            for(var i = 0, len = children.length; i < len; i++)
                children[i]._setCachedParent(null);
        }
    };
    p.addChild = function(child, localZOrder, tag){
        cc.Node.prototype.addChild.call(this, child, localZOrder, tag);
        if(child._parent == this && this._isBaked)
            child._setCachedParent(this);
    };
    p._bakeRendering = function(){
        if(this._cacheDirty){
            var _t = this;
            var children = _t._children, locBakeSprite = this._bakeSprite;
            var boundingBox = this._getBoundingBoxForBake();
            boundingBox.width = 0 | boundingBox.width;
            boundingBox.height = 0 | boundingBox.height;
            var bakeContext = locBakeSprite.getCacheContext();
            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
            bakeContext.translate(0 - boundingBox.x, boundingBox.height + boundingBox.y);
            var t = cc.affineTransformInvert(this._transformWorld);
            var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
            bakeContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var anchor = locBakeSprite.getAnchorPointInPoints();
            locBakeSprite.setPosition(anchor.x + boundingBox.x, anchor.y + boundingBox.y);
            _t.sortAllChildren();
            cc.renderer._turnToCacheMode(this.__instanceId);
            for (var i = 0, len = children.length; i < len; i++) {
                children[i].visit(bakeContext);
            }
            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
            this._cacheDirty = false;
        }
    };
    p.visit = function(ctx){
        if(!this._isBaked){
            cc.Node.prototype.visit.call(this, ctx);
            return;
        }
        var context = ctx || cc._renderContext;
        var _t = this;
        var children = _t._children;
        var len = children.length;
        if (!_t._visible || len === 0)
            return;
        _t.transform(context);
        if(_t._bakeRenderCmd)
            cc.renderer.pushRenderCommand(_t._bakeRenderCmd);
        this._bakeSprite.visit(context);
    };
    p._getBoundingBoxForBake = function () {
        var rect = null;
        if (!this._children || this._children.length === 0)
            return cc.rect(0, 0, 10, 10);
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                if(rect){
                    var childRect = child._getBoundingBoxToCurrentNode();
                    if (childRect)
                        rect = cc.rectUnion(rect, childRect);
                }else{
                    rect = child._getBoundingBoxToCurrentNode();
                }
            }
        }
        return rect;
    };
    p = null;
}else{
    cc.assert(cc.isFunction(cc._tmp.LayerDefineForWebGL), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.LayerDefineForWebGL();
    delete cc._tmp.LayerDefineForWebGL;
}
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function () {
        return this._blendFunc;
    },
    changeWidthAndHeight: function (w, h) {
        this.width = w;
        this.height = h;
    },
    changeWidth: function (w) {
        this.width = w;
    },
    changeHeight: function (h) {
        this.height = h;
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    setColor: function (color) {
        cc.Layer.prototype.setColor.call(this, color);
        this._updateColor();
    },
    setOpacity: function (opacity) {
        cc.Layer.prototype.setOpacity.call(this, opacity);
        this._updateColor();
    },
    _blendFuncStr: "source",
    ctor: null,
    init: function (color, width, height) {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS)
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR);
        var winSize = cc.director.getWinSize();
        color = color || cc.color(0, 0, 0, 255);
        width = width === undefined ? winSize.width : width;
        height = height === undefined ? winSize.height : height;
        var locDisplayedColor = this._displayedColor;
        locDisplayedColor.r = color.r;
        locDisplayedColor.g = color.g;
        locDisplayedColor.b = color.b;
        var locRealColor = this._realColor;
        locRealColor.r = color.r;
        locRealColor.g = color.g;
        locRealColor.b = color.b;
        this._displayedOpacity = color.a;
        this._realOpacity = color.a;
        var proto = cc.LayerColor.prototype;
        proto.setContentSize.call(this, width, height);
        proto._updateColor.call(this);
        return true;
    },
    setBlendFunc: function (src, dst) {
        var _t = this, locBlendFunc = this._blendFunc;
        if (dst === undefined) {
            locBlendFunc.src = src.src;
            locBlendFunc.dst = src.dst;
        } else {
            locBlendFunc.src = src;
            locBlendFunc.dst = dst;
        }
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)
            _t._blendFuncStr = cc._getCompositeOperationByBlendFunc(locBlendFunc);
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function (parentColor) {
        cc.Layer.prototype.updateDisplayedColor.call(this, parentColor);
        this._updateColor();
    },
    updateDisplayedOpacity: function (parentOpacity) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._updateColor();
    },
    draw: null
});
cc.LayerColor.create = function (color, width, height) {
    return new cc.LayerColor(color, width, height);
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerColor.prototype;
    _p.ctor = function (color, width, height) {
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, color, width, height);
    };
    _p._initRendererCmd = function(){
        this._rendererCmd = new cc.RectRenderCmdCanvas(this);
    };
    _p._setWidth = function(width){
        cc.Node.prototype._setWidth.call(this, width);
    };
    _p._setHeight = function(height){
        cc.Node.prototype._setHeight.call(this, height);
    };
    _p._updateColor = function () {
        var locCmd = this._rendererCmd;
        if(!locCmd || !locCmd._color)
            return;
        var locColor = this._displayedColor;
        locCmd._color.r = locColor.r;
        locCmd._color.g = locColor.g;
        locCmd._color.b = locColor.b;
        locCmd._color.a = this._displayedOpacity / 255;
    };
    _p.draw = function (ctx) {
        var context = ctx || cc._renderContext, _t = this;
        var locEGLViewer = cc.view, locDisplayedColor = _t._displayedColor;
        context.fillStyle = "rgba(" + (0 | locDisplayedColor.r) + "," + (0 | locDisplayedColor.g) + ","
            + (0 | locDisplayedColor.b) + "," + _t._displayedOpacity / 255 + ")";
        context.fillRect(0, 0, _t.width * locEGLViewer.getScaleX(), -_t.height * locEGLViewer.getScaleY());
        cc.g_NumberOfDraws++;
    };
    _p._bakeRendering = function(){
        if(this._cacheDirty){
            var _t = this;
            var locBakeSprite = _t._bakeSprite, children = this._children;
            var len = children.length, i;
            var boundingBox = this._getBoundingBoxForBake();
            boundingBox.width = 0 | boundingBox.width;
            boundingBox.height = 0 | boundingBox.height;
            var bakeContext = locBakeSprite.getCacheContext();
            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
            var anchor = locBakeSprite.getAnchorPointInPoints(), locPos = this._position;
            if(this._ignoreAnchorPointForPosition){
                bakeContext.translate(0 - boundingBox.x + locPos.x, boundingBox.height + boundingBox.y - locPos.y);
                locBakeSprite.setPosition(anchor.x + boundingBox.x - locPos.x, anchor.y + boundingBox.y - locPos.y);
            } else {
                var selfAnchor = this.getAnchorPointInPoints();
                var selfPos = {x: locPos.x - selfAnchor.x, y: locPos.y - selfAnchor.y};
                bakeContext.translate(0 - boundingBox.x + selfPos.x, boundingBox.height + boundingBox.y - selfPos.y);
                locBakeSprite.setPosition(anchor.x + boundingBox.x - selfPos.x, anchor.y + boundingBox.y - selfPos.y);
            }
            var t = cc.affineTransformInvert(this._transformWorld);
            var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
            bakeContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var child;
            cc.renderer._turnToCacheMode(this.__instanceId);
            if (len > 0) {
                _t.sortAllChildren();
                for (i = 0; i < len; i++) {
                    child = children[i];
                    if (child._localZOrder < 0)
                        child.visit(bakeContext);
                    else
                        break;
                }
                if(_t._rendererCmd)
                    cc.renderer.pushRenderCommand(_t._rendererCmd);
                for (; i < len; i++) {
                    children[i].visit(bakeContext);
                }
            } else
            if(_t._rendererCmd)
                cc.renderer.pushRenderCommand(_t._rendererCmd);
            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
            this._cacheDirty = false;
        }
    };
    _p.visit = function(ctx){
        if(!this._isBaked){
            cc.Node.prototype.visit.call(this, ctx);
            return;
        }
        var context = ctx || cc._renderContext;
        var _t = this;
        if (!_t._visible)
            return;
        _t.transform(context);
        if(_t._bakeRenderCmd)
            cc.renderer.pushRenderCommand(_t._bakeRenderCmd);
        this._bakeSprite.visit(context);
    };
    _p._getBoundingBoxForBake = function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.nodeToWorldTransform();
        rect = cc.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        if (!this._children || this._children.length === 0)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerColor), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.WebGLLayerColor();
    delete cc._tmp.WebGLLayerColor;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerColor), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerColor();
delete cc._tmp.PrototypeLayerColor;
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: false,
    _className: "LayerGradient",
    ctor: function (start, end, v) {
        var _t = this;
        cc.LayerColor.prototype.ctor.call(_t);
        _t._endColor = cc.color(0, 0, 0, 255);
        _t._alongVector = cc.p(0, -1);
        _t._startOpacity = 255;
        _t._endOpacity = 255;
        cc.LayerGradient.prototype.init.call(_t, start, end, v);
    },
    _initRendererCmd: function(){
        this._rendererCmd = new cc.GradientRectRenderCmdCanvas(this);
    },
    init: function (start, end, v) {
        start = start || cc.color(0, 0, 0, 255);
        end = end || cc.color(0, 0, 0, 255);
        v = v || cc.p(0, -1);
        var _t = this;
        var locEndColor = _t._endColor;
        _t._startOpacity = start.a;
        locEndColor.r = end.r;
        locEndColor.g = end.g;
        locEndColor.b = end.b;
        _t._endOpacity = end.a;
        _t._alongVector = v;
        _t._compressedInterpolation = true;
        cc.LayerColor.prototype.init.call(_t, cc.color(start.r, start.g, start.b, 255));
        cc.LayerGradient.prototype._updateColor.call(_t);
        return true;
    },
    setContentSize: function (size, height) {
        cc.LayerColor.prototype.setContentSize.call(this, size, height);
        this._updateColor();
    },
    _setWidth: function (width) {
        cc.LayerColor.prototype._setWidth.call(this, width);
        this._updateColor();
    },
    _setHeight: function (height) {
        cc.LayerColor.prototype._setHeight.call(this, height);
        this._updateColor();
    },
    getStartColor: function () {
        return this._realColor;
    },
    setStartColor: function (color) {
        this.color = color;
    },
    setEndColor: function (color) {
        this._endColor = color;
        this._updateColor();
    },
    getEndColor: function () {
        return this._endColor;
    },
    setStartOpacity: function (o) {
        this._startOpacity = o;
        this._updateColor();
    },
    getStartOpacity: function () {
        return this._startOpacity;
    },
    setEndOpacity: function (o) {
        this._endOpacity = o;
        this._updateColor();
    },
    getEndOpacity: function () {
        return this._endOpacity;
    },
    setVector: function (Var) {
        this._alongVector.x = Var.x;
        this._alongVector.y = Var.y;
        this._updateColor();
    },
    getVector: function () {
        return cc.p(this._alongVector.x, this._alongVector.y);
    },
    isCompressedInterpolation: function () {
        return this._compressedInterpolation;
    },
    setCompressedInterpolation: function (compress) {
        this._compressedInterpolation = compress;
        this._updateColor();
    },
    _draw: null,
    _updateColor: null
});
cc.LayerGradient.create = function (start, end, v) {
    return new cc.LayerGradient(start, end, v);
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerGradient.prototype;
    _p._updateColor = function () {
        var _t = this;
        var locAlongVector = _t._alongVector, tWidth = _t.width * 0.5, tHeight = _t.height * 0.5;
        var locCmd = this._rendererCmd;
        locCmd._startPoint.x = tWidth * (-locAlongVector.x) + tWidth;
        locCmd._startPoint.y = tHeight * locAlongVector.y - tHeight;
        locCmd._endPoint.x = tWidth * locAlongVector.x + tWidth;
        locCmd._endPoint.y = tHeight * (-locAlongVector.y) - tHeight;
        var locStartColor = this._displayedColor, locEndColor = this._endColor, opacity = this._displayedOpacity / 255;
        var startOpacity = this._startOpacity, endOpacity = this._endOpacity;
        locCmd._startStopStr = "rgba(" + Math.round(locStartColor.r) + "," + Math.round(locStartColor.g) + ","
            + Math.round(locStartColor.b) + "," + startOpacity.toFixed(4) + ")";
        locCmd._endStopStr = "rgba(" + Math.round(locEndColor.r) + "," + Math.round(locEndColor.g) + ","
            + Math.round(locEndColor.b) + "," + endOpacity.toFixed(4) + ")";
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerGradient), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.WebGLLayerGradient();
    delete cc._tmp.WebGLLayerGradient;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerGradient), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerGradient();
delete cc._tmp.PrototypeLayerGradient;
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function (layers) {
        cc.Layer.prototype.ctor.call(this);
        if (layers instanceof Array)
            cc.LayerMultiplex.prototype.initWithLayers.call(this, layers);
        else
            cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments));
    },
    initWithLayers: function (layers) {
        if ((layers.length > 0) && (layers[layers.length - 1] == null))
            cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = layers;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return true;
    },
    switchTo: function (n) {
        if (n >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchTo);
            return;
        }
        this.removeChild(this._layers[this._enabledLayer], true);
        this._enabledLayer = n;
        this.addChild(this._layers[n]);
    },
    switchToAndReleaseMe: function (n) {
        if (n >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe);
            return;
        }
        this.removeChild(this._layers[this._enabledLayer], true);
        this._layers[this._enabledLayer] = null;
        this._enabledLayer = n;
        this.addChild(this._layers[n]);
    },
    addLayer: function (layer) {
        if (!layer) {
            cc.log(cc._LogInfos.LayerMultiplex_addLayer);
            return;
        }
        this._layers.push(layer);
    }
});
cc.LayerMultiplex.create = function () {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments));
};
cc._tmp.PrototypeSprite = function () {
    var _p = cc.Sprite.prototype;
    cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    _p.dirty;
    _p.flippedX;
    cc.defineGetterSetter(_p, "flippedX", _p.isFlippedX, _p.setFlippedX);
    _p.flippedY;
    cc.defineGetterSetter(_p, "flippedY", _p.isFlippedY, _p.setFlippedY);
    _p.offsetX;
    cc.defineGetterSetter(_p, "offsetX", _p._getOffsetX);
    _p.offsetY;
    cc.defineGetterSetter(_p, "offsetY", _p._getOffsetY);
    _p.atlasIndex;
    _p.texture;
    cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
    _p.textureRectRotated;
    cc.defineGetterSetter(_p, "textureRectRotated", _p.isTextureRectRotated);
    _p.textureAtlas;
    _p.batchNode;
    cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
    _p.quad;
    cc.defineGetterSetter(_p, "quad", _p.getQuad);
};
cc.generateTintImageWithMultiply = function(image, color, rect, renderCanvas){
    renderCanvas = renderCanvas || cc.newElement("canvas");
    rect = rect || cc.rect(0,0, image.width, image.height);
    var context = renderCanvas.getContext( "2d" );
    if(renderCanvas.width != rect.width || renderCanvas.height != rect.height){
        renderCanvas.width = rect.width;
        renderCanvas.height = rect.height;
    }else{
        context.globalCompositeOperation = "source-over";
    }
    context.fillStyle = "rgb(" + (0|color.r) + "," + (0|color.g) + "," + (0|color.b) + ")";
    context.fillRect(0, 0, rect.width, rect.height);
    context.globalCompositeOperation = "multiply";
    context.drawImage(image,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(image,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height);
    return renderCanvas;
};
cc.generateTintImage = function (texture, tintedImgCache, color, rect, renderCanvas) {
    if (!rect)
        rect = cc.rect(0, 0, texture.width, texture.height);
    var r = color.r / 255;
    var g = color.g / 255;
    var b = color.b / 255;
    var w = Math.min(rect.width, tintedImgCache[0].width);
    var h = Math.min(rect.height, tintedImgCache[0].height);
    var buff = renderCanvas;
    var ctx;
    if (!buff) {
        buff = cc.newElement("canvas");
        buff.width = w;
        buff.height = h;
        ctx = buff.getContext("2d");
    } else {
        ctx = buff.getContext("2d");
        ctx.clearRect(0, 0, w, h);
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    var a = ctx.globalAlpha;
    if (r > 0) {
        ctx.globalAlpha = r * a;
        ctx.drawImage(tintedImgCache[0], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (g > 0) {
        ctx.globalAlpha = g * a;
        ctx.drawImage(tintedImgCache[1], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (b > 0) {
        ctx.globalAlpha = b * a;
        ctx.drawImage(tintedImgCache[2], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (r + g + b < 1) {
        ctx.globalAlpha = a;
        ctx.drawImage(tintedImgCache[3], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    ctx.restore();
    return buff;
};
cc.generateTextureCacheForColor = function (texture) {
    if (texture.channelCache) {
        return texture.channelCache;
    }
    var textureCache = [
        cc.newElement("canvas"),
        cc.newElement("canvas"),
        cc.newElement("canvas"),
        cc.newElement("canvas")
    ];
    function renderToCache() {
        var ref = cc.generateTextureCacheForColor;
        var w = texture.width;
        var h = texture.height;
        textureCache[0].width = w;
        textureCache[0].height = h;
        textureCache[1].width = w;
        textureCache[1].height = h;
        textureCache[2].width = w;
        textureCache[2].height = h;
        textureCache[3].width = w;
        textureCache[3].height = h;
        ref.canvas.width = w;
        ref.canvas.height = h;
        var ctx = ref.canvas.getContext("2d");
        ctx.drawImage(texture, 0, 0);
        ref.tempCanvas.width = w;
        ref.tempCanvas.height = h;
        var pixels = ctx.getImageData(0, 0, w, h).data;
        for (var rgbI = 0; rgbI < 4; rgbI++) {
            var cacheCtx = textureCache[rgbI].getContext('2d');
            cacheCtx.getImageData(0, 0, w, h).data;
            ref.tempCtx.drawImage(texture, 0, 0);
            var to = ref.tempCtx.getImageData(0, 0, w, h);
            var toData = to.data;
            for (var i = 0; i < pixels.length; i += 4) {
                toData[i  ] = (rgbI === 0) ? pixels[i  ] : 0;
                toData[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
                toData[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
                toData[i + 3] = pixels[i + 3];
            }
            cacheCtx.putImageData(to, 0, 0);
        }
        texture.onload = null;
    }
    try {
        renderToCache();
    } catch (e) {
        texture.onload = renderToCache;
    }
    texture.channelCache = textureCache;
    return textureCache;
};
cc.generateTextureCacheForColor.canvas = cc.newElement('canvas');
cc.generateTextureCacheForColor.tempCanvas = cc.newElement('canvas');
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext('2d');
cc.cutRotateImageToCanvas = function (texture, rect) {
    if (!texture)
        return null;
    if (!rect)
        return texture;
    var nCanvas = cc.newElement("canvas");
    nCanvas.width = rect.width;
    nCanvas.height = rect.height;
    var ctx = nCanvas.getContext("2d");
    ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
    ctx.rotate(-1.5707963267948966);
    ctx.drawImage(texture, rect.x, rect.y, rect.height, rect.width, -rect.height / 2, -rect.width / 2, rect.height, rect.width);
    return nCanvas;
};
cc._getCompositeOperationByBlendFunc = function(blendFunc){
    if(!blendFunc)
        return "source";
    else{
        if(( blendFunc.src == cc.SRC_ALPHA && blendFunc.dst == cc.ONE) || (blendFunc.src == cc.ONE && blendFunc.dst == cc.ONE))
            return "lighter";
        else if(blendFunc.src == cc.ZERO && blendFunc.dst == cc.SRC_ALPHA)
            return "destination-in";
        else if(blendFunc.src == cc.ZERO && blendFunc.dst == cc.ONE_MINUS_SRC_ALPHA)
            return "destination-out";
        else
            return "source";
    }
};
cc.Sprite = cc.Node.extend({
	dirty:false,
	atlasIndex:0,
    textureAtlas:null,
    _batchNode:null,
    _recursiveDirty:null,
    _hasChildren:null,
    _shouldBeHidden:false,
    _transformToBatch:null,
    _blendFunc:null,
    _texture:null,
    _rect:null,
    _rectRotated:false,
    _offsetPosition:null,
    _unflippedOffsetPositionFromCenter:null,
    _opacityModifyRGB:false,
    _flippedX:false,
    _flippedY:false,
    _textureLoaded:false,
    _newTextureWhenChangeColor: null,
    _className:"Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded:function(){
        return this._textureLoaded;
    },
    addLoadedEventListener:function(callback, target){
        this.addEventListener("load", callback, target);
    },
    isDirty:function () {
        return this.dirty;
    },
    setDirty:function (bDirty) {
        this.dirty = bDirty;
    },
    isTextureRectRotated:function () {
        return this._rectRotated;
    },
    getAtlasIndex:function () {
        return this.atlasIndex;
    },
    setAtlasIndex:function (atlasIndex) {
        this.atlasIndex = atlasIndex;
    },
    getTextureRect:function () {
        return cc.rect(this._rect);
    },
    getTextureAtlas:function () {
        return this.textureAtlas;
    },
    setTextureAtlas:function (textureAtlas) {
        this.textureAtlas = textureAtlas;
    },
    getOffsetPosition:function () {
        return cc.p(this._offsetPosition);
    },
	_getOffsetX: function () {
		return this._offsetPosition.x;
	},
	_getOffsetY: function () {
		return this._offsetPosition.y;
	},
    getBlendFunc:function () {
        return this._blendFunc;
    },
    initWithSpriteFrame:function (spriteFrame) {
        cc.assert(spriteFrame, cc._LogInfos.Sprite_initWithSpriteFrame);
        if(!spriteFrame.textureLoaded()){
            this._textureLoaded = false;
            spriteFrame.addEventListener("load", this._spriteFrameLoadedCallback, this);
        }
        var rotated = cc._renderType === cc._RENDER_TYPE_CANVAS ? false : spriteFrame._rotated;
        var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect(), rotated);
        this.setSpriteFrame(spriteFrame);
        return ret;
    },
    _spriteFrameLoadedCallback:null,
    initWithSpriteFrameName:function (spriteFrameName) {
        cc.assert(spriteFrameName, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var frame = cc.spriteFrameCache.getSpriteFrame(spriteFrameName);
        cc.assert(frame, spriteFrameName + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(frame);
    },
    useBatchNode:function (batchNode) {
        this.textureAtlas = batchNode.textureAtlas;
        this._batchNode = batchNode;
    },
    setVertexRect:function (rect) {
        var locRect = this._rect;
        locRect.x = rect.x;
        locRect.y = rect.y;
        locRect.width = rect.width;
        locRect.height = rect.height;
    },
    sortAllChildren:function () {
        if (this._reorderChildDirty) {
            var _children = this._children;
            var len = _children.length, i, j, tmp;
            for(i=1; i<len; i++){
                tmp = _children[i];
                j = i - 1;
                while(j >= 0){
                    if(tmp._localZOrder < _children[j]._localZOrder){
                        _children[j+1] = _children[j];
                    }else if(tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder){
                        _children[j+1] = _children[j];
                    }else{
                        break;
                    }
                    j--;
                }
                _children[j+1] = tmp;
            }
            if (this._batchNode) {
                this._arrayMakeObjectsPerformSelector(_children, cc.Node._StateCallbackType.sortAllChildren);
            }
            this._reorderChildDirty = false;
        }
    },
    reorderChild:function (child, zOrder) {
        cc.assert(child, cc._LogInfos.Sprite_reorderChild_2);
        if(this._children.indexOf(child) === -1){
            cc.log(cc._LogInfos.Sprite_reorderChild);
            return;
        }
        if (zOrder === child.zIndex)
            return;
        if (this._batchNode && !this._reorderChildDirty) {
            this._setReorderChildDirtyRecursively();
            this._batchNode.reorderBatch(true);
        }
        cc.Node.prototype.reorderChild.call(this, child, zOrder);
    },
    removeChild:function (child, cleanup) {
        if (this._batchNode)
            this._batchNode.removeSpriteFromAtlas(child);
        cc.Node.prototype.removeChild.call(this, child, cleanup);
    },
    setVisible:function (visible) {
        cc.Node.prototype.setVisible.call(this, visible);
        this.setDirtyRecursively(true);
    },
    removeAllChildren:function (cleanup) {
        var locChildren = this._children, locBatchNode = this._batchNode;
        if (locBatchNode && locChildren != null) {
            for (var i = 0, len = locChildren.length; i < len; i++)
                locBatchNode.removeSpriteFromAtlas(locChildren[i]);
        }
        cc.Node.prototype.removeAllChildren.call(this, cleanup);
        this._hasChildren = false;
    },
	setDirtyRecursively:function (value) {
		this._recursiveDirty = value;
		this.dirty = value;
		var locChildren = this._children, child, l = locChildren ? locChildren.length : 0;
		for (var i = 0; i < l; i++) {
			child = locChildren[i];
			(child instanceof cc.Sprite) && child.setDirtyRecursively(true);
		}
	},
	setNodeDirty: function(norecursive) {
		cc.Node.prototype.setNodeDirty.call(this);
		if (!norecursive && this._batchNode && !this._recursiveDirty) {
			if (this._hasChildren)
				this.setDirtyRecursively(true);
			else {
				this._recursiveDirty = true;
				this.dirty = true;
			}
		}
	},
    ignoreAnchorPointForPosition:function (relative) {
        if(this._batchNode){
            cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition);
            return;
        }
        cc.Node.prototype.ignoreAnchorPointForPosition.call(this, relative);
    },
    setFlippedX:function (flippedX) {
        if (this._flippedX != flippedX) {
            this._flippedX = flippedX;
            this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
            this.setNodeDirty(true);
        }
    },
    setFlippedY:function (flippedY) {
        if (this._flippedY != flippedY) {
            this._flippedY = flippedY;
            this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
            this.setNodeDirty(true);
        }
    },
    isFlippedX:function () {
        return this._flippedX;
    },
    isFlippedY:function () {
        return this._flippedY;
    },
    setOpacityModifyRGB:null,
    isOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName:function (animationName, frameIndex) {
        cc.assert(animationName, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var cache = cc.animationCache.getAnimation(animationName);
        if(!cache){
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName);
            return;
        }
        var animFrame = cache.getFrames()[frameIndex];
        if(!animFrame){
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2);
            return;
        }
        this.setSpriteFrame(animFrame.getSpriteFrame());
    },
    getBatchNode:function () {
        return this._batchNode;
    },
    _setReorderChildDirtyRecursively:function () {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = true;
            var pNode = this._parent;
            while (pNode && pNode != this._batchNode) {
                pNode._setReorderChildDirtyRecursively();
                pNode = pNode.parent;
            }
        }
    },
    getTexture:function () {
        return this._texture;
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: false,
    _colorized: false,
    _blendFuncStr: "source",
    _originalTexture: null,
    _drawSize_Canvas: null,
    ctor: null,
	_softInit: function (fileName, rect, rotated) {
		if (fileName === undefined)
			cc.Sprite.prototype.init.call(this);
		else if (cc.isString(fileName)) {
			if (fileName[0] === "#") {
				var frameName = fileName.substr(1, fileName.length - 1);
				var spriteFrame = cc.spriteFrameCache.getSpriteFrame(frameName);
				this.initWithSpriteFrame(spriteFrame);
			} else {
				cc.Sprite.prototype.init.call(this, fileName, rect);
			}
		} else if (cc.isObject(fileName)) {
			if (fileName instanceof cc.Texture2D) {
				this.initWithTexture(fileName, rect, rotated);
			} else if (fileName instanceof cc.SpriteFrame) {
				this.initWithSpriteFrame(fileName);
			} else if ((fileName instanceof HTMLImageElement) || (fileName instanceof HTMLCanvasElement)) {
				var texture2d = new cc.Texture2D();
				texture2d.initWithElement(fileName);
				texture2d.handleLoadedTexture();
				this.initWithTexture(texture2d);
			}
		}
	},
    getQuad:function () {
        return this._quad;
    },
    setBlendFunc: null,
    init:null,
    initWithFile:function (filename, rect) {
        cc.assert(filename, cc._LogInfos.Sprite_initWithFile);
        var tex = cc.textureCache.getTextureForKey(filename);
        if (!tex) {
            tex = cc.textureCache.addImage(filename);
            return this.initWithTexture(tex, rect || cc.rect(0, 0, tex._contentSize.width, tex._contentSize.height));
        } else {
            if (!rect) {
                var size = tex.getContentSize();
                rect = cc.rect(0, 0, size.width, size.height);
            }
            return this.initWithTexture(tex, rect);
        }
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect:null,
    updateTransform: null,
    addChild: null,
    updateColor:function () {
        var locDisplayedColor = this._displayedColor, locDisplayedOpacity = this._displayedOpacity;
        var color4 = {r: locDisplayedColor.r, g: locDisplayedColor.g, b: locDisplayedColor.b, a: locDisplayedOpacity};
        if (this._opacityModifyRGB) {
            color4.r *= locDisplayedOpacity / 255.0;
            color4.g *= locDisplayedOpacity / 255.0;
            color4.b *= locDisplayedOpacity / 255.0;
        }
        var locQuad = this._quad;
        locQuad.bl.colors = color4;
        locQuad.br.colors = color4;
        locQuad.tl.colors = color4;
        locQuad.tr.colors = color4;
        if (this._batchNode) {
            if (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED) {
                this.textureAtlas.updateQuad(locQuad, this.atlasIndex)
            } else {
                this.dirty = true;
            }
        }
        this._quadDirty = true;
    },
    setOpacity:null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(newFrame){
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(newFrame);
    },
    isFrameDisplayed: null,
    displayFrame: function () {
        return new cc.SpriteFrame(this._texture,
                                  cc.rectPointsToPixels(this._rect),
                                  this._rectRotated,
                                  cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter),
                                  cc.sizePointsToPixels(this._contentSize));
    },
    setBatchNode:null,
    setTexture: null,
    _updateBlendFunc:function () {
        if(this._batchNode){
            cc.log(cc._LogInfos.Sprite__updateBlendFunc);
            return;
        }
        if (!this._texture || !this._texture.hasPremultipliedAlpha()) {
            this._blendFunc.src = cc.SRC_ALPHA;
            this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
            this.opacityModifyRGB = false;
        } else {
            this._blendFunc.src = cc.BLEND_SRC;
            this._blendFunc.dst = cc.BLEND_DST;
            this.opacityModifyRGB = true;
        }
    },
    _changeTextureColor: function () {
        var locElement, locTexture = this._texture, locRect = this._rendererCmd._textureCoord;
        if (locTexture && locRect.validRect && this._originalTexture) {
            locElement = locTexture.getHtmlElementObj();
            if (!locElement)
                return;
            this._colorized = true;
            if (locElement instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor
                && this._originalTexture._htmlElementObj != locElement)
                cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, locRect, locElement);
            else {
                locElement = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, locRect);
                locTexture = new cc.Texture2D();
                locTexture.initWithElement(locElement);
                locTexture.handleLoadedTexture();
                this.texture = locTexture;
            }
        }
    },
    _setTextureCoords:function (rect) {
        rect = cc.rectPointsToPixels(rect);
        var tex = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!tex)
            return;
        var atlasWidth = tex.pixelsWidth;
        var atlasHeight = tex.pixelsHeight;
        var left, right, top, bottom, tempSwap, locQuad = this._quad;
        if (this._rectRotated) {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.height * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.width * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.height) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.width) / atlasHeight;
            }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
            if (this._flippedX) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = top;
            locQuad.br.texCoords.u = left;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = right;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = bottom;
        } else {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.width * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.height * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.width) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.height) / atlasHeight;
            }
            if (this._flippedX) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = bottom;
            locQuad.br.texCoords.u = right;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = left;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = top;
        }
        this._quadDirty = true;
    }
});
cc.Sprite.create = function (fileName, rect, rotated) {
    return new cc.Sprite(fileName, rect, rotated);
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Sprite.prototype;
    _p._spriteFrameLoadedCallback = function(spriteFrame){
        var _t = this;
        _t.setNodeDirty(true);
        _t.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
        var curColor = _t.color;
        if (curColor.r !== 255 || curColor.g !== 255 || curColor.b !== 255)
            _t._changeTextureColor();
        _t.dispatchEvent("load");
    };
    _p.setOpacityModifyRGB = function (modify) {
        if (this._opacityModifyRGB !== modify) {
            this._opacityModifyRGB = modify;
            this.setNodeDirty(true);
        }
    };
    _p.updateDisplayedOpacity = function (parentOpacity) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._setNodeDirtyForCache();
    };
    _p.ctor = function (fileName, rect, rotated) {
        var self = this;
        cc.Node.prototype.ctor.call(self);
        self._shouldBeHidden = false;
        self._offsetPosition = cc.p(0, 0);
        self._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        self._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        self._rect = cc.rect(0, 0, 0, 0);
        self._newTextureWhenChangeColor = false;
        self._textureLoaded = true;
        self._drawSize_Canvas = cc.size(0, 0);
        self._softInit(fileName, rect, rotated);
    };
    _p._initRendererCmd = function(){
        this._rendererCmd = new cc.TextureRenderCmdCanvas(this);
    };
    _p.setBlendFunc = function (src, dst) {
        var _t = this, locBlendFunc = this._blendFunc;
        if (dst === undefined) {
            locBlendFunc.src = src.src;
            locBlendFunc.dst = src.dst;
        } else {
            locBlendFunc.src = src;
            locBlendFunc.dst = dst;
        }
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)
            _t._blendFuncStr = cc._getCompositeOperationByBlendFunc(locBlendFunc);
    };
    _p.init = function () {
        var _t = this;
        if (arguments.length > 0)
            return _t.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(_t);
        _t.dirty = _t._recursiveDirty = false;
        _t._blendFunc.src = cc.BLEND_SRC;
        _t._blendFunc.dst = cc.BLEND_DST;
        _t.texture = null;
        _t._textureLoaded = true;
        _t._flippedX = _t._flippedY = false;
        _t.anchorX = 0.5;
        _t.anchorY = 0.5;
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        _t._hasChildren = false;
        _t.setTextureRect(cc.rect(0, 0, 0, 0), false, cc.size(0, 0));
        return true;
    };
    _p.initWithTexture = function (texture, rect, rotated) {
        var _t = this;
        cc.assert(arguments.length != 0, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        rotated = rotated || false;
        if (rotated && texture.isLoaded()) {
            var tempElement = texture.getHtmlElementObj();
            tempElement = cc.cutRotateImageToCanvas(tempElement, rect);
            var tempTexture = new cc.Texture2D();
            tempTexture.initWithElement(tempElement);
            tempTexture.handleLoadedTexture();
            texture = tempTexture;
            _t._rect = cc.rect(0, 0, rect.width, rect.height);
        }
        if (!cc.Node.prototype.init.call(_t))
            return false;
        _t._batchNode = null;
        _t._recursiveDirty = false;
        _t.dirty = false;
        _t._opacityModifyRGB = true;
        _t._blendFunc.src = cc.BLEND_SRC;
        _t._blendFunc.dst = cc.BLEND_DST;
        _t._flippedX = _t._flippedY = false;
        _t.anchorX = 0.5;
        _t.anchorY = 0.5;
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        _t._hasChildren = false;
        var locTextureLoaded = texture.isLoaded();
        _t._textureLoaded = locTextureLoaded;
        if (!locTextureLoaded) {
            _t._rectRotated = rotated;
            if (rect) {
                _t._rect.x = rect.x;
                _t._rect.y = rect.y;
                _t._rect.width = rect.width;
                _t._rect.height = rect.height;
            }
            if(_t.texture)
                _t.texture.removeEventListener("load", _t);
            texture.addEventListener("load", _t._textureLoadedCallback, _t);
            _t.texture = texture;
            return true;
        }
        if (!rect) {
            rect = cc.rect(0, 0, texture.width, texture.height);
        }
        if(texture && texture.url) {
            var _x = rect.x + rect.width, _y = rect.y + rect.height;
            if(_x > texture.width){
                cc.error(cc._LogInfos.RectWidth, texture.url);
            }
            if(_y > texture.height){
                cc.error(cc._LogInfos.RectHeight, texture.url);
            }
        }
        _t._originalTexture = texture;
        _t.texture = texture;
        _t.setTextureRect(rect, rotated);
        _t.batchNode = null;
        return true;
    };
    _p._textureLoadedCallback = function (sender) {
        var _t = this;
        if(_t._textureLoaded)
            return;
        _t._textureLoaded = true;
        var locRect = _t._rect;
        if (!locRect) {
            locRect = cc.rect(0, 0, sender.width, sender.height);
        } else if (cc._rectEqualToZero(locRect)) {
            locRect.width = sender.width;
            locRect.height = sender.height;
        }
        _t._originalTexture = sender;
        _t.texture = sender;
        _t.setTextureRect(locRect, _t._rectRotated);
        var locColor = this._displayedColor;
        if(locColor.r != 255 || locColor.g != 255 || locColor.b != 255)
            _t._changeTextureColor();
        _t.batchNode = _t._batchNode;
        _t.dispatchEvent("load");
    };
    _p.setTextureRect = function (rect, rotated, untrimmedSize) {
        var _t = this;
        _t._rectRotated = rotated || false;
        _t.setContentSize(untrimmedSize || rect);
        _t.setVertexRect(rect);
        var locTextureRect = _t._rendererCmd._textureCoord,
            scaleFactor = cc.contentScaleFactor();
        locTextureRect.renderX = locTextureRect.x = 0 | (rect.x * scaleFactor);
        locTextureRect.renderY = locTextureRect.y = 0 | (rect.y * scaleFactor);
        locTextureRect.width = 0 | (rect.width * scaleFactor);
        locTextureRect.height = 0 | (rect.height * scaleFactor);
        locTextureRect.validRect = !(locTextureRect.width === 0 || locTextureRect.height === 0 || locTextureRect.x < 0 || locTextureRect.y < 0);
        var relativeOffset = _t._unflippedOffsetPositionFromCenter;
        if (_t._flippedX)
            relativeOffset.x = -relativeOffset.x;
        if (_t._flippedY)
            relativeOffset.y = -relativeOffset.y;
        _t._offsetPosition.x = relativeOffset.x + (_t._contentSize.width - _t._rect.width) / 2;
        _t._offsetPosition.y = relativeOffset.y + (_t._contentSize.height - _t._rect.height) / 2;
        if (_t._batchNode) {
            _t.dirty = true;
        }
    };
    _p.updateTransform = function () {
        var _t = this;
        if (_t.dirty) {
            var locParent = _t._parent;
            if (!_t._visible || ( locParent && locParent != _t._batchNode && locParent._shouldBeHidden)) {
                _t._shouldBeHidden = true;
            } else {
                _t._shouldBeHidden = false;
                if (!locParent || locParent == _t._batchNode) {
                    _t._transformToBatch = _t.nodeToParentTransform();
                } else {
                    _t._transformToBatch = cc.affineTransformConcat(_t.nodeToParentTransform(), locParent._transformToBatch);
                }
            }
            _t._recursiveDirty = false;
            _t.dirty = false;
        }
        if (_t._hasChildren)
            _t._arrayMakeObjectsPerformSelector(_t._children, cc.Node._StateCallbackType.updateTransform);
    };
    _p.addChild = function (child, localZOrder, tag) {
        cc.assert(child, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        if (localZOrder == null)
            localZOrder = child._localZOrder;
        if (tag == null)
            tag = child.tag;
        cc.Node.prototype.addChild.call(this, child, localZOrder, tag);
        this._hasChildren = true;
    };
    _p.setOpacity = function (opacity) {
        cc.Node.prototype.setOpacity.call(this, opacity);
        this._setNodeDirtyForCache();
    };
    _p.setColor = function (color3) {
        var _t = this;
        var curColor = _t.color;
        this._oldDisplayColor = curColor;
        if ((curColor.r === color3.r) && (curColor.g === color3.g) && (curColor.b === color3.b))
            return;
        cc.Node.prototype.setColor.call(_t, color3);
    };
    _p.updateDisplayedColor = function (parentColor) {
        var _t = this;
        cc.Node.prototype.updateDisplayedColor.call(_t, parentColor);
        var oColor = _t._oldDisplayColor;
        var nColor = _t._displayedColor;
        if (oColor.r === nColor.r && oColor.g === nColor.g && oColor.b === nColor.b)
            return;
        _t._changeTextureColor();
        _t._setNodeDirtyForCache();
    };
    _p.setSpriteFrame = function (newFrame) {
        var _t = this;
        if(cc.isString(newFrame)){
            newFrame = cc.spriteFrameCache.getSpriteFrame(newFrame);
            cc.assert(newFrame, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame)
        }
        _t.setNodeDirty(true);
        var frameOffset = newFrame.getOffset();
        _t._unflippedOffsetPositionFromCenter.x = frameOffset.x;
        _t._unflippedOffsetPositionFromCenter.y = frameOffset.y;
        _t._rectRotated = newFrame.isRotated();
        var pNewTexture = newFrame.getTexture();
        var locTextureLoaded = newFrame.textureLoaded();
        if (!locTextureLoaded) {
            _t._textureLoaded = false;
            newFrame.addEventListener("load", function (sender) {
                _t._textureLoaded = true;
                var locNewTexture = sender.getTexture();
                if (locNewTexture != _t._texture)
                    _t.texture = locNewTexture;
                _t.setTextureRect(sender.getRect(), sender.isRotated(), sender.getOriginalSize());
                _t.dispatchEvent("load");
            }, _t);
        }
        if (pNewTexture != _t._texture)
            _t.texture = pNewTexture;
        if (_t._rectRotated)
            _t._originalTexture = pNewTexture;
        _t.setTextureRect(newFrame.getRect(), _t._rectRotated, newFrame.getOriginalSize());
        _t._colorized = false;
        _t._rendererCmd._textureCoord.renderX = _t._rendererCmd._textureCoord.x;
        _t._rendererCmd._textureCoord.renderY = _t._rendererCmd._textureCoord.y;
        if (locTextureLoaded) {
            var curColor = _t.color;
            if (curColor.r !== 255 || curColor.g !== 255 || curColor.b !== 255)
                _t._changeTextureColor();
        }
    };
    _p.isFrameDisplayed = function (frame) {
        if (frame.getTexture() != this._texture)
            return false;
        return cc.rectEqualToRect(frame.getRect(), this._rect);
    };
    _p.setBatchNode = function (spriteBatchNode) {
        var _t = this;
        _t._batchNode = spriteBatchNode;
        if (!_t._batchNode) {
            _t.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED;
            _t.textureAtlas = null;
            _t._recursiveDirty = false;
            _t.dirty = false;
        } else {
            _t._transformToBatch = cc.affineTransformIdentity();
            _t.textureAtlas = _t._batchNode.textureAtlas;
        }
    };
    _p.setTexture = function (texture) {
        var _t = this;
        if(texture && (cc.isString(texture))){
            texture = cc.textureCache.addImage(texture);
            _t.setTexture(texture);
            var size = texture.getContentSize();
            _t.setTextureRect(cc.rect(0,0, size.width, size.height));
            if(!texture._isLoaded){
                texture.addEventListener("load", function(){
                    var size = texture.getContentSize();
                    _t.setTextureRect(cc.rect(0,0, size.width, size.height));
                }, this);
            }
            return;
        }
        cc.assert(!texture || texture instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture);
        if (_t._texture != texture) {
            if (texture && texture.getHtmlElementObj() instanceof  HTMLImageElement) {
                _t._originalTexture = texture;
            }
            _t._texture = texture;
        }
    };
    if(!cc.sys._supportCanvasNewBlendModes)
        _p._changeTextureColor =  function () {
            var locElement, locTexture = this._texture, locRect = this._rendererCmd._textureCoord;
            if (locTexture && locRect.validRect && this._originalTexture) {
                locElement = locTexture.getHtmlElementObj();
                if (!locElement)
                    return;
                var cacheTextureForColor = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
                if (cacheTextureForColor) {
                    this._colorized = true;
                    if (locElement instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor)
                        cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor, locRect, locElement);
                    else {
                        locElement = cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor, locRect);
                        locTexture = new cc.Texture2D();
                        locTexture.initWithElement(locElement);
                        locTexture.handleLoadedTexture();
                        this.texture = locTexture;
                    }
                }
            }
        };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLSprite), cc._LogInfos.MissingFile, "SpritesWebGL.js");
    cc._tmp.WebGLSprite();
    delete cc._tmp.WebGLSprite;
}
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function(){
        cc.Sprite.prototype.ctor.call(this);
        var canvasElement = document.createElement("canvas");
        canvasElement.width = canvasElement.height = 10;
        this._cacheCanvas = canvasElement;
        this._cacheContext = canvasElement.getContext("2d");
        var texture = new cc.Texture2D();
        texture.initWithElement(canvasElement);
        texture.handleLoadedTexture();
        this.setTexture(texture);
    },
    getCacheContext: function(){
        return this._cacheContext;
    },
    getCacheCanvas: function(){
        return this._cacheCanvas;
    },
    resetCanvasSize: function(sizeOrWidth, height){
        if(height === undefined){
            height = sizeOrWidth.height;
            sizeOrWidth = sizeOrWidth.width;
        }
        var locCanvas = this._cacheCanvas;
        locCanvas.width = sizeOrWidth;
        locCanvas.height = height;
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0,0, sizeOrWidth, height), false);
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame:null,
    _delayPerUnit:0,
    _userInfo:null,
    ctor:function (spriteFrame, delayUnits, userInfo) {
        this._spriteFrame = spriteFrame || null;
        this._delayPerUnit = delayUnits || 0;
        this._userInfo = userInfo || null;
    },
    clone: function(){
        var frame = new cc.AnimationFrame();
        frame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return frame;
    },
    copyWithZone:function (pZone) {
        return cc.clone(this);
    },
    copy:function (pZone) {
        var newFrame = new cc.AnimationFrame();
        newFrame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return newFrame;
    },
    initWithSpriteFrame:function (spriteFrame, delayUnits, userInfo) {
        this._spriteFrame = spriteFrame;
        this._delayPerUnit = delayUnits;
        this._userInfo = userInfo;
        return true;
    },
    getSpriteFrame:function () {
        return this._spriteFrame;
    },
    setSpriteFrame:function (spriteFrame) {
        this._spriteFrame = spriteFrame;
    },
    getDelayUnits:function () {
        return this._delayPerUnit;
    },
    setDelayUnits:function (delayUnits) {
        this._delayPerUnit = delayUnits;
    },
    getUserInfo:function () {
        return this._userInfo;
    },
    setUserInfo:function (userInfo) {
        this._userInfo = userInfo;
    }
});
cc.AnimationFrame.create = function(spriteFrame,delayUnits,userInfo){
    return new cc.AnimationFrame(spriteFrame,delayUnits,userInfo);
};
cc.Animation = cc.Class.extend({
    _frames:null,
    _loops:0,
    _restoreOriginalFrame:false,
    _duration:0,
    _delayPerUnit:0,
    _totalDelayUnits:0,
    ctor:function (frames, delay, loops) {
        this._frames = [];
		if (frames === undefined) {
			this.initWithSpriteFrames(null, 0);
		} else {
			var frame0 = frames[0];
			if(frame0){
				if (frame0 instanceof cc.SpriteFrame) {
					this.initWithSpriteFrames(frames, delay, loops);
				}else if(frame0 instanceof cc.AnimationFrame) {
					this.initWithAnimationFrames(frames, delay, loops);
				}
			}
		}
    },
    getFrames:function () {
        return this._frames;
    },
    setFrames:function (frames) {
        this._frames = frames;
    },
    addSpriteFrame:function (frame) {
        var animFrame = new cc.AnimationFrame();
        animFrame.initWithSpriteFrame(frame, 1, null);
        this._frames.push(animFrame);
        this._totalDelayUnits++;
    },
    addSpriteFrameWithFile:function (fileName) {
        var texture = cc.textureCache.addImage(fileName);
        var rect = cc.rect(0, 0, 0, 0);
        rect.width = texture.width;
        rect.height = texture.height;
        var frame = new cc.SpriteFrame(texture, rect);
        this.addSpriteFrame(frame);
    },
    addSpriteFrameWithTexture:function (texture, rect) {
        var pFrame = new cc.SpriteFrame(texture, rect);
        this.addSpriteFrame(pFrame);
    },
    initWithAnimationFrames:function (arrayOfAnimationFrames, delayPerUnit, loops) {
        cc.arrayVerifyType(arrayOfAnimationFrames, cc.AnimationFrame);
        this._delayPerUnit = delayPerUnit;
        this._loops = loops === undefined ? 1 : loops;
        this._totalDelayUnits = 0;
        var locFrames = this._frames;
        locFrames.length = 0;
        for (var i = 0; i < arrayOfAnimationFrames.length; i++) {
            var animFrame = arrayOfAnimationFrames[i];
            locFrames.push(animFrame);
            this._totalDelayUnits += animFrame.getDelayUnits();
        }
        return true;
    },
    clone: function(){
        var animation = new cc.Animation();
        animation.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        animation.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return animation;
    },
    copyWithZone:function (pZone) {
        var pCopy = new cc.Animation();
        pCopy.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        pCopy.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return pCopy;
    },
    _copyFrames:function(){
       var copyFrames = [];
        for(var i = 0; i< this._frames.length;i++)
            copyFrames.push(this._frames[i].clone());
        return copyFrames;
    },
    copy:function (pZone) {
        return this.copyWithZone(null);
    },
    getLoops:function () {
        return this._loops;
    },
    setLoops:function (value) {
        this._loops = value;
    },
    setRestoreOriginalFrame:function (restOrigFrame) {
        this._restoreOriginalFrame = restOrigFrame;
    },
    getRestoreOriginalFrame:function () {
        return this._restoreOriginalFrame;
    },
    getDuration:function () {
        return this._totalDelayUnits * this._delayPerUnit;
    },
    getDelayPerUnit:function () {
        return this._delayPerUnit;
    },
    setDelayPerUnit:function (delayPerUnit) {
        this._delayPerUnit = delayPerUnit;
    },
    getTotalDelayUnits:function () {
        return this._totalDelayUnits;
    },
    initWithSpriteFrames:function (frames, delay, loops) {
        cc.arrayVerifyType(frames, cc.SpriteFrame);
        this._loops = loops === undefined ? 1 : loops;
        this._delayPerUnit = delay || 0;
        this._totalDelayUnits = 0;
        var locFrames = this._frames;
        locFrames.length = 0;
        if (frames) {
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(frame, 1, null);
                locFrames.push(animFrame);
            }
            this._totalDelayUnits += frames.length;
        }
        return true;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.Animation.create = function (frames, delay, loops) {
    return new cc.Animation(frames, delay, loops);
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
	_animations: {},
    addAnimation:function (animation, name) {
        this._animations[name] = animation;
    },
    removeAnimation:function (name) {
        if (!name) {
            return;
        }
        if (this._animations[name]) {
            delete this._animations[name];
        }
    },
    getAnimation:function (name) {
        if (this._animations[name])
            return this._animations[name];
        return null;
    },
    _addAnimationsWithDictionary:function (dictionary,plist) {
        var animations = dictionary["animations"];
        if (!animations) {
            cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary);
            return;
        }
        var version = 1;
        var properties = dictionary["properties"];
        if (properties) {
            version = (properties["format"] != null) ? parseInt(properties["format"]) : version;
            var spritesheets = properties["spritesheets"];
            var spriteFrameCache = cc.spriteFrameCache;
            var path = cc.path;
            for (var i = 0; i < spritesheets.length; i++) {
                spriteFrameCache.addSpriteFrames(path.changeBasename(plist, spritesheets[i]));
            }
        }
        switch (version) {
            case 1:
                this._parseVersion1(animations);
                break;
            case 2:
                this._parseVersion2(animations);
                break;
            default :
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2);
                break;
        }
    },
    addAnimations:function (plist) {
        cc.assert(plist, cc._LogInfos.animationCache_addAnimations_2);
        var dict = cc.loader.getRes(plist);
        if(!dict){
            cc.log(cc._LogInfos.animationCache_addAnimations);
            return;
        }
        this._addAnimationsWithDictionary(dict,plist);
    },
    _parseVersion1:function (animations) {
        var frameCache = cc.spriteFrameCache;
        for (var key in animations) {
            var animationDict = animations[key];
            var frameNames = animationDict["frames"];
            var delay = parseFloat(animationDict["delay"]) || 0;
            var animation = null;
            if (!frameNames) {
                cc.log(cc._LogInfos.animationCache__parseVersion1, key);
                continue;
            }
            var frames = [];
            for (var i = 0; i < frameNames.length; i++) {
                var spriteFrame = frameCache.getSpriteFrame(frameNames[i]);
                if (!spriteFrame) {
                    cc.log(cc._LogInfos.animationCache__parseVersion1_2, key, frameNames[i]);
                    continue;
                }
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, 1, null);
                frames.push(animFrame);
            }
            if (frames.length === 0) {
                cc.log(cc._LogInfos.animationCache__parseVersion1_3, key);
                continue;
            } else if (frames.length != frameNames.length) {
                cc.log(cc._LogInfos.animationCache__parseVersion1_4, key);
            }
            animation = new cc.Animation(frames, delay, 1);
            cc.animationCache.addAnimation(animation, key);
        }
    },
    _parseVersion2:function (animations) {
        var frameCache = cc.spriteFrameCache;
        for (var key in animations) {
            var animationDict = animations[key];
            var isLoop = animationDict["loop"];
            var loopsTemp = parseInt(animationDict["loops"]);
            var loops = isLoop ? cc.REPEAT_FOREVER : ((isNaN(loopsTemp)) ? 1 : loopsTemp);
            var restoreOriginalFrame = (animationDict["restoreOriginalFrame"] && animationDict["restoreOriginalFrame"] == true) ? true : false;
            var frameArray = animationDict["frames"];
            if (!frameArray) {
                cc.log(cc._LogInfos.animationCache__parseVersion2, key);
                continue;
            }
            var arr = [];
            for (var i = 0; i < frameArray.length; i++) {
                var entry = frameArray[i];
                var spriteFrameName = entry["spriteframe"];
                var spriteFrame = frameCache.getSpriteFrame(spriteFrameName);
                if (!spriteFrame) {
                    cc.log(cc._LogInfos.animationCache__parseVersion2_2, key, spriteFrameName);
                    continue;
                }
                var delayUnits = parseFloat(entry["delayUnits"]) || 0;
                var userInfo = entry["notification"];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, delayUnits, userInfo);
                arr.push(animFrame);
            }
            var delayPerUnit = parseFloat(animationDict["delayPerUnit"]) || 0;
            var animation = new cc.Animation();
            animation.initWithAnimationFrames(arr, delayPerUnit, loops);
            animation.setRestoreOriginalFrame(restoreOriginalFrame);
            cc.animationCache.addAnimation(animation, key);
        }
    },
	_clear: function () {
		this._animations = {};
	}
};
cc.SpriteFrame = cc.Class.extend({
    _offset:null,
    _originalSize:null,
    _rectInPixels:null,
    _rotated:false,
    _rect:null,
    _offsetInPixels:null,
    _originalSizeInPixels:null,
    _texture:null,
    _textureFilename:"",
    _textureLoaded:false,
    ctor:function (filename, rect, rotated, offset, originalSize) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = false;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = false;
        if(filename !== undefined && rect !== undefined ){
            if(rotated === undefined || offset === undefined || originalSize === undefined)
                this.initWithTexture(filename, rect);
            else
                this.initWithTexture(filename, rect, rotated, offset, originalSize)
        }
    },
    textureLoaded:function(){
        return this._textureLoaded;
    },
    addLoadedEventListener:function(callback, target){
        this.addEventListener("load", callback, target);
    },
    getRectInPixels:function () {
        var locRectInPixels = this._rectInPixels;
        return cc.rect(locRectInPixels.x, locRectInPixels.y, locRectInPixels.width, locRectInPixels.height);
    },
    setRectInPixels:function (rectInPixels) {
        if (!this._rectInPixels){
            this._rectInPixels = cc.rect(0,0,0,0);
        }
        this._rectInPixels.x = rectInPixels.x;
        this._rectInPixels.y = rectInPixels.y;
        this._rectInPixels.width = rectInPixels.width;
        this._rectInPixels.height = rectInPixels.height;
        this._rect = cc.rectPixelsToPoints(rectInPixels);
    },
    isRotated:function () {
        return this._rotated;
    },
    setRotated:function (bRotated) {
        this._rotated = bRotated;
    },
    getRect:function () {
        var locRect = this._rect;
        return cc.rect(locRect.x, locRect.y, locRect.width, locRect.height);
    },
    setRect:function (rect) {
        if (!this._rect){
            this._rect = cc.rect(0,0,0,0);
        }
        this._rect.x = rect.x;
        this._rect.y = rect.y;
        this._rect.width = rect.width;
        this._rect.height = rect.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect);
    },
    getOffsetInPixels:function () {
        return cc.p(this._offsetInPixels);
    },
    setOffsetInPixels:function (offsetInPixels) {
        this._offsetInPixels.x = offsetInPixels.x;
        this._offsetInPixels.y = offsetInPixels.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset);
    },
    getOriginalSizeInPixels:function () {
        return cc.size(this._originalSizeInPixels);
    },
    setOriginalSizeInPixels:function (sizeInPixels) {
        this._originalSizeInPixels.width = sizeInPixels.width;
        this._originalSizeInPixels.height = sizeInPixels.height;
    },
    getOriginalSize:function () {
        return cc.size(this._originalSize);
    },
    setOriginalSize:function (sizeInPixels) {
        this._originalSize.width = sizeInPixels.width;
        this._originalSize.height = sizeInPixels.height;
    },
    getTexture:function () {
        if (this._texture)
            return this._texture;
        if (this._textureFilename !== "") {
            var locTexture = cc.textureCache.addImage(this._textureFilename);
            if (locTexture)
                this._textureLoaded = locTexture.isLoaded();
            return locTexture;
        }
        return null;
    },
    setTexture:function (texture) {
        if (this._texture != texture) {
            var locLoaded = texture.isLoaded();
            this._textureLoaded = locLoaded;
            this._texture = texture;
            if(!locLoaded){
                texture.addEventListener("load", function(sender){
                    this._textureLoaded = true;
                    if(this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS){
                        var tempElement = sender.getHtmlElementObj();
                        tempElement = cc.cutRotateImageToCanvas(tempElement, this.getRect());
                        var tempTexture = new cc.Texture2D();
                        tempTexture.initWithElement(tempElement);
                        tempTexture.handleLoadedTexture();
                        this.setTexture(tempTexture);
                        var rect = this.getRect();
                        this.setRect(cc.rect(0, 0, rect.width, rect.height));
                    }
                    var locRect = this._rect;
                    if(locRect.width === 0 && locRect.height === 0){
                        var w = sender.width, h = sender.height;
                        this._rect.width = w;
                        this._rect.height = h;
                        this._rectInPixels = cc.rectPointsToPixels(this._rect);
                        this._originalSizeInPixels.width = this._rectInPixels.width;
                        this._originalSizeInPixels.height = this._rectInPixels.height;
                        this._originalSize.width =  w;
                        this._originalSize.height =  h;
                    }
                    this.dispatchEvent("load");
                }, this);
            }
        }
    },
    getOffset:function () {
        return cc.p(this._offset);
    },
    setOffset:function (offsets) {
        this._offset.x = offsets.x;
        this._offset.y = offsets.y;
    },
    clone: function(){
        var frame = new cc.SpriteFrame();
        frame.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        frame.setTexture(this._texture);
        return frame;
    },
    copyWithZone:function () {
        var copy = new cc.SpriteFrame();
        copy.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        copy.setTexture(this._texture);
        return copy;
    },
    copy:function () {
        return this.copyWithZone();
    },
    initWithTexture:function (texture, rect, rotated, offset, originalSize) {
        if(arguments.length === 2)
            rect = cc.rectPointsToPixels(rect);
        offset = offset || cc.p(0, 0);
        originalSize = originalSize || rect;
        rotated = rotated || false;
        if (cc.isString(texture)){
            this._texture = null;
            this._textureFilename = texture;
        } else if (texture instanceof cc.Texture2D){
            this.setTexture(texture);
        }
        texture = this.getTexture();
        this._rectInPixels = rect;
        rect = this._rect = cc.rectPixelsToPoints(rect);
        if(texture && texture.url && texture.isLoaded()) {
            var _x, _y;
            if(rotated){
                _x = rect.x + rect.height;
                _y = rect.y + rect.width;
            }else{
                _x = rect.x + rect.width;
                _y = rect.y + rect.height;
            }
            if(_x > texture.getPixelsWide()){
                cc.error(cc._LogInfos.RectWidth, texture.url);
            }
            if(_y > texture.getPixelsHigh()){
                cc.error(cc._LogInfos.RectHeight, texture.url);
            }
        }
        this._offsetInPixels.x = offset.x;
        this._offsetInPixels.y = offset.y;
        cc._pointPixelsToPointsOut(offset, this._offset);
        this._originalSizeInPixels.width = originalSize.width;
        this._originalSizeInPixels.height = originalSize.height;
        cc._sizePixelsToPointsOut(originalSize, this._originalSize);
        this._rotated = rotated;
        return true;
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function (filename, rect, rotated, offset, originalSize) {
    return new cc.SpriteFrame(filename,rect,rotated,offset,originalSize);
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function (texture, rect, rotated, offset, originalSize) {
    var spriteFrame = new cc.SpriteFrame();
    spriteFrame._texture = texture;
    spriteFrame._rectInPixels = rect;
    spriteFrame._rect = cc.rectPixelsToPoints(rect);
    spriteFrame._offsetInPixels.x = offset.x;
    spriteFrame._offsetInPixels.y = offset.y;
    cc._pointPixelsToPointsOut(spriteFrame._offsetInPixels, spriteFrame._offset);
    spriteFrame._originalSizeInPixels.width = originalSize.width;
    spriteFrame._originalSizeInPixels.height = originalSize.height;
    cc._sizePixelsToPointsOut(spriteFrame._originalSizeInPixels, spriteFrame._originalSize);
    spriteFrame._rotated = rotated;
    return spriteFrame;
};
cc.spriteFrameCache = {
    _CCNS_REG1 : /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2 : /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache : {},
    _rectFromString :  function (content) {
        var result = this._CCNS_REG2.exec(content);
        if(!result) return cc.rect(0, 0, 0, 0);
        return cc.rect(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]), parseFloat(result[4]));
    },
    _pointFromString : function (content) {
        var result = this._CCNS_REG1.exec(content);
        if(!result) return cc.p(0,0);
        return cc.p(parseFloat(result[1]), parseFloat(result[2]));
    },
    _sizeFromString : function (content) {
        var result = this._CCNS_REG1.exec(content);
        if(!result) return cc.size(0, 0);
        return cc.size(parseFloat(result[1]), parseFloat(result[2]));
    },
    _getFrameConfig : function(url){
        var dict = cc.loader.getRes(url);
        cc.assert(dict, cc._LogInfos.spriteFrameCache__getFrameConfig_2, url);
        cc.loader.release(url);//release it in loader
        if(dict._inited){
            this._frameConfigCache[url] = dict;
            return dict;
        }
        var tempFrames = dict["frames"], tempMeta = dict["metadata"] || dict["meta"];
        var frames = {}, meta = {};
        var format = 0;
        if(tempMeta){//init meta
            var tmpFormat = tempMeta["format"];
            format = (tmpFormat.length <= 1) ? parseInt(tmpFormat) : tmpFormat;
            meta.image = tempMeta["textureFileName"] || tempMeta["textureFileName"] || tempMeta["image"];
        }
        for (var key in tempFrames) {
            var frameDict = tempFrames[key];
            if(!frameDict) continue;
            var tempFrame = {};
            if (format == 0) {
                tempFrame.rect = cc.rect(frameDict["x"], frameDict["y"], frameDict["width"], frameDict["height"]);
                tempFrame.rotated = false;
                tempFrame.offset = cc.p(frameDict["offsetX"], frameDict["offsetY"]);
                var ow = frameDict["originalWidth"];
                var oh = frameDict["originalHeight"];
                if (!ow || !oh) {
                    cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                }
                ow = Math.abs(ow);
                oh = Math.abs(oh);
                tempFrame.size = cc.size(ow, oh);
            } else if (format == 1 || format == 2) {
                tempFrame.rect = this._rectFromString(frameDict["frame"]);
                tempFrame.rotated = frameDict["rotated"] || false;
                tempFrame.offset = this._pointFromString(frameDict["offset"]);
                tempFrame.size = this._sizeFromString(frameDict["sourceSize"]);
            } else if (format == 3) {
                var spriteSize = this._sizeFromString(frameDict["spriteSize"]);
                var textureRect = this._rectFromString(frameDict["textureRect"]);
                if (spriteSize) {
                    textureRect = cc.rect(textureRect.x, textureRect.y, spriteSize.width, spriteSize.height);
                }
                tempFrame.rect = textureRect;
                tempFrame.rotated = frameDict["textureRotated"] || false;
                tempFrame.offset = this._pointFromString(frameDict["spriteOffset"]);
                tempFrame.size = this._sizeFromString(frameDict["spriteSourceSize"]);
                tempFrame.aliases = frameDict["aliases"];
            } else {
                var tmpFrame = frameDict["frame"], tmpSourceSize = frameDict["sourceSize"];
                key = frameDict["filename"] || key;
                tempFrame.rect = cc.rect(tmpFrame["x"], tmpFrame["y"], tmpFrame["w"], tmpFrame["h"]);
                tempFrame.rotated = frameDict["rotated"] || false;
                tempFrame.offset = cc.p(0, 0);
                tempFrame.size = cc.size(tmpSourceSize["w"], tmpSourceSize["h"]);
            }
            frames[key] = tempFrame;
        }
        var cfg = this._frameConfigCache[url] = {
            _inited : true,
            frames : frames,
            meta : meta
        };
        return cfg;
    },
    addSpriteFrames: function (url, texture) {
        cc.assert(url, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var dict = this._frameConfigCache[url] || cc.loader.getRes(url);
        if(!dict || !dict["frames"])
            return;
        var self = this;
        var frameConfig = self._frameConfigCache[url] || self._getFrameConfig(url);
        var frames = frameConfig.frames, meta = frameConfig.meta;
        if(!texture){
            var texturePath = cc.path.changeBasename(url, meta.image || ".png");
            texture = cc.textureCache.addImage(texturePath);
        }else if(texture instanceof cc.Texture2D){
        }else if(cc.isString(texture)){//string
            texture = cc.textureCache.addImage(texture);
        }else{
            cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3);
        }
        var spAliases = self._spriteFramesAliases, spriteFrames = self._spriteFrames;
        for (var key in frames) {
            var frame = frames[key];
            var spriteFrame = spriteFrames[key];
            if (!spriteFrame) {
                spriteFrame = new cc.SpriteFrame(texture, frame.rect, frame.rotated, frame.offset, frame.size);
                var aliases = frame.aliases;
                if(aliases){//set aliases
                    for(var i = 0, li = aliases.length; i < li; i++){
                        var alias = aliases[i];
                        if (spAliases[alias]) {
                            cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, alias);
                        }
                        spAliases[alias] = key;
                    }
                }
                if (cc._renderType === cc._RENDER_TYPE_CANVAS && spriteFrame.isRotated()) {
                    var locTexture = spriteFrame.getTexture();
                    if (locTexture.isLoaded()) {
                        var tempElement = spriteFrame.getTexture().getHtmlElementObj();
                        tempElement = cc.cutRotateImageToCanvas(tempElement, spriteFrame.getRectInPixels());
                        var tempTexture = new cc.Texture2D();
                        tempTexture.initWithElement(tempElement);
                        tempTexture.handleLoadedTexture();
                        spriteFrame.setTexture(tempTexture);
                        var rect = spriteFrame._rect;
                        spriteFrame.setRect(cc.rect(0, 0, rect.width, rect.height));
                    }
                }
                spriteFrames[key] = spriteFrame;
            }
        }
    },
    _checkConflict: function (dictionary) {
        var framesDict = dictionary["frames"];
        for (var key in framesDict) {
            if (this._spriteFrames[key]) {
                cc.log(cc._LogInfos.spriteFrameCache__checkConflict, key);
            }
        }
    },
    addSpriteFrame: function (frame, frameName) {
        this._spriteFrames[frameName] = frame;
    },
    removeSpriteFrames: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
    },
    removeSpriteFrameByName: function (name) {
        if (!name) {
            return;
        }
        if (this._spriteFramesAliases[name]) {
            delete(this._spriteFramesAliases[name]);
        }
        if (this._spriteFrames[name]) {
            delete(this._spriteFrames[name]);
        }
    },
    removeSpriteFramesFromFile: function (url) {
        var self = this, spriteFrames = self._spriteFrames,
            aliases = self._spriteFramesAliases, cfg = self._frameConfigCache[url];
        if(!cfg) return;
        var frames = cfg.frames;
        for (var key in frames) {
            if (spriteFrames[key]) {
                delete(spriteFrames[key]);
                for (var alias in aliases) {//remove alias
                    if(aliases[alias] == key) delete aliases[alias];
                }
            }
        }
    },
    removeSpriteFramesFromTexture: function (texture) {
        var self = this, spriteFrames = self._spriteFrames, aliases = self._spriteFramesAliases;
        for (var key in spriteFrames) {
            var frame = spriteFrames[key];
            if (frame && (frame.getTexture() == texture)) {
                delete(spriteFrames[key]);
                for (var alias in aliases) {//remove alias
                    if(aliases[alias] == key) delete aliases[alias];
                }
            }
        }
    },
    getSpriteFrame: function (name) {
        var self = this, frame = self._spriteFrames[name];
        if (!frame) {
            var key = self._spriteFramesAliases[name];
            if (key) {
                frame = self._spriteFrames[key.toString()];
                if(!frame) delete self._spriteFramesAliases[name];
            }
        }
        if (!frame) cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, name);
        return frame;
    },
	_clear: function () {
		this._spriteFrames = {};
		this._spriteFramesAliases = {};
		this._frameConfigCache = {};
	}
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function (transformOut) {
    var projection = new cc.kmMat4();
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, projection);
    var modelview = new cc.kmMat4();
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, modelview);
    cc.kmMat4Multiply(transformOut, projection, modelview);
};
cc.Director = cc.Class.extend({
    _landscape: false,
    _nextDeltaTimeZero: false,
    _paused: false,
    _purgeDirectorInNextLoop: false,
    _sendCleanupToScene: false,
    _animationInterval: 0.0,
    _oldAnimationInterval: 0.0,
    _projection: 0,
    _accumDt: 0.0,
    _contentScaleFactor: 1.0,
    _displayStats: false,
    _deltaTime: 0.0,
    _frameRate: 0.0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function () {
        var self = this;
        self._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            self._lastUpdate = Date.now();
        });
    },
    init: function () {
        this._oldAnimationInterval = this._animationInterval = 1.0 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._accumDt = 0;
        this._frameRate = 0;
        this._displayStats = false;//can remove
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1.0;
        this._scheduler = new cc.Scheduler();
        this._actionManager = cc.ActionManager ? new cc.ActionManager() : null;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return true;
    },
    calculateDeltaTime: function () {
        var now = Date.now();
        if (this._nextDeltaTimeZero) {
            this._deltaTime = 0;
            this._nextDeltaTimeZero = false;
        } else {
            this._deltaTime = (now - this._lastUpdate) / 1000;
        }
        if ((cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0) && (this._deltaTime > 0.2))
            this._deltaTime = 1 / 60.0;
        this._lastUpdate = now;
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function () {
        var renderer = cc.renderer;
        this.calculateDeltaTime();
        if (!this._paused) {
            this._scheduler.update(this._deltaTime);
            cc.eventManager.dispatchEvent(this._eventAfterUpdate);
        }
        this._clear();
        if (this._nextScene) {
            this.setNextScene();
        }
        if (this._beforeVisitScene)
            this._beforeVisitScene();
        if (this._runningScene) {
            if (renderer.childrenOrderDirty === true) {
                cc.renderer.clearRenderCommands();
                this._runningScene._curLevel = 0;
                this._runningScene.visit();
                renderer.resetFlag();
            } else if (renderer.transformDirty() === true)
                renderer.transform();
            cc.eventManager.dispatchEvent(this._eventAfterVisit);
        }
        if (this._notificationNode)
            this._notificationNode.visit();
        if (this._displayStats)
            this._showStats();
        if (this._afterVisitScene)
            this._afterVisitScene();
        renderer.rendering(cc._renderContext);
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        if (this._displayStats)
            this._calculateMPF();
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function () {
        this._purgeDirectorInNextLoop = true;
    },
    getContentScaleFactor: function () {
        return this._contentScaleFactor;
    },
    getNotificationNode: function () {
        return this._notificationNode;
    },
    getWinSize: function () {
        return cc.size(this._winSizeInPoints);
    },
    getWinSizeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function () {
        if (this._paused)
            return;
        this._oldAnimationInterval = this._animationInterval;
        this.setAnimationInterval(1 / 4.0);
        this._paused = true;
    },
    popScene: function () {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var c = this._scenesStack.length;
        if (c == 0)
            this.end();
        else {
            this._sendCleanupToScene = true;
            this._nextScene = this._scenesStack[c - 1];
        }
    },
    purgeCachedData: function () {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear();
    },
    purgeDirector: function () {
        this.getScheduler().unscheduleAllCallbacks();
        if (cc.eventManager)
            cc.eventManager.setEnabled(false);
        if (this._runningScene) {
            this._runningScene.onExitTransitionDidStart();
            this._runningScene.onExit();
            this._runningScene.cleanup();
        }
        this._runningScene = null;
        this._nextScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug();
    },
    pushScene: function (scene) {
        cc.assert(scene, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = false;
        this._scenesStack.push(scene);
        this._nextScene = scene;
    },
    runScene: function (scene) {
        cc.assert(scene, cc._LogInfos.Director_pushScene);
        if (!this._runningScene) {
            this.pushScene(scene);
            this.startAnimation();
        } else {
            var i = this._scenesStack.length;
            if (i === 0) {
                this._sendCleanupToScene = true;
                this._scenesStack[i] = scene;
                this._nextScene = scene;
            } else {
                this._sendCleanupToScene = true;
                this._scenesStack[i - 1] = scene;
                this._nextScene = scene;
            }
        }
    },
    resume: function () {
        if (!this._paused) {
            return;
        }
        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = Date.now();
        if (!this._lastUpdate) {
            cc.log(cc._LogInfos.Director_resume);
        }
        this._paused = false;
        this._deltaTime = 0;
    },
    setContentScaleFactor: function (scaleFactor) {
        if (scaleFactor != this._contentScaleFactor) {
            this._contentScaleFactor = scaleFactor;
            this._createStatsLabel();
        }
    },
    setDepthTest: null,
    setDefaultValues: function () {
    },
    setNextDeltaTimeZero: function (nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
    },
    setNextScene: function () {
        var runningIsTransition = false, newIsTransition = false;
        if (cc.TransitionScene) {
            runningIsTransition = this._runningScene ? this._runningScene instanceof cc.TransitionScene : false;
            newIsTransition = this._nextScene ? this._nextScene instanceof cc.TransitionScene : false;
        }
        if (!newIsTransition) {
            var locRunningScene = this._runningScene;
            if (locRunningScene) {
                locRunningScene.onExitTransitionDidStart();
                locRunningScene.onExit();
            }
            if (this._sendCleanupToScene && locRunningScene)
                locRunningScene.cleanup();
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = true;
        this._nextScene = null;
        if ((!runningIsTransition) && (this._runningScene != null)) {
            this._runningScene.onEnter();
            this._runningScene.onEnterTransitionDidFinish();
        }
    },
    setNotificationNode: function (node) {
        this._notificationNode = node;
    },
    getDelegate: function () {
        return this._projectionDelegate;
    },
    setDelegate: function (delegate) {
        this._projectionDelegate = delegate;
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function () {
        this._frames++;
        this._accumDt += this._deltaTime;
        if (this._FPSLabel && this._SPFLabel && this._drawsLabel) {
            if (this._accumDt > cc.DIRECTOR_FPS_INTERVAL) {
                this._SPFLabel.string = this._secondsPerFrame.toFixed(3);
                this._frameRate = this._frames / this._accumDt;
                this._frames = 0;
                this._accumDt = 0;
                this._FPSLabel.string = this._frameRate.toFixed(1);
                this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString();
            }
            this._FPSLabel.visit();
            this._SPFLabel.visit();
            this._drawsLabel.visit();
        } else
            this._createStatsLabel();
        cc.g_NumberOfDraws = 0;
    },
    isSendCleanupToScene: function () {
        return this._sendCleanupToScene;
    },
    getRunningScene: function () {
        return this._runningScene;
    },
    getAnimationInterval: function () {
        return this._animationInterval;
    },
    isDisplayStats: function () {
        return this._displayStats;
    },
    setDisplayStats: function (displayStats) {
        this._displayStats = displayStats;
    },
    getSecondsPerFrame: function () {
        return this._secondsPerFrame;
    },
    isNextDeltaTimeZero: function () {
        return this._nextDeltaTimeZero;
    },
    isPaused: function () {
        return this._paused;
    },
    getTotalFrames: function () {
        return this._totalFrames;
    },
    popToRootScene: function () {
        this.popToSceneStackLevel(1);
    },
    popToSceneStackLevel: function (level) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var locScenesStack = this._scenesStack;
        var c = locScenesStack.length;
        if (c == 0) {
            this.end();
            return;
        }
        if (level > c)
            return;
        while (c > level) {
            var current = locScenesStack.pop();
            if (current.running) {
                current.onExitTransitionDidStart();
                current.onExit();
            }
            current.cleanup();
            c--;
        }
        this._nextScene = locScenesStack[locScenesStack.length - 1];
        this._sendCleanupToScene = false;
    },
    getScheduler: function () {
        return this._scheduler;
    },
    setScheduler: function (scheduler) {
        if (this._scheduler != scheduler) {
            this._scheduler = scheduler;
        }
    },
    getActionManager: function () {
        return this._actionManager;
    },
    setActionManager: function (actionManager) {
        if (this._actionManager != actionManager) {
            this._actionManager = actionManager;
        }
    },
    getDeltaTime: function () {
        return this._deltaTime;
    },
    _createStatsLabel: null,
    _calculateMPF: function () {
        var now = Date.now();
        this._secondsPerFrame = (now - this._lastUpdate) / 1000;
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: false,
    startAnimation: function () {
        this._nextDeltaTimeZero = true;
        this.invalid = false;
    },
    mainLoop: function () {
        if (this._purgeDirectorInNextLoop) {
            this._purgeDirectorInNextLoop = false;
            this.purgeDirector();
        }
        else if (!this.invalid) {
            this.drawScene();
        }
    },
    stopAnimation: function () {
        this.invalid = true;
    },
    setAnimationInterval: function (value) {
        this._animationInterval = value;
        if (!this.invalid) {
            this.stopAnimation();
            this.startAnimation();
        }
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = true;
cc.Director._getInstance = function () {
    if (cc.Director.firstUseDirector) {
        cc.Director.firstUseDirector = false;
        cc.Director.sharedDirector = new cc.DisplayLinkDirector();
        cc.Director.sharedDirector.init();
    }
    return cc.Director.sharedDirector;
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Director.prototype;
    _p.setProjection = function (projection) {
        this._projection = projection;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
    };
    _p.setDepthTest = function () {
    };
    _p.setOpenGLView = function (openGLView) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = openGLView || cc.view;
        if (cc.eventManager)
            cc.eventManager.setEnabled(true);
    };
    _p._clear = function () {
        var viewport = this._openGLView.getViewPortRect();
        cc._renderContext.clearRect(-viewport.x, viewport.y, viewport.width, -viewport.height);
    };
    _p._createStatsLabel = function () {
        var _t = this;
        var fontSize = 0;
        if (_t._winSizeInPoints.width > _t._winSizeInPoints.height)
            fontSize = 0 | (_t._winSizeInPoints.height / 320 * 24);
        else
            fontSize = 0 | (_t._winSizeInPoints.width / 320 * 24);
        _t._FPSLabel = new cc.LabelTTF("000.0", "Arial", fontSize);
        _t._SPFLabel = new cc.LabelTTF("0.000", "Arial", fontSize);
        _t._drawsLabel = new cc.LabelTTF("0000", "Arial", fontSize);
        var locStatsPosition = cc.DIRECTOR_STATS_POSITION;
        _t._drawsLabel.setPosition(_t._drawsLabel.width / 2 + locStatsPosition.x, _t._drawsLabel.height * 5 / 2 + locStatsPosition.y);
        _t._SPFLabel.setPosition(_t._SPFLabel.width / 2 + locStatsPosition.x, _t._SPFLabel.height * 3 / 2 + locStatsPosition.y);
        _t._FPSLabel.setPosition(_t._FPSLabel.width / 2 + locStatsPosition.x, _t._FPSLabel.height / 2 + locStatsPosition.y);
    };
    _p.getVisibleSize = function () {
        return this.getWinSize();
    };
    _p.getVisibleOrigin = function () {
        return cc.p(0, 0);
    };
} else {
    cc.Director._fpsImage = new Image();
    cc._addEventListener(cc.Director._fpsImage, "load", function () {
        cc.Director._fpsImageLoaded = true;
    });
    if (cc._fpsImage) {
        cc.Director._fpsImage.src = cc._fpsImage;
    }
    cc.assert(cc.isFunction(cc._tmp.DirectorWebGL), cc._LogInfos.MissingFile, "CCDirectorWebGL.js");
    cc._tmp.DirectorWebGL();
    delete cc._tmp.DirectorWebGL;
}
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function (prev, next, target, priority, paused, markedForDeletion) {
    this.prev = prev;
    this.next = next;
    this.target = target;
    this.priority = priority;
    this.paused = paused;
    this.markedForDeletion = markedForDeletion;
};
cc.HashUpdateEntry = function (list, entry, target, hh) {
    this.list = list;
    this.entry = entry;
    this.target = target;
    this.hh = hh;
};
cc.HashTimerEntry = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
    var _t = this;
    _t.timers = timers;
    _t.target = target;
    _t.timerIndex = timerIndex;
    _t.currentTimer = currentTimer;
    _t.currentTimerSalvaged = currentTimerSalvaged;
    _t.paused = paused;
    _t.hh = hh;
};
cc.Timer = cc.Class.extend({
    _interval:0.0,
    _callback:null,//is called _callback before
    _target:null,//target of _callback
    _elapsed:0.0,
    _runForever:false,
    _useDelay:false,
    _timesExecuted:0,
    _repeat:0,
    _delay:0,
    getInterval : function(){return this._interval;},
    setInterval : function(interval){this._interval = interval;},
    getCallback : function(){return this._callback},
    ctor:function (target, callback, interval, repeat, delay) {
        var self = this;
        self._target = target;
        self._callback = callback;
        self._elapsed = -1;
        self._interval = interval || 0;
        self._delay = delay || 0;
        self._useDelay = self._delay > 0;
        self._repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        self._runForever = (self._repeat == cc.REPEAT_FOREVER);
    },
    _doCallback:function(){
        var self = this;
        if (cc.isString(self._callback))
            self._target[self._callback](self._elapsed);
        else
            self._callback.call(self._target, self._elapsed);
    },
    update:function (dt) {
        var self = this;
        if (self._elapsed == -1) {
            self._elapsed = 0;
            self._timesExecuted = 0;
        } else {
            var locTarget = self._target, locCallback = self._callback;
            self._elapsed += dt;//standard timer usage
            if (self._runForever && !self._useDelay) {
                if (self._elapsed >= self._interval) {
                    if (locTarget && locCallback)
                        self._doCallback();
                    self._elapsed = 0;
                }
            } else {
                if (self._useDelay) {
                    if (self._elapsed >= self._delay) {
                        if (locTarget && locCallback)
                            self._doCallback();
                        self._elapsed = self._elapsed - self._delay;
                        self._timesExecuted += 1;
                        self._useDelay = false;
                    }
                } else {
                    if (self._elapsed >= self._interval) {
                        if (locTarget && locCallback)
                            self._doCallback();
                        self._elapsed = 0;
                        self._timesExecuted += 1;
                    }
                }
                if (self._timesExecuted > self._repeat)
                    cc.director.getScheduler().unscheduleCallbackForTarget(locTarget, locCallback);
            }
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale:1.0,
    _updates : null,
    _hashForUpdates:null,
    _arrayForUpdates:null,
    _hashForTimers:null,
    _arrayForTimes:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,
    _updateHashLocked:false,
    ctor:function () {
        var self = this;
        self._timeScale = 1.0;
        self._updates = [[], [], []];
        self._hashForUpdates = {};
        self._arrayForUpdates = [];
        self._hashForTimers = {};
        self._arrayForTimers = [];
        self._currentTarget = null;
        self._currentTargetSalvaged = false;
        self._updateHashLocked = false;
    },
    _removeHashElement:function (element) {
        delete this._hashForTimers[element.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, element);
        element.Timer = null;
        element.target = null;
        element = null;
    },
    _removeUpdateFromHash:function (entry) {
        var self = this, element = self._hashForUpdates[entry.target.__instanceId];
        if (element) {
            cc.arrayRemoveObject(element.list, element.entry);
            delete self._hashForUpdates[element.target.__instanceId];
            cc.arrayRemoveObject(self._arrayForUpdates, element);
            element.entry = null;
            element.target = null;
        }
    },
    _priorityIn:function (ppList, target, priority, paused) {
        var self = this, listElement = new cc.ListEntry(null, null, target, priority, paused, false);
        if (!ppList) {
            ppList = [];
            ppList.push(listElement);
        } else {
            var index2Insert = ppList.length - 1;
            for(var i = 0; i <= index2Insert; i++){
                if (priority < ppList[i].priority) {
                    index2Insert = i;
                    break;
                }
            }
            ppList.splice(i, 0, listElement);
        }
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        self._arrayForUpdates.push(hashElement);
        self._hashForUpdates[target.__instanceId] = hashElement;
        return ppList;
    },
    _appendIn:function (ppList, target, paused) {
        var self = this, listElement = new cc.ListEntry(null, null, target, 0, paused, false);
        ppList.push(listElement);
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        self._arrayForUpdates.push(hashElement);
        self._hashForUpdates[target.__instanceId] = hashElement;
    },
    setTimeScale:function (timeScale) {
        this._timeScale = timeScale;
    },
    getTimeScale:function () {
        return this._timeScale;
    },
    update:function (dt) {
        var self = this;
        var locUpdates = self._updates, locArrayForTimers = self._arrayForTimers;
        var tmpEntry, elt, i, li;
        self._updateHashLocked = true;
        if (this._timeScale != 1.0) {
            dt *= this._timeScale;
        }
        for(i = 0, li = locUpdates.length; i < li && i >= 0; i++){
            var update = self._updates[i];
            for(var j = 0, lj = update.length; j < lj; j++){
                tmpEntry = update[j];
                if ((!tmpEntry.paused) && (!tmpEntry.markedForDeletion)) tmpEntry.target.update(dt);
            }
        }
        for(i = 0, li = locArrayForTimers.length; i < li; i++){
            elt = locArrayForTimers[i];
            if(!elt) break;
            self._currentTarget = elt;
            self._currentTargetSalvaged = false;
            if (!elt.paused) {
                for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; elt.timerIndex++) {
                    elt.currentTimer = elt.timers[elt.timerIndex];
                    elt.currentTimerSalvaged = false;
                    elt.currentTimer.update(dt);
                    elt.currentTimer = null;
                }
            }
            if ((self._currentTargetSalvaged) && (elt.timers.length == 0)){
                self._removeHashElement(elt);
                i--;
            }
        }
        for(i = 0, li = locUpdates.length; i < li; i++){
            var update = self._updates[i];
            for(var j = 0, lj = update.length; j < lj; ){
                tmpEntry = update[j];
                if(!tmpEntry) break;
                if (tmpEntry.markedForDeletion) self._removeUpdateFromHash(tmpEntry);
                else j++;
            }
        }
        self._updateHashLocked = false;
        self._currentTarget = null;
    },
    scheduleCallbackForTarget:function (target, callback_fn, interval, repeat, delay, paused) {
        cc.assert(callback_fn, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
        cc.assert(target, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        interval = interval || 0;
        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        paused = paused || false;
        var self = this, timer;
        var element = self._hashForTimers[target.__instanceId];
        if (!element) {
            element = new cc.HashTimerEntry(null, target, 0, null, null, paused, null);
            self._arrayForTimers.push(element);
            self._hashForTimers[target.__instanceId] = element;
        }
        if (element.timers == null) {
            element.timers = [];
        } else {
            for (var i = 0; i < element.timers.length; i++) {
                timer = element.timers[i];
                if (callback_fn == timer._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, timer.getInterval().toFixed(4), interval.toFixed(4));
                    timer._interval = interval;
                    return;
                }
            }
        }
        timer = new cc.Timer(target, callback_fn, interval, repeat, delay);
        element.timers.push(timer);
    },
    scheduleUpdateForTarget:function (target, priority, paused) {
        if(target === null)
            return;
        var self = this, locUpdates = self._updates;
        var hashElement = self._hashForUpdates[target.__instanceId];
        if (hashElement) {
            hashElement.entry.markedForDeletion = false;
            return;
        }
        if (priority == 0) {
            self._appendIn(locUpdates[1], target, paused);
        } else if (priority < 0) {
            locUpdates[0] = self._priorityIn(locUpdates[0], target, priority, paused);
        } else {
            locUpdates[2] = self._priorityIn(locUpdates[2], target, priority, paused);
        }
    },
    unscheduleCallbackForTarget:function (target, callback_fn) {
        if ((target == null) || (callback_fn == null)) {
            return;
        }
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            var timers = element.timers;
            for(var i = 0, li = timers.length; i < li; i++){
                var timer = timers[i];
                if (callback_fn == timer._callback) {
                    if ((timer == element.currentTimer) && (!element.currentTimerSalvaged)) {
                        element.currentTimerSalvaged = true;
                    }
                    timers.splice(i, 1)
                    if (element.timerIndex >= i) {
                        element.timerIndex--;
                    }
                    if (timers.length == 0) {
                        if (self._currentTarget == element) {
                            self._currentTargetSalvaged = true;
                        } else {
                            self._removeHashElement(element);
                        }
                    }
                    return;
                }
            }
        }
    },
    unscheduleUpdateForTarget:function (target) {
        if (target == null) {
            return;
        }
        var self = this, element = self._hashForUpdates[target.__instanceId];
        if (element != null) {
            if (self._updateHashLocked) {
                element.entry.markedForDeletion = true;
            } else {
                self._removeUpdateFromHash(element.entry);
            }
        }
    },
    unscheduleAllCallbacksForTarget:function (target) {
        if (target == null) {
            return;
        }
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            var timers = element.timers;
            if ((!element.currentTimerSalvaged) && (timers.indexOf(element.currentTimer) >= 0)) {
                element.currentTimerSalvaged = true;
            }
            timers.length = 0;
            if (self._currentTarget == element) {
                self._currentTargetSalvaged = true;
            } else {
                self._removeHashElement(element);
            }
        }
        self.unscheduleUpdateForTarget(target);
    },
    unscheduleAllCallbacks:function () {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    unscheduleAllCallbacksWithMinPriority:function (minPriority) {
        var self = this, locArrayForTimers = self._arrayForTimers, locUpdates = self._updates;
        for(var i = 0, li = locArrayForTimers.length; i < li; i++){
            self.unscheduleAllCallbacksForTarget(locArrayForTimers[i].target);
        }
        for(var i = 2; i >= 0; i--){
            if((i == 1 && minPriority > 0) || (i == 0 && minPriority >= 0)) continue;
            var updates = locUpdates[i];
            for(var j = 0, lj = updates.length; j < lj; j++){
                self.unscheduleUpdateForTarget(updates[j].target);
            }
        }
    },
    pauseAllTargets:function () {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    pauseAllTargetsWithMinPriority:function (minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers, locUpdates = self._updates;
        for(var i = 0, li = locArrayForTimers.length; i < li; i++){
            element = locArrayForTimers[i];
            if (element) {
                element.paused = true;
                idsWithSelectors.push(element.target);
            }
        }
        for(var i = 0, li = locUpdates.length; i < li; i++){
            var updates = locUpdates[i];
            for(var j = 0, lj = updates.length; j < lj; j++){
                element = updates[j];
                if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                }
            }
        }
        return idsWithSelectors;
    },
    resumeTargets:function (targetsToResume) {
        if (!targetsToResume)
            return;
        for (var i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
        }
    },
    pauseTarget:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_pauseTarget);
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            element.paused = true;
        }
        var elementUpdate = self._hashForUpdates[target.__instanceId];
        if (elementUpdate) {
            elementUpdate.entry.paused = true;
        }
    },
    resumeTarget:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_resumeTarget);
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            element.paused = false;
        }
        var elementUpdate = self._hashForUpdates[target.__instanceId];
        if (elementUpdate) {
            elementUpdate.entry.paused = false;
        }
    },
    isTargetPaused:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_isTargetPaused);
        var element = this._hashForTimers[target.__instanceId];
        if (element) {
            return element.paused;
        }
        return false;
    }
});
cc.Scheduler.PRIORITY_SYSTEM = (-2147483647 - 1);
cc._tmp.PrototypeLabelTTF = function () {
    var _p = cc.LabelTTF.prototype;
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    _p.string;
    cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
    _p.textAlign;
    cc.defineGetterSetter(_p, "textAlign", _p.getHorizontalAlignment, _p.setHorizontalAlignment);
    _p.verticalAlign;
    cc.defineGetterSetter(_p, "verticalAlign", _p.getVerticalAlignment, _p.setVerticalAlignment);
    _p.fontSize;
    cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
    _p.fontName;
    cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
    _p.font;
    cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
    _p.boundingSize;
    _p.boundingWidth;
    cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
    _p.boundingHeight;
    cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
    _p.fillStyle;
    cc.defineGetterSetter(_p, "fillStyle", _p._getFillStyle, _p.setFontFillColor);
    _p.strokeStyle;
    cc.defineGetterSetter(_p, "strokeStyle", _p._getStrokeStyle, _p._setStrokeStyle);
    _p.lineWidth;
    cc.defineGetterSetter(_p, "lineWidth", _p._getLineWidth, _p._setLineWidth);
    _p.shadowOffset;
    _p.shadowOffsetX;
    cc.defineGetterSetter(_p, "shadowOffsetX", _p._getShadowOffsetX, _p._setShadowOffsetX);
    _p.shadowOffsetY;
    cc.defineGetterSetter(_p, "shadowOffsetY", _p._getShadowOffsetY, _p._setShadowOffsetY);
    _p.shadowOpacity;
    cc.defineGetterSetter(_p, "shadowOpacity", _p._getShadowOpacity, _p._setShadowOpacity);
    _p.shadowBlur;
    cc.defineGetterSetter(_p, "shadowBlur", _p._getShadowBlur, _p._setShadowBlur);
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0.0,
    _string: "",
    _originalText: null,
    _isMultiLine: false,
    _fontStyleStr: null,
    _shadowEnabled: false,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _shadowColor: null,
    _strokeEnabled: false,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: false,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    initWithString: function (label, fontName, fontSize, dimensions, hAlignment, vAlignment) {
        var strInfo;
        if (label)
            strInfo = label + "";
        else
            strInfo = "";
        fontSize = fontSize || 16;
        dimensions = dimensions || cc.size(0, 0);
        hAlignment = hAlignment || cc.TEXT_ALIGNMENT_LEFT;
        vAlignment = vAlignment || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = false;
        this._dimensions = cc.size(dimensions.width, dimensions.height);
        this._fontName = fontName || "Arial";
        this._hAlignment = hAlignment;
        this._vAlignment = vAlignment;
        this._fontSize = fontSize;
        this._fontStyleStr = this._fontSize + "px '" + fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(fontName, this._fontSize);
        this.string = strInfo;
        this._setColorsString();
        this._updateTexture();
        this._setUpdateTextureDirty();
        return true;
    },
    _setUpdateTextureDirty: function(){
        this._renderCmdDiry = this._needUpdateTexture = true;
        cc.renderer.pushDirtyNode(this);
    },
    ctor: function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = false;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._isMultiLine = false;
        this._shadowEnabled = false;
        this._shadowOffset = cc.p(0, 0);
        this._shadowOpacity = 0;
        this._shadowBlur = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = false;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetX = 0;
        this._strokeShadowOffsetY = 0;
        this._needUpdateTexture = false;
        this._lineWidths = [];
        this._setColorsString();
        if (fontName && fontName instanceof cc.FontDefinition) {
            this.initWithStringAndTextDefinition(text, fontName);
        } else {
            cc.LabelTTF.prototype.initWithString.call(this, text, fontName, fontSize, dimensions, hAlignment, vAlignment);
        }
    },
    init: function () {
        return this.initWithString(" ", this._fontName, this._fontSize);
    },
    _measureConfig: function () {
        this._getLabelContext().font = this._fontStyleStr;
    },
    _measure: function (text) {
        return this._getLabelContext().measureText(text).width;
    },
    description: function () {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">";
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function (parentOpacity) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._setColorsString();
    },
    getString: function () {
        return this._string;
    },
    getHorizontalAlignment: function () {
        return this._hAlignment;
    },
    getVerticalAlignment: function () {
        return this._vAlignment;
    },
    getDimensions: function () {
        return cc.size(this._dimensions);
    },
    getFontSize: function () {
        return this._fontSize;
    },
    getFontName: function () {
        return this._fontName;
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function (theDefinition) {
        if (theDefinition)
            this._updateWithTextDefinition(theDefinition, true);
    },
    getTextDefinition: function () {
        return this._prepareTextDefinition(false);
    },
    enableShadow: function (a, b, c, d) {
        if(a.r != null && a.g != null && a.b != null && a.a != null){
            this._enableShadow(a, b, c);
        }else{
            this._enableShadowNoneColor(a, b, c, d)
        }
    },
    _enableShadowNoneColor: function(shadowOffsetX, shadowOffsetY, shadowOpacity, shadowBlur){
        shadowOpacity = shadowOpacity || 0.5;
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        var locShadowOffset = this._shadowOffset;
        if (locShadowOffset && (locShadowOffset.x != shadowOffsetX) || (locShadowOffset._y != shadowOffsetY)) {
            locShadowOffset.x = shadowOffsetX;
            locShadowOffset.y = shadowOffsetY;
        }
        if (this._shadowOpacity != shadowOpacity) {
            this._shadowOpacity = shadowOpacity;
        }
        this._setColorsString();
        if (this._shadowBlur != shadowBlur)
            this._shadowBlur = shadowBlur;
        this._setUpdateTextureDirty();
    },
    _enableShadow: function(shadowColor, offset, blurRadius){
        if(!this._shadowColor){
            this._shadowColor = cc.color(255, 255, 255, 128);
        }
        this._shadowColor.r = shadowColor.r;
        this._shadowColor.g = shadowColor.g;
        this._shadowColor.b = shadowColor.b;
        var x, y, a, b;
        x = offset.width || offset.x || 0;
        y = offset.height || offset.y || 0;
        a = (shadowColor.a != null) ? (shadowColor.a / 255) : 0.5;
        b = blurRadius;
        this._enableShadowNoneColor(x, y, a, b);
    },
    _getShadowOffsetX: function () {
        return this._shadowOffset.x;
    },
    _setShadowOffsetX: function (x) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset.x != x) {
            this._shadowOffset.x = x;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOffsetY: function () {
        return this._shadowOffset._y;
    },
    _setShadowOffsetY: function (y) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset._y != y) {
            this._shadowOffset._y = y;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOffset: function () {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y);
    },
    _setShadowOffset: function (offset) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset.x != offset.x || this._shadowOffset.y != offset.y) {
            this._shadowOffset.x = offset.x;
            this._shadowOffset.y = offset.y;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOpacity: function () {
        return this._shadowOpacity;
    },
    _setShadowOpacity: function (shadowOpacity) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOpacity != shadowOpacity) {
            this._shadowOpacity = shadowOpacity;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    },
    _getShadowBlur: function () {
        return this._shadowBlur;
    },
    _setShadowBlur: function (shadowBlur) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowBlur != shadowBlur) {
            this._shadowBlur = shadowBlur;
            this._setUpdateTextureDirty();
        }
    },
    disableShadow: function () {
        if (this._shadowEnabled) {
            this._shadowEnabled = false;
            this._setUpdateTextureDirty();
        }
    },
    enableStroke: function (strokeColor, strokeSize) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        var locStrokeColor = this._strokeColor;
        if ((locStrokeColor.r !== strokeColor.r) || (locStrokeColor.g !== strokeColor.g) || (locStrokeColor.b !== strokeColor.b)) {
            locStrokeColor.r = strokeColor.r;
            locStrokeColor.g = strokeColor.g;
            locStrokeColor.b = strokeColor.b;
            this._setColorsString();
        }
        if (this._strokeSize !== strokeSize)
            this._strokeSize = strokeSize || 0;
        this._setUpdateTextureDirty();
    },
    _getStrokeStyle: function () {
        return this._strokeColor;
    },
    _setStrokeStyle: function (strokeStyle) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        var locStrokeColor = this._strokeColor;
        if ((locStrokeColor.r !== strokeStyle.r) || (locStrokeColor.g !== strokeStyle.g) || (locStrokeColor.b !== strokeStyle.b)) {
            locStrokeColor.r = strokeStyle.r;
            locStrokeColor.g = strokeStyle.g;
            locStrokeColor.b = strokeStyle.b;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    },
    _getLineWidth: function () {
        return this._strokeSize;
    },
    _setLineWidth: function (lineWidth) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        if (this._strokeSize !== lineWidth) {
            this._strokeSize = lineWidth || 0;
            this._setUpdateTextureDirty();
        }
    },
    disableStroke: function () {
        if (this._strokeEnabled) {
            this._strokeEnabled = false;
            this._setUpdateTextureDirty();
        }
    },
    setFontFillColor: null,
    _getFillStyle: function () {
        return this._textFillColor;
    },
    _updateWithTextDefinition: function (textDefinition, mustUpdateTexture) {
        if (textDefinition.fontDimensions) {
            this._dimensions.width = textDefinition.boundingWidth;
            this._dimensions.height = textDefinition.boundingHeight;
        } else {
            this._dimensions.width = 0;
            this._dimensions.height = 0;
        }
        this._hAlignment = textDefinition.textAlign;
        this._vAlignment = textDefinition.verticalAlign;
        this._fontName = textDefinition.fontName;
        this._fontSize = textDefinition.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        if (textDefinition.shadowEnabled)
            this.enableShadow(textDefinition.shadowOffsetX,
                textDefinition.shadowOffsetY,
                textDefinition.shadowOpacity,
                textDefinition.shadowBlur);
        if (textDefinition.strokeEnabled)
            this.enableStroke(textDefinition.strokeStyle, textDefinition.lineWidth);
        this.setFontFillColor(textDefinition.fillStyle);
        if (mustUpdateTexture)
            this._updateTexture();
    },
    _prepareTextDefinition: function (adjustForResolution) {
        var texDef = new cc.FontDefinition();
        if (adjustForResolution) {
            texDef.fontSize = this._fontSize;
            texDef.boundingWidth = cc.contentScaleFactor() * this._dimensions.width;
            texDef.boundingHeight = cc.contentScaleFactor() * this._dimensions.height;
        } else {
            texDef.fontSize = this._fontSize;
            texDef.boundingWidth = this._dimensions.width;
            texDef.boundingHeight = this._dimensions.height;
        }
        texDef.fontName = this._fontName;
        texDef.textAlign = this._hAlignment;
        texDef.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            texDef.strokeEnabled = true;
            var locStrokeColor = this._strokeColor;
            texDef.strokeStyle = cc.color(locStrokeColor.r, locStrokeColor.g, locStrokeColor.b);
            texDef.lineWidth = this._strokeSize;
        } else
            texDef.strokeEnabled = false;
        if (this._shadowEnabled) {
            texDef.shadowEnabled = true;
            texDef.shadowBlur = this._shadowBlur;
            texDef.shadowOpacity = this._shadowOpacity;
            texDef.shadowOffsetX = (adjustForResolution ? cc.contentScaleFactor() : 1) * this._shadowOffset.x;
            texDef.shadowOffsetY = (adjustForResolution ? cc.contentScaleFactor() : 1) * this._shadowOffset.y;
        } else
            texDef._shadowEnabled = false;
        var locTextFillColor = this._textFillColor;
        texDef.fillStyle = cc.color(locTextFillColor.r, locTextFillColor.g, locTextFillColor.b);
        return texDef;
    },
    _fontClientHeight: 18,
    setString: function (text) {
        text = String(text);
        if (this._originalText != text) {
            this._originalText = text + "";
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _updateString: function () {
        this._string = this._originalText;
    },
    setHorizontalAlignment: function (alignment) {
        if (alignment !== this._hAlignment) {
            this._hAlignment = alignment;
            this._setUpdateTextureDirty();
        }
    },
    setVerticalAlignment: function (verticalAlignment) {
        if (verticalAlignment != this._vAlignment) {
            this._vAlignment = verticalAlignment;
            this._setUpdateTextureDirty();
        }
    },
    setDimensions: function (dim, height) {
        var width;
        if(height === undefined){
            width = dim.width;
            height = dim.height;
        }else
            width = dim;
        if (width != this._dimensions.width || height != this._dimensions.height) {
            this._dimensions.width = width;
            this._dimensions.height = height;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _getBoundingWidth: function () {
        return this._dimensions.width;
    },
    _setBoundingWidth: function (width) {
        if (width != this._dimensions.width) {
            this._dimensions.width = width;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _getBoundingHeight: function () {
        return this._dimensions.height;
    },
    _setBoundingHeight: function (height) {
        if (height != this._dimensions.height) {
            this._dimensions.height = height;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    setFontSize: function (fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this._fontStyleStr = fontSize + "px '" + this._fontName + "'";
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, fontSize);
            this._setUpdateTextureDirty();
        }
    },
    setFontName: function (fontName) {
        if (this._fontName && this._fontName != fontName) {
            this._fontName = fontName;
            this._fontStyleStr = this._fontSize + "px '" + fontName + "'";
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(fontName, this._fontSize);
            this._setUpdateTextureDirty();
        }
    },
    _getFont: function () {
        return this._fontStyleStr;
    },
    _setFont: function (fontStyle) {
        var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
        if (res) {
            this._fontSize = parseInt(res[1]);
            this._fontName = res[2];
            this._fontStyleStr = fontStyle;
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
            this._setUpdateTextureDirty();
        }
    },
    _drawTTFInCanvas: function (context) {
        if (!context)
            return;
        var locStrokeShadowOffsetX = this._strokeShadowOffsetX, locStrokeShadowOffsetY = this._strokeShadowOffsetY;
        var locContentSizeHeight = this._contentSize.height - locStrokeShadowOffsetY, locVAlignment = this._vAlignment, locHAlignment = this._hAlignment,
            locFontHeight = this._fontClientHeight, locStrokeSize = this._strokeSize;
        context.setTransform(1, 0, 0, 1, 0 + locStrokeShadowOffsetX * 0.5, locContentSizeHeight + locStrokeShadowOffsetY * 0.5);
        if (context.font != this._fontStyleStr)
            context.font = this._fontStyleStr;
        context.fillStyle = this._fillColorStr;
        var xOffset = 0, yOffset = 0;
        var locStrokeEnabled = this._strokeEnabled;
        if (locStrokeEnabled) {
            context.lineWidth = locStrokeSize * 2;
            context.strokeStyle = this._strokeColorStr;
        }
        if (this._shadowEnabled) {
            var locShadowOffset = this._shadowOffset;
            context.shadowColor = this._shadowColorStr;
            context.shadowOffsetX = locShadowOffset.x;
            context.shadowOffsetY = -locShadowOffset.y;
            context.shadowBlur = this._shadowBlur;
        }
        context.textBaseline = cc.LabelTTF._textBaseline[locVAlignment];
        context.textAlign = cc.LabelTTF._textAlign[locHAlignment];
        var locContentWidth = this._contentSize.width - locStrokeShadowOffsetX;
        if (locHAlignment === cc.TEXT_ALIGNMENT_RIGHT)
            xOffset += locContentWidth;
        else if (locHAlignment === cc.TEXT_ALIGNMENT_CENTER)
            xOffset += locContentWidth / 2;
        else
            xOffset += 0;
        if (this._isMultiLine) {
            var locStrLen = this._strings.length;
            if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM)
                yOffset = locFontHeight + locContentSizeHeight - locFontHeight * locStrLen;
            else if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER)
                yOffset = locFontHeight / 2 + (locContentSizeHeight - locFontHeight * locStrLen) / 2;
            for (var i = 0; i < locStrLen; i++) {
                var line = this._strings[i];
                var tmpOffsetY = -locContentSizeHeight + (locFontHeight * i) + yOffset;
                if (locStrokeEnabled)
                    context.strokeText(line, xOffset, tmpOffsetY);
                context.fillText(line, xOffset, tmpOffsetY);
            }
        } else {
            if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            } else if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_TOP) {
                yOffset -= locContentSizeHeight;
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            } else {
                yOffset -= locContentSizeHeight * 0.5;
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            }
        }
    },
    _getLabelContext: function () {
        if (this._labelContext)
            return this._labelContext;
        if (!this._labelCanvas) {
            var locCanvas = cc.newElement("canvas");
            var labelTexture = new cc.Texture2D();
            labelTexture.initWithElement(locCanvas);
            this.texture = labelTexture;
            this._labelCanvas = locCanvas;
        }
        this._labelContext = this._labelCanvas.getContext("2d");
        return this._labelContext;
    },
    _checkWarp: function(strArr, i, maxWidth){
        var text = strArr[i];
        var allWidth = this._measure(text);
        if(allWidth > maxWidth && text.length > 1){
            var fuzzyLen = text.length * ( maxWidth / allWidth ) | 0;
            var tmpText = text.substr(fuzzyLen);
            var width = allWidth - this._measure(tmpText);
            var sLine;
            var pushNum = 0;
            var checkWhile = 0;
            while(width > maxWidth && checkWhile++ < 100){
                fuzzyLen *= maxWidth / width;
                fuzzyLen = fuzzyLen | 0;
                tmpText = text.substr(fuzzyLen);
                width = allWidth - this._measure(tmpText);
            }
            checkWhile = 0;
            while(width < maxWidth && checkWhile++ < 100){
                if(tmpText){
                    var exec = cc.LabelTTF._wordRex.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1;
                    sLine = tmpText;
                }
                fuzzyLen = fuzzyLen + pushNum;
                tmpText = text.substr(fuzzyLen);
                width = allWidth - this._measure(tmpText);
            }
            fuzzyLen -= pushNum;
            var sText = text.substr(0, fuzzyLen);
            if(cc.LabelTTF.wrapInspection){
                if(cc.LabelTTF._symbolRex.test(sLine || tmpText)){
                    var result = cc.LabelTTF._lastWordRex.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;
                    sLine = text.substr(fuzzyLen);
                    sText = text.substr(0, fuzzyLen);
                }
            }
            if(cc.LabelTTF._firsrEnglish.test(sLine)){
                var result = cc.LabelTTF._lastEnglish.exec(sText);
                if(result && sText !== result[0]){
                    fuzzyLen -= result[0].length;
                    sLine = text.substr(fuzzyLen);
                    sText = text.substr(0, fuzzyLen);
                }
            }
            strArr[i] = sLine || tmpText;
            strArr.splice(i, 0, sText);
        }
    },
    _updateTTF: function () {
        var locDimensionsWidth = this._dimensions.width, i, strLength;
        var locLineWidth = this._lineWidths;
        locLineWidth.length = 0;
        this._isMultiLine = false;
        this._measureConfig();
        if (locDimensionsWidth !== 0) {
            this._strings = this._string.split('\n');
            for(i = 0; i < this._strings.length; i++){
                this._checkWarp(this._strings, i, locDimensionsWidth);
            }
        } else {
            this._strings = this._string.split('\n');
            for (i = 0, strLength = this._strings.length; i < strLength; i++) {
                locLineWidth.push(this._measure(this._strings[i]));
            }
        }
        if (this._strings.length > 0)
            this._isMultiLine = true;
        var locSize, locStrokeShadowOffsetX = 0, locStrokeShadowOffsetY = 0;
        if (this._strokeEnabled)
            locStrokeShadowOffsetX = locStrokeShadowOffsetY = this._strokeSize * 2;
        if (this._shadowEnabled) {
            var locOffsetSize = this._shadowOffset;
            locStrokeShadowOffsetX += Math.abs(locOffsetSize.x) * 2;
            locStrokeShadowOffsetY += Math.abs(locOffsetSize.y) * 2;
        }
        if (locDimensionsWidth === 0) {
            if (this._isMultiLine)
                locSize = cc.size(0 | (Math.max.apply(Math, locLineWidth) + locStrokeShadowOffsetX),
                    0 | ((this._fontClientHeight * this._strings.length) + locStrokeShadowOffsetY));
            else
                locSize = cc.size(0 | (this._measure(this._string) + locStrokeShadowOffsetX), 0 | (this._fontClientHeight + locStrokeShadowOffsetY));
        } else {
            if (this._dimensions.height === 0) {
                if (this._isMultiLine)
                    locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | ((this._fontClientHeight * this._strings.length) + locStrokeShadowOffsetY));
                else
                    locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | (this._fontClientHeight + locStrokeShadowOffsetY));
            } else {
                locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | (this._dimensions.height + locStrokeShadowOffsetY));
            }
        }
        this.setContentSize(locSize);
        this._strokeShadowOffsetX = locStrokeShadowOffsetX;
        this._strokeShadowOffsetY = locStrokeShadowOffsetY;
        var locAP = this._anchorPoint;
        this._anchorPointInPoints.x = (locStrokeShadowOffsetX * 0.5) + ((locSize.width - locStrokeShadowOffsetX) * locAP.x);
        this._anchorPointInPoints.y = (locStrokeShadowOffsetY * 0.5) + ((locSize.height - locStrokeShadowOffsetY) * locAP.y);
    },
    getContentSize: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this);
    },
    _getWidth: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this);
    },
    _getHeight: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this);
    },
    _updateTexture: function () {
        var locContext = this._getLabelContext(), locLabelCanvas = this._labelCanvas;
        var locContentSize = this._contentSize;
        if (this._string.length === 0) {
            locLabelCanvas.width = 1;
            locLabelCanvas.height = locContentSize.height || 1;
            this._texture && this._texture.handleLoadedTexture();
            this.setTextureRect(cc.rect(0, 0, 1, locContentSize.height));
            return true;
        }
        locContext.font = this._fontStyleStr;
        this._updateTTF();
        var width = locContentSize.width, height = locContentSize.height;
        var flag = locLabelCanvas.width == width && locLabelCanvas.height == height;
        locLabelCanvas.width = width;
        locLabelCanvas.height = height;
        if (flag) locContext.clearRect(0, 0, width, height);
        this._drawTTFInCanvas(locContext);
        this._texture && this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, width, height));
        return true;
    },
    visit: function (ctx) {
        if (!this._string || this._string == "")
            return;
        if (this._needUpdateTexture) {
            this._needUpdateTexture = false;
            this._updateTexture();
        }
        var context = ctx || cc._renderContext;
        cc.Sprite.prototype.visit.call(this, context);
    },
    draw: null,
    _setTextureCoords: function (rect) {
        var tex = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!tex)
            return;
        var atlasWidth = tex.pixelsWidth;
        var atlasHeight = tex.pixelsHeight;
        var left, right, top, bottom, tempSwap, locQuad = this._quad;
        if (this._rectRotated) {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.height * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.width * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.height) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.width) / atlasHeight;
            }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
            if (this._flippedX) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = top;
            locQuad.br.texCoords.u = left;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = right;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = bottom;
        } else {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.width * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.height * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.width) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.height) / atlasHeight;
            }
            if (this._flippedX) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = bottom;
            locQuad.br.texCoords.u = right;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = left;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = top;
        }
        this._quadDirty = true;
    }
});
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LabelTTF.prototype;
    _p.setColor = function (color3) {
        cc.Node.prototype.setColor.call(this, color3);
        this._setColorsString();
    };
    _p._transformForRenderer = function(){
        if (this._needUpdateTexture) {
            this._needUpdateTexture = false;
            this._updateTexture();
        }
        cc.Node.prototype._transformForRenderer.call(this);
    };
    _p._setColorsString = function () {
        this._setUpdateTextureDirty();
        var locDisplayColor = this._displayedColor,
            locDisplayedOpacity = this._displayedOpacity,
            locShadowColor = this._shadowColor || this._displayedColor;
        var locStrokeColor = this._strokeColor, locFontFillColor = this._textFillColor;
        this._shadowColorStr = "rgba(" + (0 | (locShadowColor.r * 0.5)) + "," + (0 | (locShadowColor.g * 0.5)) + "," + (0 | (locShadowColor.b * 0.5)) + "," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | (locDisplayColor.r / 255 * locFontFillColor.r)) + "," + (0 | (locDisplayColor.g / 255 * locFontFillColor.g)) + ","
            + (0 | (locDisplayColor.b / 255 * locFontFillColor.b)) + ", " + locDisplayedOpacity / 255 + ")";
        this._strokeColorStr = "rgba(" + (0 | (locDisplayColor.r / 255 * locStrokeColor.r)) + "," + (0 | (locDisplayColor.g / 255 * locStrokeColor.g)) + ","
            + (0 | (locDisplayColor.b / 255 * locStrokeColor.b)) + ", " + locDisplayedOpacity / 255 + ")";
    };
    _p.updateDisplayedColor = function (parentColor) {
        cc.Node.prototype.updateDisplayedColor.call(this, parentColor);
        this._setColorsString();
    };
    _p.setOpacity = function (opacity) {
        if (this._opacity === opacity)
            return;
        cc.Sprite.prototype.setOpacity.call(this, opacity);
        this._setColorsString();
        this._setUpdateTextureDirty();
    };
    _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity;
    _p.initWithStringAndTextDefinition = function (text, textDefinition) {
        this._updateWithTextDefinition(textDefinition, false);
        this.string = text;
        return true;
    };
    _p.setFontFillColor = function (tintColor) {
        var locTextFillColor = this._textFillColor;
        if (locTextFillColor.r != tintColor.r || locTextFillColor.g != tintColor.g || locTextFillColor.b != tintColor.b) {
            locTextFillColor.r = tintColor.r;
            locTextFillColor.g = tintColor.g;
            locTextFillColor.b = tintColor.b;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    };
    _p.draw = cc.Sprite.prototype.draw;
    _p.setTextureRect = function (rect, rotated, untrimmedSize) {
        this._rectRotated = rotated || false;
        untrimmedSize = untrimmedSize || rect;
        this.setContentSize(untrimmedSize);
        this.setVertexRect(rect);
        var locTextureCoordRect = this._rendererCmd._textureCoord;
        locTextureCoordRect.x = rect.x;
        locTextureCoordRect.y = rect.y;
        locTextureCoordRect.renderX = rect.x;
        locTextureCoordRect.renderY = rect.y;
        locTextureCoordRect.width = rect.width;
        locTextureCoordRect.height = rect.height;
        locTextureCoordRect.validRect = !(locTextureCoordRect.width === 0 || locTextureCoordRect.height === 0
            || locTextureCoordRect.x < 0 || locTextureCoordRect.y < 0);
        var relativeOffset = this._unflippedOffsetPositionFromCenter;
        if (this._flippedX)
            relativeOffset.x = -relativeOffset.x;
        if (this._flippedY)
            relativeOffset.y = -relativeOffset.y;
        this._offsetPosition.x = relativeOffset.x + (this._contentSize.width - this._rect.width) / 2;
        this._offsetPosition.y = relativeOffset.y + (this._contentSize.height - this._rect.height) / 2;
        if (this._batchNode) {
            this.dirty = true;
        }
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLabelTTF), cc._LogInfos.MissingFile, "LabelTTFWebGL.js");
    cc._tmp.WebGLLabelTTF();
    delete cc._tmp.WebGLLabelTTF;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = true;
cc.LabelTTF._wordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
    return new cc.LabelTTF(text, fontName, fontSize, dimensions, hAlignment, vAlignment);
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
if (cc.USE_LA88_LABELS)
    cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTURECOLOR;
else
    cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ?
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv) :
    cc._addEventListener(window, 'load', function () {
        this.removeEventListener('load', arguments.callee, false);
        document.body.appendChild(cc.LabelTTF.__labelHeightDiv);
    }, false);
cc.LabelTTF.__getFontHeightByDiv = function (fontName, fontSize) {
    var clientHeight = cc.LabelTTF.__fontHeightCache[fontName + "." + fontSize];
    if (clientHeight > 0) return clientHeight;
    var labelDiv = cc.LabelTTF.__labelHeightDiv;
    labelDiv.innerHTML = "ajghl~!";
    labelDiv.style.fontFamily = fontName;
    labelDiv.style.fontSize = fontSize + "px";
    clientHeight = labelDiv.clientHeight;
    cc.LabelTTF.__fontHeightCache[fontName + "." + fontSize] = clientHeight;
    labelDiv.innerHTML = "";
    return clientHeight;
};
cc.LabelTTF.__fontHeightCache = {};
var cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function (jsObj, superclass) {
};
cc.KEY = {
    backspace:8,
    tab:9,
    enter:13,
    shift:16,
    ctrl:17,
    alt:18,
    pause:19,
    capslock:20,
    escape:27,
    pageup:33,
    pagedown:34,
    end:35,
    home:36,
    left:37,
    up:38,
    right:39,
    down:40,
    insert:45,
    Delete:46,
    0:48,
    1:49,
    2:50,
    3:51,
    4:52,
    5:53,
    6:54,
    7:55,
    8:56,
    9:57,
    a:65,
    b:66,
    c:67,
    d:68,
    e:69,
    f:70,
    g:71,
    h:72,
    i:73,
    j:74,
    k:75,
    l:76,
    m:77,
    n:78,
    o:79,
    p:80,
    q:81,
    r:82,
    s:83,
    t:84,
    u:85,
    v:86,
    w:87,
    x:88,
    y:89,
    z:90,
    num0:96,
    num1:97,
    num2:98,
    num3:99,
    num4:100,
    num5:101,
    num6:102,
    num7:103,
    num8:104,
    num9:105,
    '*':106,
    '+':107,
    '-':109,
    'numdel':110,
    '/':111,
    f1:112,
    f2:113,
    f3:114,
    f4:115,
    f5:116,
    f6:117,
    f7:118,
    f8:119,
    f9:120,
    f10:121,
    f11:122,
    f12:123,
    numlock:144,
    scrolllock:145,
    semicolon:186,
    ',':186,
    equal:187,
    '=':187,
    ';':188,
    comma:188,
    dash:189,
    '.':190,
    period:190,
    forwardslash:191,
    grave:192,
    '[':219,
    openbracket:219,
    ']':221,
    closebracket:221,
    backslash:220,
    quote:222,
    space:32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function (imgData) {
    if (imgData.length > 8 && imgData[0] == 0x89
        && imgData[1] == 0x50
        && imgData[2] == 0x4E
        && imgData[3] == 0x47
        && imgData[4] == 0x0D
        && imgData[5] == 0x0A
        && imgData[6] == 0x1A
        && imgData[7] == 0x0A) {
        return cc.FMT_PNG;
    }
    if (imgData.length > 2 && ((imgData[0] == 0x49 && imgData[1] == 0x49)
        || (imgData[0] == 0x4d && imgData[1] == 0x4d)
        || (imgData[0] == 0xff && imgData[1] == 0xd8))) {
        return cc.FMT_TIFF;
    }
	return cc.FMT_UNKNOWN;
};
cc.inherits = function (childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
};
cc.base = function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
        ret = caller.superClass_.constructor.apply( me, Array.prototype.slice.call(arguments, 1));
        return ret;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
        if (ctor.prototype[opt_methodName] === caller) {
            foundCaller = true;
        } else if (foundCaller) {
            return ctor.prototype[opt_methodName].apply(me, args);
        }
    }
    if (me[opt_methodName] === caller) {
        return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
        throw Error(
            'cc.base called from a method of one name ' +
                'to a method of a different name');
    }
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    cc.rendererCanvas = {
        childrenOrderDirty: true,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToCanvasOn: false,
        _cacheToCanvasCmds: {},
        _cacheInstanceIds:[],
        _currentID: 0,
        rendering: function (ctx) {
            var locCmds = this._renderCmds,
                i,
                len,
                scaleX = cc.view.getScaleX(),
                scaleY = cc.view.getScaleY();
            var context = ctx || cc._renderContext;
            for (i = 0, len = locCmds.length; i < len; i++) {
                locCmds[i].rendering(context, scaleX, scaleY);
            }
        },
        _renderingToCacheCanvas: function (ctx, instanceID) {
            if (!ctx)
                cc.log("The context of RenderTexture is invalid.");
            instanceID = instanceID || this._currentID;
            var locCmds = this._cacheToCanvasCmds[instanceID], i, len;
            for (i = 0, len = locCmds.length; i < len; i++) {
                locCmds[i].rendering(ctx, 1, 1);
            }
            locCmds.length = 0;
            var locIDs = this._cacheInstanceIds;
            delete this._cacheToCanvasCmds[instanceID];
            cc.arrayRemoveObject(locIDs, instanceID);
            if (locIDs.length === 0)
                this._isCacheToCanvasOn = false;
            else
                this._currentID = locIDs[locIDs.length - 1];
        },
        _turnToCacheMode: function(renderTextureID){
            this._isCacheToCanvasOn = true;
            renderTextureID = renderTextureID || 0;
            this._cacheToCanvasCmds[renderTextureID] = [];
            this._cacheInstanceIds.push(renderTextureID);
            this._currentID = renderTextureID;
        },
        _turnToNormalMode: function(){
            this._isCacheToCanvasOn = false;
        },
        resetFlag: function () {
            this.childrenOrderDirty = false;
            this._transformNodePool.length = 0;
        },
        transform: function () {
            var locPool = this._transformNodePool;
            locPool.sort(this._sortNodeByLevelAsc);
            for (var i = 0, len = locPool.length; i < len; i++) {
                if (locPool[i]._renderCmdDiry)
                    locPool[i]._transformForRenderer();
            }
            locPool.length = 0;
        },
        transformDirty: function () {
            return this._transformNodePool.length > 0;
        },
        _sortNodeByLevelAsc: function (n1, n2) {
            return n1._curLevel - n2._curLevel;
        },
        pushDirtyNode: function (node) {
            this._transformNodePool.push(node);
        },
        clearRenderCommands: function () {
            this._renderCmds.length = 0;
        },
        pushRenderCommand: function (cmd) {
            if (this._isCacheToCanvasOn) {
                var currentId = this._currentID, locCmdBuffer = this._cacheToCanvasCmds;
                var cmdList = locCmdBuffer[currentId];
                if (cmdList.indexOf(cmd) === -1)
                    cmdList.push(cmd);
            } else {
                if (this._renderCmds.indexOf(cmd) === -1)
                    this._renderCmds.push(cmd);
            }
        }
    };
    cc.renderer = cc.rendererCanvas;
    cc.TextureRenderCmdCanvas = function (node) {
        this._node = node;
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: false
        };
    };
    cc.TextureRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var self = this,
            node = self._node;
        var context = ctx || cc._renderContext,
            locTextureCoord = self._textureCoord;
        if(node._texture && (locTextureCoord.width === 0 || locTextureCoord.height === 0))
            return;
        if (!locTextureCoord.validRect && node._displayedOpacity === 0)
            return;
        if(node._texture && !node._texture._isLoaded)
            return;
        var t = node._transformWorld,
            locX = node._offsetPosition.x,
            locY = -node._offsetPosition.y - node._rect.height,
            locWidth = node._rect.width,
            locHeight = node._rect.height,
            image, curColor, contentSize;
        var blendChange = (node._blendFuncStr !== "source"), alpha = (node._displayedOpacity / 255);
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1 || node._flippedX || node._flippedY) {
            context.save();
            context.globalAlpha = alpha;
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            if (blendChange)
                context.globalCompositeOperation = node._blendFuncStr;
            if (node._flippedX){
                locX = -locX - locWidth;
                context.scale(-1, 1);
            }
            if (node._flippedY){
                locY = node._offsetPosition.y;
                context.scale(1, -1);
            }
            if (node._texture) {
                image = node._texture._htmlElementObj;
                if (node._colorized) {
                    context.drawImage(image,
                        0,
                        0,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            locX * scaleX,
                            locY * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY
                    );
                } else {
                    context.drawImage(image,
                        locTextureCoord.renderX,
                        locTextureCoord.renderY,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            locX * scaleX,
                            locY * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY
                    );
                }
            } else {
                contentSize = node._contentSize;
                if(locTextureCoord.validRect) {
                    curColor = node._displayedColor;
                    context.fillStyle = "rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)";
                    context.fillRect(locX * scaleX, locY * scaleY, contentSize.width * scaleX, contentSize.height * scaleY);
                }
            }
            context.restore();
        } else {
            if (blendChange) {
                context.save();
                context.globalCompositeOperation = node._blendFuncStr;
            }
            context.globalAlpha = alpha;
            if (node._texture) {
                image = node._texture.getHtmlElementObj();
                if (node._colorized) {
                    context.drawImage(image,
                        0,
                        0,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            (t.tx + locX) * scaleX,
                            (-t.ty + locY) * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY);
                } else {
                    context.drawImage(
                        image,
                        locTextureCoord.renderX,
                        locTextureCoord.renderY,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            (t.tx + locX) * scaleX,
                            (-t.ty + locY) * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY);
                }
            } else {
                contentSize = node._contentSize;
                if(locTextureCoord.validRect) {
                    curColor = node._displayedColor;
                    context.fillStyle = "rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)";
                    context.fillRect((t.tx + locX) * scaleX, (-t.ty + locY) * scaleY, contentSize.width * scaleX, contentSize.height * scaleY);
                }
            }
            if (blendChange)
                context.restore();
        }
        cc.g_NumberOfDraws++;
    };
    cc.RectRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.RectRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            node = this._node,
            t = node._transformWorld,
            curColor = node._displayedColor,
            opacity = node._displayedOpacity / 255,
            locWidth = node._contentSize.width,
            locHeight = node._contentSize.height;
        if (opacity === 0)
            return;
        var needTransform = (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1);
        var needRestore = (node._blendFuncStr !== "source") || needTransform;
        if (needRestore) {
            context.save();
            context.globalCompositeOperation = node._blendFuncStr;
        }
        context.globalAlpha = opacity;
        context.fillStyle = "rgba(" + (0 | curColor.r) + "," + (0 | curColor.g) + ","
            + (0 | curColor.b) + ", 1)";
        if (needTransform) {
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
        } else {
            context.fillRect(t.tx * scaleX, -t.ty * scaleY, locWidth * scaleX, -locHeight * scaleY);
        }
        if (needRestore)
            context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.GradientRectRenderCmdCanvas = function (node) {
        this._node = node;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._startStopStr = null;
        this._endStopStr = null;
    };
    cc.GradientRectRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            self = this,
            node = self._node,
            opacity = node._displayedOpacity / 255,
            t = node._transformWorld;
        if(opacity === 0)
            return;
        var needTransform = (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1);
        var needRestore = (node._blendFuncStr !== "source") || needTransform;
        if(needRestore){
            context.save();
            context.globalCompositeOperation = node._blendFuncStr;
        }
        context.globalAlpha = opacity;
        var locWidth = node._contentSize.width, locHeight = node._contentSize.height;
        var gradient = context.createLinearGradient(self._startPoint.x, self._startPoint.y, self._endPoint.x, self._endPoint.y);
        gradient.addColorStop(0, this._startStopStr);
        gradient.addColorStop(1, this._endStopStr);
        context.fillStyle = gradient;
        if(needTransform){
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
        } else
            context.fillRect(t.tx * scaleX, -t.ty * scaleY, locWidth * scaleX, -locHeight * scaleY);
        if(needRestore)
            context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.ParticleRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ParticleRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            node = this._node,
            t = node._transformWorld,
            pointRect = node._pointRect;
        context.save();
        context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if (node.isBlendAdditive())
            context.globalCompositeOperation = 'lighter';
        else
            context.globalCompositeOperation = 'source-over';
        var i, particle, lpx, alpha;
        var particleCount = this._node.particleCount, particles = this._node._particles;
        if (cc.ParticleSystem.SHAPE_MODE == cc.ParticleSystem.TEXTURE_MODE) {
            if (!node._texture || !node._texture._isLoaded) {
                context.restore();
                return;
            }
            var element = node._texture.getHtmlElementObj();
            if (!element.width || !element.height) {
                context.restore();
                return;
            }
            var textureCache = cc.textureCache, drawElement = element;
            for (i = 0; i < particleCount; i++) {
                particle = particles[i];
                lpx = (0 | (particle.size * 0.5));
                alpha =  particle.color.a / 255;
                if(alpha === 0) continue;
                context.globalAlpha = alpha;
                context.save();
                context.translate((0 | particle.drawPos.x), -(0 | particle.drawPos.y));
                var size = Math.floor(particle.size / 4) * 4;
                var w = pointRect.width;
                var h = pointRect.height;
                context.scale(Math.max((1 / w) * size, 0.000001), Math.max((1 / h) * size, 0.000001));
                if (particle.rotation)
                    context.rotate(cc.degreesToRadians(particle.rotation));
                if (particle.isChangeColor) {
                    var cacheTextureForColor = textureCache.getTextureColors(element);
                    if (cacheTextureForColor) {
                        if (!cacheTextureForColor.tintCache) {
                            cacheTextureForColor.tintCache = cc.newElement('canvas');
                            cacheTextureForColor.tintCache.width = element.width;
                            cacheTextureForColor.tintCache.height = element.height;
                        }
                        cc.generateTintImage(element, cacheTextureForColor, particle.color, this._pointRect, cacheTextureForColor.tintCache);
                        drawElement = cacheTextureForColor.tintCache;
                    }
                }
                context.drawImage(drawElement, -(0 | (w / 2)), -(0 | (h / 2)));
                context.restore();
            }
        } else {
            var drawTool = cc._drawingUtil;
            for (i = 0; i < particleCount; i++) {
                particle = particles[i];
                lpx = (0 | (particle.size * 0.5));
                alpha =  particle.color.a / 255;
                if(alpha === 0) continue;
                context.globalAlpha = alpha;
                context.save();
                context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                if (cc.ParticleSystem.BALL_SHAPE == cc.ParticleSystem.STAR_SHAPE) {
                    if (particle.rotation)
                        context.rotate(cc.degreesToRadians(particle.rotation));
                    drawTool.drawStar(context, lpx, particle.color);
                } else
                    drawTool.drawColorBall(context, lpx, particle.color);
                context.restore();
            }
        }
        context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.ProgressRenderCmdCanvas = function (node) {
        this._PI180 = Math.PI / 180;
        this._node = node;
        this._sprite = null;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._barRect = cc.rect(0, 0, 0, 0);
        this._origin = cc.p(0, 0);
        this._radius = 0;
        this._startAngle = 270;
        this._endAngle = 270;
        this._counterClockWise = false;
    };
    cc.ProgressRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext, node = this._node, locSprite = this._sprite;
        var locTextureCoord = locSprite._rendererCmd._textureCoord, alpha = locSprite._displayedOpacity / 255;
        if(locTextureCoord.width === 0 || locTextureCoord.height === 0)
            return;
        if (!locSprite._texture || !locTextureCoord.validRect || alpha === 0)
            return;
        var t = node._transformWorld;
        context.save();
        context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if (locSprite._blendFuncStr != "source")
            context.globalCompositeOperation = locSprite._blendFuncStr;
        context.globalAlpha = alpha;
        var locRect = locSprite._rect, locOffsetPosition = locSprite._offsetPosition, locDrawSizeCanvas = locSprite._drawSize_Canvas;
        var flipXOffset = 0 | (locOffsetPosition.x), flipYOffset = -locOffsetPosition.y - locRect.height;
        locDrawSizeCanvas.width = locRect.width * scaleX;
        locDrawSizeCanvas.height = locRect.height * scaleY;
        if (locSprite._flippedX) {
            flipXOffset = -locOffsetPosition.x - locRect.width;
            context.scale(-1, 1);
        }
        if (locSprite._flippedY) {
            flipYOffset = locOffsetPosition.y;
            context.scale(1, -1);
        }
        flipXOffset *= scaleX;
        flipYOffset *= scaleY;
        if (this._type == cc.ProgressTimer.TYPE_BAR) {
            var locBarRect = this._barRect;
            context.beginPath();
            context.rect(locBarRect.x * scaleX, locBarRect.y * scaleY, locBarRect.width * scaleX, locBarRect.height * scaleY);
            context.clip();
            context.closePath();
        } else if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
            var locOriginX = this._origin.x * scaleX;
            var locOriginY = this._origin.y * scaleY;
            context.beginPath();
            context.arc(locOriginX, locOriginY, this._radius * scaleY, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise);
            context.lineTo(locOriginX, locOriginY);
            context.clip();
            context.closePath();
        }
        var image = locSprite._texture.getHtmlElementObj();
        context.drawImage(image,
            locTextureCoord.renderX,
            locTextureCoord.renderY,
            locTextureCoord.width,
            locTextureCoord.height,
            flipXOffset, flipYOffset,
            locDrawSizeCanvas.width,
            locDrawSizeCanvas.height
        );
        context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.DrawNodeRenderCmdCanvas = function (node) {
        this._node = node;
        this._buffer = null;
        this._drawColor = null;
        this._blendFunc = null;
    };
    cc.DrawNodeRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext, _t = this, node = _t._node;
        var alpha = node._displayedOpacity/255;
        if(alpha === 0)
            return;
        context.globalAlpha = alpha;
        var t = node._transformWorld;
        context.save();
        ctx.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if ((_t._blendFunc && (_t._blendFunc.src == cc.SRC_ALPHA) && (_t._blendFunc.dst == cc.ONE)))
            context.globalCompositeOperation = 'lighter';
        var locBuffer = _t._buffer;
        for (var i = 0, len = locBuffer.length; i < len; i++) {
            var element = locBuffer[i];
            switch (element.type) {
                case cc.DrawNode.TYPE_DOT:
                    _t._drawDot(context, element, scaleX, scaleY);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    _t._drawSegment(context, element, scaleX, scaleY);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    _t._drawPoly(context, element, scaleX, scaleY);
                    break;
            }
        }
        context.restore();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawDot = function (ctx, element, scaleX, scaleY) {
        var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
        ctx.fillStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")";
        ctx.beginPath();
        ctx.arc(locPos.x * scaleX, -locPos.y * scaleY, locRadius * scaleX, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawSegment = function (ctx, element, scaleX, scaleY) {
        var locColor = element.lineColor;
        var locFrom = element.verts[0], locTo = element.verts[1];
        var locLineWidth = element.lineWidth, locLineCap = element.lineCap;
        ctx.strokeStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")";
        ctx.lineWidth = locLineWidth * scaleX;
        ctx.beginPath();
        ctx.lineCap = locLineCap;
        ctx.moveTo(locFrom.x * scaleX, -locFrom.y * scaleY);
        ctx.lineTo(locTo.x * scaleX, -locTo.y * scaleY);
        ctx.stroke();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawPoly = function (ctx, element, scaleX, scaleY) {
        var locVertices = element.verts, locLineCap = element.lineCap;
        var locFillColor = element.fillColor, locLineWidth = element.lineWidth;
        var locLineColor = element.lineColor, locIsClosePolygon = element.isClosePolygon;
        var locIsFill = element.isFill, locIsStroke = element.isStroke;
        if (locVertices == null)
            return;
        var firstPoint = locVertices[0];
        ctx.lineCap = locLineCap;
        if (locFillColor)
            ctx.fillStyle = "rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + ","
                + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")";
        if (locLineWidth)
            ctx.lineWidth = locLineWidth * scaleX;
        if (locLineColor)
            ctx.strokeStyle = "rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + ","
                + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")";
        ctx.beginPath();
        ctx.moveTo(firstPoint.x * scaleX, -firstPoint.y * scaleY);
        for (var i = 1, len = locVertices.length; i < len; i++)
            ctx.lineTo(locVertices[i].x * scaleX, -locVertices[i].y * scaleY);
        if (locIsClosePolygon)
            ctx.closePath();
        if (locIsFill)
            ctx.fill();
        if (locIsStroke)
            ctx.stroke();
    };
    cc.ClippingNodeSaveRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeSaveRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            var locCache = cc.ClippingNode._getSharedCache();
            var canvas = context.canvas;
            locCache.width = canvas.width;
            locCache.height = canvas.height;
            var locCacheCtx = locCache.getContext("2d");
            locCacheCtx.drawImage(canvas, 0, 0);
            context.save();
        } else {
            node.transform();
            var t = node._transformWorld;
            context.save();
            context.save();
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        }
    };
    cc.ClippingNodeClipRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeClipRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            context.globalCompositeOperation = node.inverted ? "destination-out" : "destination-in";
            var t = node._transformWorld;
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        } else {
            context.restore();
            if (node.inverted) {
                var canvas = context.canvas;
                context.save();
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.moveTo(0, 0);
                context.lineTo(0, canvas.height);
                context.lineTo(canvas.width, canvas.height);
                context.lineTo(canvas.width, 0);
                context.lineTo(0, 0);
                context.restore();
            }
            context.clip();
        }
    };
    cc.ClippingNodeRestoreRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeRestoreRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var locCache = cc.ClippingNode._getSharedCache();
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            context.restore();
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.globalCompositeOperation = "destination-over";
            context.drawImage(locCache, 0, 0);
            context.restore();
        } else {
            context.restore();
        }
    };
    cc.PhysicsDebugNodeRenderCmdCanvas = function (node) {
        this._node = node;
        this._buffer = node._buffer;
    };
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var _node = this._node;
        if (!_node._space)
            return;
        _node._space.eachShape(cc.DrawShape.bind(_node));
        _node._space.eachConstraint(cc.DrawConstraint.bind(_node));
        cc.DrawNodeRenderCmdCanvas.prototype.rendering.call(this, ctx, scaleX, scaleY);
        _node.clear();
    };
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawDot = cc.DrawNodeRenderCmdCanvas.prototype._drawDot;
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawSegment = cc.DrawNodeRenderCmdCanvas.prototype._drawSegment;
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawPoly = cc.DrawNodeRenderCmdCanvas.prototype._drawPoly;
    cc.TMXLayerRenderCmdCanvas = function (tmxLayer) {
        this._node = tmxLayer;
        this._childrenRenderCmds = [];
    };
    cc.TMXLayerRenderCmdCanvas.prototype._copyRendererCmds = function (rendererCmds) {
        if (!rendererCmds)
            return;
        var locCacheCmds = this._childrenRenderCmds;
        locCacheCmds.length = 0;
        for (var i = 0, len = rendererCmds.length; i < len; i++) {
            locCacheCmds[i] = rendererCmds[i];
        }
    };
    cc.TMXLayerRenderCmdCanvas.prototype._renderingChildToCache = function (scaleX, scaleY) {
        var locNode = this._node;
        if (locNode._cacheDirty) {
            var locCacheCmds = this._childrenRenderCmds, locCacheContext = locNode._cacheContext, locCanvas = locNode._cacheCanvas;
            locCacheContext.save();
            locCacheContext.clearRect(0, 0, locCanvas.width, -locCanvas.height);
            var t = cc.affineTransformInvert(locNode._transformWorld);
            locCacheContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            for (var i = 0, len = locCacheCmds.length; i < len; i++) {
                locCacheCmds[i].rendering(locCacheContext, scaleX, scaleY);
                if (locCacheCmds[i]._node)
                    locCacheCmds[i]._node._cacheDirty = false;
            }
            locCacheContext.restore();
            locNode._cacheDirty = false;
        }
    };
    cc.TMXLayerRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var alpha = node._displayedOpacity/255;
        if(alpha <= 0)
            return;
        this._renderingChildToCache(scaleX, scaleY);
        var context = ctx || cc._renderContext;
        context.globalAlpha = alpha;
        var posX = 0 | ( -node._anchorPointInPoints.x), posY = 0 | ( -node._anchorPointInPoints.y);
        var locCacheCanvas = node._cacheCanvas, t = node._transformWorld;
        if (locCacheCanvas && locCacheCanvas.width !== 0 && locCacheCanvas.height !== 0) {
            context.save();
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var locCanvasHeight = locCacheCanvas.height * scaleY;
            if(node.layerOrientation === cc.TMX_ORIENTATION_HEX){
                var halfTileSize = node._mapTileSize.height * 0.5 * scaleY;
                context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height,
                    posX, -(posY + locCanvasHeight) + halfTileSize, locCacheCanvas.width * scaleX, locCanvasHeight);
            } else {
                context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height,
                    posX, -(posY + locCanvasHeight), locCacheCanvas.width * scaleX, locCanvasHeight);
            }
            context.restore();
        }
        cc.g_NumberOfDraws++;
    };
    cc.CustomRenderCmdCanvas = function(node, func){
        this._node = node;
        this._callback = func;
    };
    cc.CustomRenderCmdCanvas.prototype.rendering = function(ctx, scaleX, scaleY){
        if(!this._callback)
            return;
        this._callback.call(this._node, ctx, scaleX, scaleY);
    };
    cc.SkeletonRenderCmdCanvas = function(node){
        this._node = node;
    };
    cc.SkeletonRenderCmdCanvas.prototype.rendering = function(ctx, scaleX, scaleY){
        var node = this._node;
        ctx = ctx || cc._renderContext;
        if(!node._debugSlots && !node._debugBones){
            return;
        }
        var t = node._transformWorld;
        ctx.save();
        ctx.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        var locSkeleton = node._skeleton;
        var attachment,slot, i, n, drawingUtil = cc._drawingUtil;
        if (node._debugSlots) {
            drawingUtil.setDrawColor(0, 0, 255, 255);
            drawingUtil.setLineWidth(1);
            var points = [];
            for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                slot = locSkeleton.drawOrder[i];
                if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)
                    continue;
                attachment = slot.attachment;
                sp._regionAttachment_updateSlotForCanvas(attachment, slot, points);
                drawingUtil.drawPoly(points, 4, true);
            }
        }
        if (node._debugBones) {
            var bone;
            drawingUtil.setLineWidth(2);
            drawingUtil.setDrawColor(255, 0, 0, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                var x = bone.data.length * bone.m00 + bone.worldX;
                var y = bone.data.length * bone.m10 + bone.worldY;
                drawingUtil.drawLine(
                    {x:bone.worldX, y:bone.worldY},
                    {x:x, y:y});
            }
            drawingUtil.setPointSize(4);
            drawingUtil.setDrawColor(0, 0, 255, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                drawingUtil.drawPoint({x:bone.worldX, y:bone.worldY});
                if (i === 0)
                    drawingUtil.setDrawColor(0, 255, 0, 255);
            }
        }
        ctx.restore();
    };
}
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX != RotationY. Don't know which one to return",
    Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function (msg) {
    if (!cc._canvas)
        return;
    var logList = cc._logList;
    var doc = document;
    if (!logList) {
        var logDiv = doc.createElement("Div");
        var logDivStyle = logDiv.style;
        logDiv.setAttribute("id", "logInfoDiv");
        cc._canvas.parentNode.appendChild(logDiv);
        logDiv.setAttribute("width", "200");
        logDiv.setAttribute("height", cc._canvas.height);
        logDivStyle.zIndex = "99999";
        logDivStyle.position = "absolute";
        logDivStyle.top = "0";
        logDivStyle.left = "0";
        logList = cc._logList = doc.createElement("textarea");
        var logListStyle = logList.style;
        logList.setAttribute("rows", "20");
        logList.setAttribute("cols", "30");
        logList.setAttribute("disabled", true);
        logDiv.appendChild(logList);
        logListStyle.backgroundColor = "transparent";
        logListStyle.borderBottom = "1px solid #cccccc";
        logListStyle.borderRightWidth = "0px";
        logListStyle.borderLeftWidth = "0px";
        logListStyle.borderTopWidth = "0px";
        logListStyle.borderTopStyle = "none";
        logListStyle.borderRightStyle = "none";
        logListStyle.borderLeftStyle = "none";
        logListStyle.padding = "0px";
        logListStyle.margin = 0;
    }
    logList.value = logList.value + msg + "\r\n";
    logList.scrollTop = logList.scrollHeight;
};
cc._formatString = function (arg) {
    if (cc.isObject(arg)) {
        try {
            return JSON.stringify(arg);
        } catch (err) {
            return "";
        }
    } else
        return arg;
};
cc._initDebugSetting = function (mode) {
    var ccGame = cc.game;
    if(mode == ccGame.DEBUG_MODE_NONE)
        return;
    var locLog;
    if(mode > ccGame.DEBUG_MODE_ERROR){
        locLog = cc._logToWebPage.bind(cc);
        cc.error = function(){
            locLog("ERROR :  " + cc.formatStr.apply(cc, arguments));
        };
        cc.assert = function(cond, msg) {
            if (!cond && msg) {
                for (var i = 2; i < arguments.length; i++)
                    msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                locLog("Assert: " + msg);
            }
        };
        if(mode != ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE){
            cc.warn = function(){
                locLog("WARN :  " + cc.formatStr.apply(cc, arguments));
            };
        }
        if(mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE){
            cc.log = function(){
                locLog(cc.formatStr.apply(cc, arguments));
            };
        }
    } else {
        if(!console)
            return;
        cc.error = function(){
            return console.error.apply(console, arguments);
        };
        cc.assert = function (cond, msg) {
            if (!cond && msg) {
                for (var i = 2; i < arguments.length; i++)
                    msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                throw msg;
            }
        };
        if(mode != ccGame.DEBUG_MODE_ERROR)
            cc.warn = function(){
                return console.warn.apply(console, arguments);
            };
        if(mode == ccGame.DEBUG_MODE_INFO)
            cc.log = function(){
                return console.log.apply(console, arguments);
            };
    }
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.HashElement = cc.Class.extend({
    actions:null,
    target:null,
    actionIndex:0,
    currentAction:null,
    currentActionSalvaged:false,
    paused:false,
    hh:null,
    ctor:function () {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.currentActionSalvaged = false;
        this.paused = false;
        this.hh = null;
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets:null,
    _arrayTargets:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,
    _searchElementByTarget:function (arr, target) {
        for (var k = 0; k < arr.length; k++) {
            if (target == arr[k].target)
                return arr[k];
        }
        return null;
    },
    ctor:function () {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = false;
    },
    addAction:function (action, target, paused) {
        if(!action)
            throw "cc.ActionManager.addAction(): action must be non-null";
        if(!target)
            throw "cc.ActionManager.addAction(): action must be non-null";
        var element = this._hashTargets[target.__instanceId];
        if (!element) {
            element = new cc.HashElement();
            element.paused = paused;
            element.target = target;
            this._hashTargets[target.__instanceId] = element;
            this._arrayTargets.push(element);
        }
        this._actionAllocWithHashElement(element);
        element.actions.push(action);
        action.startWithTarget(target);
    },
    removeAllActions:function () {
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
            var element = locTargets[i];
            if (element)
                this.removeAllActionsFromTarget(element.target, true);
        }
    },
    removeAllActionsFromTarget:function (target, forceDelete) {
        if (target == null)
            return;
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            if (element.actions.indexOf(element.currentAction) !== -1 && !(element.currentActionSalvaged))
                element.currentActionSalvaged = true;
            element.actions.length = 0;
            if (this._currentTarget == element && !forceDelete) {
                this._currentTargetSalvaged = true;
            } else {
                this._deleteHashElement(element);
            }
        }
    },
    removeAction:function (action) {
        if (action == null)
            return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            for (var i = 0; i < element.actions.length; i++) {
                if (element.actions[i] == action) {
                    element.actions.splice(i, 1);
                    break;
                }
            }
        } else {
            cc.log(cc._LogInfos.ActionManager_removeAction);
        }
    },
    removeActionByTag:function (tag, target) {
        if(tag == cc.ACTION_TAG_INVALID)
            cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(target, cc._LogInfos.ActionManager_addAction);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            var limit = element.actions.length;
            for (var i = 0; i < limit; ++i) {
                var action = element.actions[i];
                if (action && action.getTag() === tag && action.getOriginalTarget() == target) {
                    this._removeActionAtIndex(i, element);
                    break;
                }
            }
        }
    },
    getActionByTag:function (tag, target) {
        if(tag == cc.ACTION_TAG_INVALID)
            cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            if (element.actions != null) {
                for (var i = 0; i < element.actions.length; ++i) {
                    var action = element.actions[i];
                    if (action && action.getTag() === tag)
                        return action;
                }
            }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, tag);
        }
        return null;
    },
    numberOfRunningActionsInTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            return (element.actions) ? element.actions.length : 0;
        return 0;
    },
    pauseTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            element.paused = true;
    },
    resumeTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            element.paused = false;
    },
    pauseAllRunningActions:function(){
        var idsWithActions = [];
        var locTargets = this._arrayTargets;
        for(var i = 0; i< locTargets.length; i++){
            var element = locTargets[i];
            if(element && !element.paused){
                element.paused = true;
                idsWithActions.push(element.target);
            }
        }
        return idsWithActions;
    },
    resumeTargets:function(targetsToResume){
        if(!targetsToResume)
            return;
        for(var i = 0 ; i< targetsToResume.length; i++){
            if(targetsToResume[i])
                this.resumeTarget(targetsToResume[i]);
        }
    },
    purgeSharedManager:function () {
        cc.director.getScheduler().unscheduleUpdateForTarget(this);
    },
    _removeActionAtIndex:function (index, element) {
        var action = element.actions[index];
        if ((action == element.currentAction) && (!element.currentActionSalvaged))
            element.currentActionSalvaged = true;
        element.actions.splice(index, 1);
        if (element.actionIndex >= index)
            element.actionIndex--;
        if (element.actions.length == 0) {
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            } else {
                this._deleteHashElement(element);
            }
        }
    },
    _deleteHashElement:function (element) {
        if (element) {
            delete this._hashTargets[element.target.__instanceId];
            cc.arrayRemoveObject(this._arrayTargets, element);
            element.actions = null;
            element.target = null;
        }
    },
    _actionAllocWithHashElement:function (element) {
        if (element.actions == null) {
            element.actions = [];
        }
    },
    update:function (dt) {
        var locTargets = this._arrayTargets , locCurrTarget;
        for (var elt = 0; elt < locTargets.length; elt++) {
            this._currentTarget = locTargets[elt];
            locCurrTarget = this._currentTarget;
            if (!locCurrTarget.paused) {
                for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length;
                     locCurrTarget.actionIndex++) {
                    locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                    if (!locCurrTarget.currentAction)
                        continue;
                    locCurrTarget.currentActionSalvaged = false;
                    locCurrTarget.currentAction.step(dt * ( locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1 ) );
                    if (locCurrTarget.currentActionSalvaged) {
                        locCurrTarget.currentAction = null;//release
                    } else if (locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        var action = locCurrTarget.currentAction;
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                    }
                    locCurrTarget.currentAction = null;
                }
            }
            if (this._currentTargetSalvaged && locCurrTarget.actions.length === 0) {
                this._deleteHashElement(locCurrTarget);
            }
        }
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget:null,
    target:null,
    tag:cc.ACTION_TAG_INVALID,
    ctor:function () {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.ACTION_TAG_INVALID;
    },
    copy:function () {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone();
    },
    clone:function () {
        var action = new cc.Action();
        action.originalTarget = null;
        action.target = null;
        action.tag = this.tag;
        return action;
    },
    isDone:function () {
        return true;
    },
    startWithTarget:function (target) {
        this.originalTarget = target;
        this.target = target;
    },
    stop:function () {
        this.target = null;
    },
    step:function (dt) {
        cc.log("[Action step]. override me");
    },
    update:function (dt) {
        cc.log("[Action update]. override me");
    },
    getTarget:function () {
        return this.target;
    },
    setTarget:function (target) {
        this.target = target;
    },
    getOriginalTarget:function () {
        return this.originalTarget;
    },
    setOriginalTarget:function (originalTarget) {
        this.originalTarget = originalTarget;
    },
    getTag:function () {
        return this.tag;
    },
    setTag:function (tag) {
        this.tag = tag;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.action = function () {
    return new cc.Action();
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration:0,
    ctor:function () {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0;
    },
    getDuration:function () {
        return this._duration * (this._times || 1);
    },
    setDuration:function (duration) {
        this._duration = duration;
    },
    reverse:function () {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null;
    },
    clone:function () {
        return new cc.FiniteTimeAction();
    }
});
cc.Speed = cc.Action.extend({
    _speed:0.0,
    _innerAction:null,
    ctor:function (action, speed) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
		action && this.initWithAction(action, speed);
    },
    getSpeed:function () {
        return this._speed;
    },
    setSpeed:function (speed) {
        this._speed = speed;
    },
    initWithAction:function (action, speed) {
        if(!action)
            throw "cc.Speed.initWithAction(): action must be non nil";
        this._innerAction = action;
        this._speed = speed;
        return true;
    },
    clone:function () {
        var action = new cc.Speed();
        action.initWithAction(this._innerAction.clone(), this._speed);
        return action;
    },
    startWithTarget:function (target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    step:function (dt) {
        this._innerAction.step(dt * this._speed);
    },
    isDone:function () {
        return this._innerAction.isDone();
    },
    reverse:function () {
        return new cc.Speed(this._innerAction.reverse(), this._speed);
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.speed = function (action, speed) {
    return new cc.Speed(action, speed);
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode:null,
    _boundarySet:false,
    _boundaryFullyCovered:false,
    _halfScreenSize:null,
    _fullScreenSize:null,
    _worldRect:null,
    leftBoundary:0.0,
    rightBoundary:0.0,
    topBoundary:0.0,
    bottomBoundary:0.0,
    ctor:function (followedNode, rect) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;
        this._halfScreenSize = null;
        this._fullScreenSize = null;
        this.leftBoundary = 0.0;
        this.rightBoundary = 0.0;
        this.topBoundary = 0.0;
        this.bottomBoundary = 0.0;
        this._worldRect = cc.rect(0, 0, 0, 0);
		if(followedNode)
			rect ? this.initWithTarget(followedNode, rect)
				 : this.initWithTarget(followedNode);
    },
    clone:function () {
        var action = new cc.Follow();
        var locRect = this._worldRect;
        var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
        action.initWithTarget(this._followedNode, rect);
        return action;
    },
    isBoundarySet:function () {
        return this._boundarySet;
    },
    setBoudarySet:function (value) {
        this._boundarySet = value;
    },
    initWithTarget:function (followedNode, rect) {
        if(!followedNode)
            throw "cc.Follow.initWithAction(): followedNode must be non nil";
        var _this = this;
        rect = rect || cc.rect(0, 0, 0, 0);
        _this._followedNode = followedNode;
        _this._worldRect = rect;
        _this._boundarySet = !cc._rectEqualToZero(rect);
        _this._boundaryFullyCovered = false;
        var winSize = cc.director.getWinSize();
        _this._fullScreenSize = cc.p(winSize.width, winSize.height);
        _this._halfScreenSize = cc.pMult(_this._fullScreenSize, 0.5);
        if (_this._boundarySet) {
            _this.leftBoundary = -((rect.x + rect.width) - _this._fullScreenSize.x);
            _this.rightBoundary = -rect.x;
            _this.topBoundary = -rect.y;
            _this.bottomBoundary = -((rect.y + rect.height) - _this._fullScreenSize.y);
            if (_this.rightBoundary < _this.leftBoundary) {
                _this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2;
            }
            if (_this.topBoundary < _this.bottomBoundary) {
                _this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2;
            }
            if ((_this.topBoundary == _this.bottomBoundary) && (_this.leftBoundary == _this.rightBoundary))
                _this._boundaryFullyCovered = true;
        }
        return true;
    },
    step:function (dt) {
        var tempPosX = this._followedNode.x;
        var tempPosY = this._followedNode.y;
        tempPosX = this._halfScreenSize.x - tempPosX;
        tempPosY = this._halfScreenSize.y - tempPosY;
        if (this._boundarySet) {
            if (this._boundaryFullyCovered)
                return;
	        this.target.setPosition(cc.clampf(tempPosX, this.leftBoundary, this.rightBoundary), cc.clampf(tempPosY, this.bottomBoundary, this.topBoundary));
        } else {
            this.target.setPosition(tempPosX, tempPosY);
        }
    },
    isDone:function () {
        return ( !this._followedNode.running );
    },
    stop:function () {
        this.target = null;
        cc.Action.prototype.stop.call(this);
    }
});
cc.follow = function (followedNode, rect) {
    return new cc.Follow(followedNode, rect);
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed:0,
    _firstTick:false,
    _easeList: null,
    _times:1,
    _repeatForever: false,
    _repeatMethod: false,//Compatible with repeat class, Discard after can be deleted
    _speed: 1,
    _speedMethod: false,//Compatible with speed class, Discard after can be deleted
    ctor:function (d) {
        this._speed = 1;
        this._times = 1;
        this._repeatForever = false;
        this.MAX_VALUE = 2;
        this._repeatMethod = false;//Compatible with repeat class, Discard after can be deleted
        this._speedMethod = false;//Compatible with repeat class, Discard after can be deleted
        cc.FiniteTimeAction.prototype.ctor.call(this);
		d !== undefined && this.initWithDuration(d);
    },
    getElapsed:function () {
        return this._elapsed;
    },
    initWithDuration:function (d) {
        this._duration = (d === 0) ? cc.FLT_EPSILON : d;
        this._elapsed = 0;
        this._firstTick = true;
        return true;
    },
    isDone:function () {
        return (this._elapsed >= this._duration);
    },
    _cloneDecoration: function(action){
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._times = this._times;
        action._easeList = this._easeList;
        action._speedMethod = this._speedMethod;
        action._repeatMethod = this._repeatMethod;
    },
    _reverseEaseList: function(action){
        if(this._easeList){
            action._easeList = [];
            for(var i=0; i<this._easeList.length; i++){
                action._easeList.push(this._easeList[i].reverse());
            }
        }
    },
    clone:function () {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action;
    },
    easing: function (easeObj) {
        if (this._easeList)
            this._easeList.length = 0;
        else
            this._easeList = [];
        for (var i = 0; i < arguments.length; i++)
            this._easeList.push(arguments[i]);
        return this;
    },
    _computeEaseTime: function (dt) {
        var locList = this._easeList;
        if ((!locList) || (locList.length === 0))
            return dt;
        for (var i = 0, n = locList.length; i < n; i++)
            dt = locList[i].easing(dt);
        return dt;
    },
    step:function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
        } else
            this._elapsed += dt;
        var t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
        t = (1 > t ? t : 1);
        this.update(t > 0 ? t : 0);
        if(this._repeatMethod && this._times > 1 && this.isDone()){
            if(!this._repeatForever){
                this._times--;
            }
            this.startWithTarget(this.target);
            this.step(this._elapsed - this._duration);
        }
    },
    startWithTarget:function (target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true;
    },
    reverse:function () {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null;
    },
    setAmplitudeRate:function (amp) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.");
    },
    getAmplitudeRate:function () {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0;
    },
    speed: function(speed){
        if(speed <= 0){
            cc.log("The speed parameter error");
            return this;
        }
        this._speedMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._speed *= speed;
        return this;
    },
    getSpeed: function(){
        return this._speed;
    },
    setSpeed: function(speed){
        this._speed = speed;
        return this;
    },
    repeat: function(times){
        times = Math.round(times);
        if(isNaN(times) || times < 1){
            cc.log("The repeat parameter error");
            return this;
        }
        this._repeatMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._times *= times;
        return this;
    },
    repeatForever: function(){
        this._repeatMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._times = this.MAX_VALUE;
        this._repeatForever = true;
        return this;
    }
});
cc.actionInterval = function (d) {
    return new cc.ActionInterval(d);
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions:null,
    _split:null,
    _last:0,
    ctor:function (tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
		var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
		var last = paramArray.length - 1;
		if ((last >= 0) && (paramArray[last] == null))
			cc.log("parameters should not be ending with null in Javascript");
        if (last >= 0) {
            var prev = paramArray[0], action1;
            for (var i = 1; i < last; i++) {
                if (paramArray[i]) {
                    action1 = prev;
                    prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
                }
            }
            this.initWithTwoActions(prev, paramArray[last]);
        }
    },
    initWithTwoActions:function (actionOne, actionTwo) {
        if(!actionOne || !actionTwo)
            throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        var d = actionOne._duration + actionTwo._duration;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
    },
    clone:function () {
        var action = new cc.Sequence();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1;
    },
    stop:function () {
        if (this._last !== -1)
            this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var new_t, found = 0;
        var locSplit = this._split, locActions = this._actions, locLast = this._last;
        if (dt < locSplit) {
            new_t = (locSplit !== 0) ? dt / locSplit : 1;
            if (found === 0 && locLast === 1) {
                locActions[1].update(0);
                locActions[1].stop();
            }
        } else {
            found = 1;
            new_t = (locSplit === 1) ? 1 : (dt - locSplit) / (1 - locSplit);
            if (locLast === -1) {
                locActions[0].startWithTarget(this.target);
                locActions[0].update(1);
                locActions[0].stop();
            }
            if (!locLast) {
                locActions[0].update(1);
                locActions[0].stop();
            }
        }
        if (locLast === found && locActions[found].isDone())
            return;
        if (locLast !== found)
            locActions[found].startWithTarget(this.target);
        locActions[found].update(new_t);
        this._last = found;
    },
    reverse:function () {
        var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.sequence = function (tempArray) {
    var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
    if ((paramArray.length > 0) && (paramArray[paramArray.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i])
            prev = cc.Sequence._actionOneTwo(prev, paramArray[i]);
    }
    return prev;
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function (actionOne, actionTwo) {
    var sequence = new cc.Sequence();
    sequence.initWithTwoActions(actionOne, actionTwo);
    return sequence;
};
cc.Repeat = cc.ActionInterval.extend({
    _times:0,
    _total:0,
    _nextDt:0,
    _actionInstant:false,
    _innerAction:null,
    ctor: function (action, times) {
        cc.ActionInterval.prototype.ctor.call(this);
		times !== undefined && this.initWithAction(action, times);
    },
    initWithAction:function (action, times) {
        var duration = action._duration * times;
        if (this.initWithDuration(duration)) {
            this._times = times;
            this._innerAction = action;
            if (action instanceof cc.ActionInstant){
                this._actionInstant = true;
                this._times -= 1;
            }
            this._total = 0;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Repeat();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action;
    },
    startWithTarget:function (target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var locInnerAction = this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (dt >= locNextDt) {
            while (dt > locNextDt && this._total < locTimes) {
                locInnerAction.update(1);
                this._total++;
                locInnerAction.stop();
                locInnerAction.startWithTarget(this.target);
                locNextDt += locInnerAction._duration / locDuration;
                this._nextDt = locNextDt;
            }
            if (dt >= 1.0 && this._total < locTimes)
                this._total++;
            if (!this._actionInstant) {
                if (this._total === locTimes) {
                    locInnerAction.update(1);
                    locInnerAction.stop();
                } else {
                    locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
                }
            }
        } else {
            locInnerAction.update((dt * locTimes) % 1.0);
        }
    },
    isDone:function () {
        return this._total == this._times;
    },
    reverse:function () {
        var action = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.repeat = function (action, times) {
    return new cc.Repeat(action, times);
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction:null,
    ctor:function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
		action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.RepeatForever.initWithAction(): action must be non null";
        this._innerAction = action;
        return true;
    },
    clone:function () {
        var action = new cc.RepeatForever();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    step:function (dt) {
        var locInnerAction = this._innerAction;
        locInnerAction.step(dt);
        if (locInnerAction.isDone()) {
            locInnerAction.startWithTarget(this.target);
            locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
        }
    },
    isDone:function () {
        return false;
    },
    reverse:function () {
        var action = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.repeatForever = function (action) {
    return new cc.RepeatForever(action);
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one:null,
    _two:null,
    ctor:function (tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._one = null;
        this._two = null;
		var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
		var last = paramArray.length - 1;
		if ((last >= 0) && (paramArray[last] == null))
			cc.log("parameters should not be ending with null in Javascript");
        if (last >= 0) {
            var prev = paramArray[0], action1;
            for (var i = 1; i < last; i++) {
                if (paramArray[i]) {
                    action1 = prev;
                    prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
                }
            }
            this.initWithTwoActions(prev, paramArray[last]);
        }
    },
    initWithTwoActions:function (action1, action2) {
        if(!action1 || !action2)
            throw "cc.Spawn.initWithTwoActions(): arguments must all be non null" ;
        var ret = false;
        var d1 = action1._duration;
        var d2 = action2._duration;
        if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;
            if (d1 > d2) {
                this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2));
            } else if (d1 < d2) {
                this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1));
            }
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.Spawn();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._one.clone(), this._two.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
    },
    stop:function () {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this._one)
            this._one.update(dt);
        if (this._two)
            this._two.update(dt);
    },
    reverse:function () {
        var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.spawn = function (tempArray) {
    var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
    if ((paramArray.length > 0) && (paramArray[paramArray.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i] != null)
            prev = cc.Spawn._actionOneTwo(prev, paramArray[i]);
    }
    return prev;
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function (action1, action2) {
    var pSpawn = new cc.Spawn();
    pSpawn.initWithTwoActions(action1, action2);
    return pSpawn;
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX:0,
    _startAngleX:0,
    _diffAngleX:0,
    _dstAngleY:0,
    _startAngleY:0,
    _diffAngleY:0,
    ctor:function (duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
    },
    initWithDuration:function (duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._dstAngleX = deltaAngleX || 0;
            this._dstAngleY = deltaAngleY || this._dstAngleX;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.RotateTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locStartAngleX = target.rotationX % 360.0;
        var locDiffAngleX = this._dstAngleX - locStartAngleX;
        if (locDiffAngleX > 180)
            locDiffAngleX -= 360;
        if (locDiffAngleX < -180)
            locDiffAngleX += 360;
        this._startAngleX = locStartAngleX;
        this._diffAngleX = locDiffAngleX;
        this._startAngleY = target.rotationY % 360.0;
        var locDiffAngleY = this._dstAngleY - this._startAngleY;
        if (locDiffAngleY > 180)
            locDiffAngleY -= 360;
        if (locDiffAngleY < -180)
            locDiffAngleY += 360;
        this._diffAngleY = locDiffAngleY;
    },
    reverse:function () {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.");
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
            this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
        }
    }
});
cc.rotateTo = function (duration, deltaAngleX, deltaAngleY) {
    return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX:0,
    _startAngleX:0,
    _angleY:0,
    _startAngleY:0,
    ctor: function (duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
    },
    initWithDuration:function (duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._angleX = deltaAngleX || 0;
            this._angleY = deltaAngleY || this._angleX;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.RotateBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._angleX, this._angleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngleX = target.rotationX;
        this._startAngleY = target.rotationY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.rotationX = this._startAngleX + this._angleX * dt;
            this.target.rotationY = this._startAngleY + this._angleY * dt;
        }
    },
    reverse:function () {
        var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.rotateBy = function (duration, deltaAngleX, deltaAngleY) {
    return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta:null,
    _startPosition:null,
    _previousPosition:null,
    ctor:function (duration, deltaPos, deltaY) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
		deltaPos !== undefined && this.initWithDuration(duration, deltaPos, deltaY);
    },
    initWithDuration:function (duration, position, y) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
	        if(position.x !== undefined) {
		        y = position.y;
		        position = position.x;
	        }
            this._positionDelta.x = position;
            this._positionDelta.y = y;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.MoveBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._positionDelta);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var x = this._positionDelta.x * dt;
            var y = this._positionDelta.y * dt;
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var action = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.moveBy = function (duration, deltaPos, deltaY) {
    return new cc.MoveBy(duration, deltaPos, deltaY);
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition:null,
    ctor:function (duration, position, y) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
		position !== undefined && this.initWithDuration(duration, position, y);
    },
    initWithDuration:function (duration, position, y) {
        if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
	        if(position.x !== undefined) {
		        y = position.y;
		        position = position.x;
	        }
            this._endPosition.x = position;
            this._endPosition.y = y;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.MoveTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition);
        return action;
    },
    startWithTarget:function (target) {
        cc.MoveBy.prototype.startWithTarget.call(this, target);
        this._positionDelta.x = this._endPosition.x - target.getPositionX();
        this._positionDelta.y = this._endPosition.y - target.getPositionY();
    }
});
cc.moveTo = function (duration, position, y) {
    return new cc.MoveTo(duration, position, y);
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX:0,
    _skewY:0,
    _startSkewX:0,
    _startSkewY:0,
    _endSkewX:0,
    _endSkewY:0,
    _deltaX:0,
    _deltaY:0,
    ctor: function (t, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
		sy !== undefined && this.initWithDuration(t, sx, sy);
    },
    initWithDuration:function (t, sx, sy) {
        var ret = false;
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._endSkewX = sx;
            this._endSkewY = sy;
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.SkewTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startSkewX = target.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        if (this._deltaX > 180)
            this._deltaX -= 360;
        if (this._deltaX < -180)
            this._deltaX += 360;
        this._startSkewY = target.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        if (this._deltaY > 180)
            this._deltaY -= 360;
        if (this._deltaY < -180)
            this._deltaY += 360;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this.target.skewX = this._startSkewX + this._deltaX * dt;
        this.target.skewY = this._startSkewY + this._deltaY * dt;
    }
});
cc.skewTo = function (t, sx, sy) {
    return new cc.SkewTo(t, sx, sy);
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
	ctor: function(t, sx, sy) {
		cc.SkewTo.prototype.ctor.call(this);
		sy !== undefined && this.initWithDuration(t, sx, sy);
	},
    initWithDuration:function (t, deltaSkewX, deltaSkewY) {
        var ret = false;
        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
            this._skewX = deltaSkewX;
            this._skewY = deltaSkewY;
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.SkewBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._skewX, this._skewY);
        return action;
    },
    startWithTarget:function (target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
    },
    reverse:function () {
        var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.skewBy = function (t, sx, sy) {
    return new cc.SkewBy(t, sx, sy);
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition:null,
    _delta:null,
    _height:0,
    _jumps:0,
    _previousPosition:null,
    ctor:function (duration, position, y, height, jumps) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
		height !== undefined && this.initWithDuration(duration, position, y, height, jumps);
    },
    initWithDuration:function (duration, position, y, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
	        if (jumps === undefined) {
		        jumps = height;
		        height = y;
		        y = position.y;
		        position = position.x;
	        }
            this._delta.x = position;
            this._delta.y = y;
            this._height = height;
            this._jumps = jumps;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.JumpBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var frac = dt * this._jumps % 1.0;
            var y = this._height * 4 * frac * (1 - frac);
            y += this._delta.y * dt;
            var x = this._delta.x * dt;
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var action = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.jumpBy = function (duration, position, y, height, jumps) {
    return new cc.JumpBy(duration, position, y, height, jumps);
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition:null,
    ctor:function (duration, position, y, height, jumps) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        height !== undefined && this.initWithDuration(duration, position, y, height, jumps);
    },
    initWithDuration:function (duration, position, y, height, jumps) {
        if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
            if (jumps === undefined) {
                y = position.y;
                position = position.x;
            }
            this._endPosition.x = position;
            this._endPosition.y = y;
            return true;
        }
        return false;
    },
    startWithTarget:function (target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y;
    },
    clone:function () {
        var action = new cc.JumpTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action;
    }
});
cc.jumpTo = function (duration, position, y, height, jumps) {
    return new cc.JumpTo(duration, position, y, height, jumps);
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function (a, b, c, d, t) {
    return (Math.pow(1 - t, 3) * a +
        3 * t * (Math.pow(1 - t, 2)) * b +
        3 * Math.pow(t, 2) * (1 - t) * c +
        Math.pow(t, 3) * d );
};
cc.BezierBy = cc.ActionInterval.extend({
    _config:null,
    _startPosition:null,
    _previousPosition:null,
    ctor:function (t, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
		c && this.initWithDuration(t, c);
    },
    initWithDuration:function (t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._config = c;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.BezierBy();
        this._cloneDecoration(action);
        var newConfigs = [];
        for (var i = 0; i < this._config.length; i++) {
            var selConf = this._config[i];
            newConfigs.push(cc.p(selConf.x, selConf.y));
        }
        action.initWithDuration(this._duration, newConfigs);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var locConfig = this._config;
            var xa = 0;
            var xb = locConfig[0].x;
            var xc = locConfig[1].x;
            var xd = locConfig[2].x;
            var ya = 0;
            var yb = locConfig[0].y;
            var yc = locConfig[1].y;
            var yd = locConfig[2].y;
            var x = cc.bezierAt(xa, xb, xc, xd, dt);
            var y = cc.bezierAt(ya, yb, yc, yd, dt);
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var locConfig = this._config;
        var r = [
            cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])),
            cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])),
            cc.pNeg(locConfig[2]) ];
        var action = new cc.BezierBy(this._duration, r);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.bezierBy = function (t, c) {
    return new cc.BezierBy(t, c);
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig:null,
    ctor:function (t, c) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
		c && this.initWithDuration(t, c);
    },
    initWithDuration:function (t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._toConfig = c;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.BezierTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toConfig);
        return action;
    },
    startWithTarget:function (target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        var locStartPos = this._startPosition;
        var locToConfig = this._toConfig;
        var locConfig = this._config;
        locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
        locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
        locConfig[2] = cc.pSub(locToConfig[2], locStartPos);
    }
});
cc.bezierTo = function (t, c) {
    return new cc.BezierTo(t, c);
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX:1,
    _scaleY:1,
    _startScaleX:1,
    _startScaleY:1,
    _endScaleX:0,
    _endScaleY:0,
    _deltaX:0,
    _deltaY:0,
    ctor:function (duration, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
		sx !== undefined && this.initWithDuration(duration, sx, sy);
    },
    initWithDuration:function (duration, sx, sy) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._endScaleX = sx;
            this._endScaleY = (sy != null) ? sy : sx;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.ScaleTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.scaleX;
        this._startScaleY = target.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.scaleX = this._startScaleX + this._deltaX * dt;
	        this.target.scaleY = this._startScaleY + this._deltaY * dt;
        }
    }
});
cc.scaleTo = function (duration, sx, sy) {
    return new cc.ScaleTo(duration, sx, sy);
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget:function (target) {
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
    },
    reverse:function () {
        var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.ScaleBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
    }
});
cc.scaleBy = function (duration, sx, sy) {
    return new cc.ScaleBy(duration, sx, sy);
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times:0,
    _originalState:false,
    ctor:function (duration, blinks) {
        cc.ActionInterval.prototype.ctor.call(this);
		blinks !== undefined && this.initWithDuration(duration, blinks);
    },
    initWithDuration:function (duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._times = blinks;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Blink();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._times);
        return action;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target && !this.isDone()) {
            var slice = 1.0 / this._times;
            var m = dt % slice;
            this.target.visible = (m > (slice / 2));
        }
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._originalState = target.visible;
    },
    stop:function () {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
    },
    reverse:function () {
        var action = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.blink = function (duration, blinks) {
    return new cc.Blink(duration, blinks);
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity:0,
    _fromOpacity:0,
    ctor:function (duration, opacity) {
        cc.ActionInterval.prototype.ctor.call(this);
		opacity !== undefined && this.initWithDuration(duration, opacity);
    },
    initWithDuration:function (duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._toOpacity = opacity;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.FadeTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    },
    update:function (time) {
        time = this._computeEaseTime(time);
        var fromOpacity = this._fromOpacity !== undefined ? this._fromOpacity : 255;
        this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.opacity;
    }
});
cc.fadeTo = function (duration, opacity) {
    return new cc.FadeTo(duration, opacity);
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor:function (duration) {
        cc.FadeTo.prototype.ctor.call(this);
        duration && this.initWithDuration(duration, 255);
    },
    reverse:function () {
        var action = new cc.FadeOut();
        action.initWithDuration(this._duration, 0);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.FadeIn();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    },
    startWithTarget:function (target) {
        if(this._reverseAction)
            this._toOpacity = this._reverseAction._fromOpacity;
        cc.FadeTo.prototype.startWithTarget.call(this, target);
    }
});
cc.fadeIn = function (duration) {
    return new cc.FadeIn(duration);
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor:function (duration) {
        cc.FadeTo.prototype.ctor.call(this);
        duration && this.initWithDuration(duration, 0);
    },
    reverse:function () {
        var action = new cc.FadeIn();
        action._reverseAction = this;
        action.initWithDuration(this._duration, 255);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.FadeOut();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    }
});
cc.fadeOut = function (d) {
    return new cc.FadeOut(d);
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to:null,
    _from:null,
    ctor:function (duration, red, green, blue) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
		blue !== undefined && this.initWithDuration(duration, red, green, blue);
    },
    initWithDuration:function (duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._to = cc.color(red, green, blue);
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TintTo();
        this._cloneDecoration(action);
        var locTo = this._to;
        action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this.target.color;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var locFrom = this._from, locTo = this._to;
        if (locFrom) {
            this.target.color = cc.color(locFrom.r + (locTo.r - locFrom.r) * dt,
                                        locFrom.g + (locTo.g - locFrom.g) * dt,
	                                    locFrom.b + (locTo.b - locFrom.b) * dt);
        }
    }
});
cc.tintTo = function (duration, red, green, blue) {
    return new cc.TintTo(duration, red, green, blue);
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR:0,
    _deltaG:0,
    _deltaB:0,
    _fromR:0,
    _fromG:0,
    _fromB:0,
    ctor:function (duration, deltaRed, deltaGreen, deltaBlue) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaBlue !== undefined && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
    },
    initWithDuration:function (duration, deltaRed, deltaGreen, deltaBlue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._deltaR = deltaRed;
            this._deltaG = deltaGreen;
            this._deltaB = deltaBlue;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TintBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var color = target.color;
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this.target.color = cc.color(this._fromR + this._deltaR * dt,
                                    this._fromG + this._deltaG * dt,
                                    this._fromB + this._deltaB * dt);
    },
    reverse:function () {
        var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.tintBy = function (duration, deltaRed, deltaGreen, deltaBlue) {
    return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update:function (dt) {},
    reverse:function () {
        var action = new cc.DelayTime(this._duration);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.DelayTime();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration);
        return action;
    }
});
cc.delayTime = function (d) {
    return new cc.DelayTime(d);
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other:null,
    ctor:function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
		action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.ReverseTime.initWithAction(): action must be non null";
        if(action == this._other)
            throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
            this._other = action;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.ReverseTime();
        this._cloneDecoration(action);
        action.initWithAction(this._other.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this._other)
            this._other.update(1 - dt);
    },
    reverse:function () {
        return this._other.clone();
    },
    stop:function () {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
    }
});
cc.reverseTime = function (action) {
    return new cc.ReverseTime(action);
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation:null,
    _nextFrame:0,
    _origFrame:null,
    _executedLoops:0,
    _splitTimes:null,
    ctor:function (animation) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
		animation && this.initWithAnimation(animation);
    },
    getAnimation:function () {
        return this._animation;
    },
    setAnimation:function (animation) {
        this._animation = animation;
    },
    initWithAnimation:function (animation) {
        if(!animation)
            throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var singleDuration = animation.getDuration();
        if (this.initWithDuration(singleDuration * animation.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(animation);
            this._origFrame = null;
            this._executedLoops = 0;
            var locTimes = this._splitTimes;
            locTimes.length = 0;
            var accumUnitsOfTime = 0;
            var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
            var frames = animation.getFrames();
            cc.arrayVerifyType(frames, cc.AnimationFrame);
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var value = (accumUnitsOfTime * newUnitOfTimeValue) / singleDuration;
                accumUnitsOfTime += frame.getDelayUnits();
                locTimes.push(value);
            }
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Animate();
        this._cloneDecoration(action);
        action.initWithAnimation(this._animation.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        if (this._animation.getRestoreOriginalFrame())
            this._origFrame = target.displayFrame();
        this._nextFrame = 0;
        this._executedLoops = 0;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (dt < 1.0) {
            dt *= this._animation.getLoops();
            var loopNumber = 0 | dt;
            if (loopNumber > this._executedLoops) {
                this._nextFrame = 0;
                this._executedLoops++;
            }
            dt = dt % 1.0;
        }
        var frames = this._animation.getFrames();
        var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
        for (var i = this._nextFrame; i < numberOfFrames; i++) {
            if (locSplitTimes[i] <= dt) {
                this.target.setSpriteFrame(frames[i].getSpriteFrame());
                this._nextFrame = i + 1;
            } else {
                break;
            }
        }
    },
    reverse:function () {
        var locAnimation = this._animation;
        var oldArray = locAnimation.getFrames();
        var newArray = [];
        cc.arrayVerifyType(oldArray, cc.AnimationFrame);
        if (oldArray.length > 0) {
            for (var i = oldArray.length - 1; i >= 0; i--) {
                var element = oldArray[i];
                if (!element)
                    break;
                newArray.push(element.clone());
            }
        }
        var newAnim = new cc.Animation(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
        newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
        var action = new cc.Animate(newAnim);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    stop:function () {
        if (this._animation.getRestoreOriginalFrame() && this.target)
            this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this);
    }
});
cc.animate = function (animation) {
    return new cc.Animate(animation);
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action:null,
    _forcedTarget:null,
    ctor: function (target, action) {
        cc.ActionInterval.prototype.ctor.call(this);
		action && this.initWithTarget(target, action);
    },
    initWithTarget:function (target, action) {
        if (this.initWithDuration(action._duration)) {
            this._forcedTarget = target;
            this._action = action;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TargetedAction();
        this._cloneDecoration(action);
        action.initWithTarget(this._forcedTarget, this._action.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget);
    },
    stop:function () {
        this._action.stop();
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this._action.update(dt);
    },
    getForcedTarget:function () {
        return this._forcedTarget;
    },
    setForcedTarget:function (forcedTarget) {
        if (this._forcedTarget != forcedTarget)
            this._forcedTarget = forcedTarget;
    }
});
cc.targetedAction = function (target, action) {
    return new cc.TargetedAction(target, action);
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone:function () {
        return true;
    },
    step:function (dt) {
        this.update(1);
    },
    update:function (dt) {
    },
    reverse:function(){
        return this.clone();
    },
    clone:function(){
        return new cc.ActionInstant();
    }
});
cc.Show = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = true;
    },
    reverse:function () {
        return new cc.Hide();
    },
    clone:function(){
        return new cc.Show();
    }
});
cc.show = function () {
    return new cc.Show();
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = false;
    },
    reverse:function () {
        return new cc.Show();
    },
    clone:function(){
        return new cc.Hide();
    }
});
cc.hide = function () {
    return new cc.Hide();
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = !this.target.visible;
    },
    reverse:function () {
        return new cc.ToggleVisibility();
    },
    clone:function(){
        return new cc.ToggleVisibility();
    }
});
cc.toggleVisibility = function () {
    return new cc.ToggleVisibility();
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
     _isNeedCleanUp: true,
    ctor:function(isNeedCleanUp){
        cc.FiniteTimeAction.prototype.ctor.call(this);
	    isNeedCleanUp !== undefined && this.init(isNeedCleanUp);
    },
    update:function(dt){
        this.target.removeFromParent(this._isNeedCleanUp);
    },
    /**
     * Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it .
     * @param isNeedCleanUp
     * @returns {boolean}
     */
    init:function(isNeedCleanUp){
        this._isNeedCleanUp = isNeedCleanUp;
        return true;
    },
    reverse:function(){
        return new cc.RemoveSelf(this._isNeedCleanUp);
    },
    clone:function(){
        return new cc.RemoveSelf(this._isNeedCleanUp);
    }
});
cc.removeSelf = function(isNeedCleanUp){
    return new cc.RemoveSelf(isNeedCleanUp);
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX:false,
    ctor:function(flip){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = false;
		flip !== undefined && this.initWithFlipX(flip);
    },
    initWithFlipX:function (flip) {
        this._flippedX = flip;
        return true;
    },
    update:function (dt) {
        this.target.flippedX = this._flippedX;
    },
    reverse:function () {
        return new cc.FlipX(!this._flippedX);
    },
    clone:function(){
        var action = new cc.FlipX();
        action.initWithFlipX(this._flippedX);
        return action;
    }
});
cc.flipX = function (flip) {
    return new cc.FlipX(flip);
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY:false,
    ctor: function(flip){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = false;
		flip !== undefined && this.initWithFlipY(flip);
    },
    initWithFlipY:function (flip) {
        this._flippedY = flip;
        return true;
    },
    update:function (dt) {
        this.target.flippedY = this._flippedY;
    },
    reverse:function () {
        return new cc.FlipY(!this._flippedY);
    },
    clone:function(){
        var action = new cc.FlipY();
        action.initWithFlipY(this._flippedY);
        return action;
    }
});
cc.flipY = function (flip) {
    return new cc.FlipY(flip);
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
	_y: 0,
    ctor:function(pos, y){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._x = 0;
	    this._y = 0;
		if (pos !== undefined) {
			if (pos.x !== undefined) {
				y = pos.y;
				pos = pos.x;
			}
			this.initWithPosition(pos, y);
		}
    },
    initWithPosition: function (x, y) {
        this._x = x;
        this._y = y;
        return true;
    },
    update:function (dt) {
        this.target.setPosition(this._x, this._y);
    },
    clone:function(){
        var action = new cc.Place();
        action.initWithPosition(this._x, this._y);
        return action;
    }
});
cc.place = function (pos, y) {
    return new cc.Place(pos, y);
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget:null,
    _callFunc:null,
    _function:null,
    _data:null,
    ctor:function(selector, selectorTarget, data){
        cc.FiniteTimeAction.prototype.ctor.call(this);
		if(selector !== undefined){
			if(selectorTarget === undefined)
				this.initWithFunction(selector);
			else this.initWithFunction(selector, selectorTarget, data);
		}
    },
    initWithFunction:function (selector, selectorTarget, data) {
	    if (selectorTarget) {
            this._data = data;
            this._callFunc = selector;
            this._selectorTarget = selectorTarget;
	    }
	    else if (selector)
		    this._function = selector;
        return true;
    },
    execute:function () {
        if (this._callFunc != null)
            this._callFunc.call(this._selectorTarget, this.target, this._data);
        else if(this._function)
            this._function.call(null, this.target);
    },
    update:function (dt) {
        this.execute();
    },
    getTargetCallback:function () {
        return this._selectorTarget;
    },
    setTargetCallback:function (sel) {
        if (sel != this._selectorTarget) {
            if (this._selectorTarget)
                this._selectorTarget = null;
            this._selectorTarget = sel;
        }
    },
    clone:function(){
       var action = new cc.CallFunc();
        if(this._selectorTarget){
             action.initWithFunction(this._callFunc,  this._selectorTarget, this._data)
        }else if(this._function){
             action.initWithFunction(this._function);
        }
        return action;
    }
});
cc.callFunc = function (selector, selectorTarget, data) {
    return new cc.CallFunc(selector, selectorTarget, data);
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig:0,
    _centerYOrig:0,
    _centerZOrig:0,
    _eyeXOrig:0,
    _eyeYOrig:0,
    _eyeZOrig:0,
    _upXOrig:0,
    _upYOrig:0,
    _upZOrig:0,
    ctor:function(){
        var _t = this;
        cc.ActionInterval.prototype.ctor.call(_t);
        _t._centerXOrig=0;
        _t._centerYOrig=0;
        _t._centerZOrig=0;
        _t._eyeXOrig=0;
        _t._eyeYOrig=0;
        _t._eyeZOrig=0;
        _t._upXOrig=0;
        _t._upYOrig=0;
        _t._upZOrig=0;
    },
    startWithTarget:function (target) {
        var _t = this;
        cc.ActionInterval.prototype.startWithTarget.call(_t, target);
        var camera = target.getCamera();
        var centerXYZ = camera.getCenter();
        _t._centerXOrig = centerXYZ.x;
        _t._centerYOrig = centerXYZ.y;
        _t._centerZOrig = centerXYZ.z;
        var eyeXYZ = camera.getEye();
        _t._eyeXOrig = eyeXYZ.x;
        _t._eyeYOrig = eyeXYZ.y;
        _t._eyeZOrig = eyeXYZ.z;
        var upXYZ = camera.getUp();
        _t._upXOrig = upXYZ.x;
        _t._upYOrig = upXYZ.y;
        _t._upZOrig = upXYZ.z;
    },
    clone:function(){
       return new cc.ActionCamera();
    },
    reverse:function () {
        return new cc.ReverseTime(this);
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0.0,
    _deltaRadius: 0.0,
    _angleZ: 0.0,
    _deltaAngleZ: 0.0,
    _angleX: 0.0,
    _deltaAngleX: 0.0,
    _radZ: 0.0,
    _radDeltaZ: 0.0,
    _radX: 0.0,
    _radDeltaX: 0.0,
    ctor:function(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX){
        cc.ActionCamera.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX);
    },
    initWithDuration:function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            var _t = this;
            _t._radius = radius;
            _t._deltaRadius = deltaRadius;
            _t._angleZ = angleZ;
            _t._deltaAngleZ = deltaAngleZ;
            _t._angleX = angleX;
            _t._deltaAngleX = deltaAngleX;
            _t._radDeltaZ = cc.degreesToRadians(deltaAngleZ);
            _t._radDeltaX = cc.degreesToRadians(deltaAngleX);
            return true;
        }
        return false;
    },
    sphericalRadius:function () {
        var newRadius, zenith, azimuth;
        var camera = this.target.getCamera();
        var eyeXYZ = camera.getEye();
        var centerXYZ = camera.getCenter();
        var x = eyeXYZ.x - centerXYZ.x, y = eyeXYZ.y - centerXYZ.y, z = eyeXYZ.z - centerXYZ.z;
        var r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
        var s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if (s === 0.0)
            s = cc.FLT_EPSILON;
        if (r === 0.0)
            r = cc.FLT_EPSILON;
        zenith = Math.acos(z / r);
        if (x < 0)
            azimuth = Math.PI - Math.asin(y / s);
        else
            azimuth = Math.asin(y / s);
        newRadius = r / cc.Camera.getZEye();
        return {newRadius:newRadius, zenith:zenith, azimuth:azimuth};
    },
    startWithTarget:function (target) {
        var _t = this;
        cc.ActionInterval.prototype.startWithTarget.call(_t, target);
        var retValue = _t.sphericalRadius();
        if (isNaN(_t._radius))
            _t._radius = retValue.newRadius;
        if (isNaN(_t._angleZ))
            _t._angleZ = cc.radiansToDegrees(retValue.zenith);
        if (isNaN(_t._angleX))
            _t._angleX = cc.radiansToDegrees(retValue.azimuth);
        _t._radZ = cc.degreesToRadians(_t._angleZ);
        _t._radX = cc.degreesToRadians(_t._angleX);
    },
    clone:function(){
        var a = new cc.OrbitCamera(), _t = this;
        a.initWithDuration(_t._duration, _t._radius, _t._deltaRadius, _t._angleZ, _t._deltaAngleZ, _t._angleX, _t._deltaAngleX);
        return a;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var r = (this._radius + this._deltaRadius * dt) * cc.Camera.getZEye();
        var za = this._radZ + this._radDeltaZ * dt;
        var xa = this._radX + this._radDeltaX * dt;
        var i = Math.sin(za) * Math.cos(xa) * r + this._centerXOrig;
        var j = Math.sin(za) * Math.sin(xa) * r + this._centerYOrig;
        var k = Math.cos(za) * r + this._centerZOrig;
        this.target.getCamera().setEye(i, j, k);
        this.target.setNodeDirty();
    }
});
cc.orbitCamera = function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    return new cc.OrbitCamera(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX);
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner:null,
    ctor: function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.ActionEase.initWithAction(): action must be non nil";
        if (this.initWithDuration(action.getDuration())) {
            this._inner = action;
            return true;
        }
        return false;
    },
    clone:function(){
       var action = new cc.ActionEase();
        action.initWithAction(this._inner.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._inner.startWithTarget(this.target);
    },
    stop:function () {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this);
    },
    update:function (dt) {
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.ActionEase(this._inner.reverse());
    },
    getInnerAction:function(){
       return this._inner;
    }
});
cc.actionEase = function (action) {
    return new cc.ActionEase(action);
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate:0,
    ctor: function(action, rate){
        cc.ActionEase.prototype.ctor.call(this);
		rate !== undefined && this.initWithAction(action, rate);
    },
    setRate:function (rate) {
        this._rate = rate;
    },
    getRate:function () {
        return this._rate;
    },
    initWithAction:function (action, rate) {
        if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
            this._rate = rate;
            return true;
        }
        return false;
    },
    clone:function(){
        var action = new cc.EaseRateAction();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    },
    reverse:function () {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
    }
});
cc.easeRateAction = function (action, rate) {
    return new cc.EaseRateAction(action, rate);
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update:function (dt) {
        this._inner.update(Math.pow(dt, this._rate));
    },
    reverse:function () {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
    },
    clone:function(){
        var action = new cc.EaseIn();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    }
});
cc.EaseIn.create = function (action, rate) {
    return new cc.EaseIn(action, rate);
};
cc.easeIn = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            return Math.pow(dt, this._rate);
        },
        reverse: function(){
            return cc.easeIn(1 / this._rate);
        }
    };
};
cc.EaseOut = cc.EaseRateAction.extend({
    update:function (dt) {
        this._inner.update(Math.pow(dt, 1 / this._rate));
    },
    reverse:function () {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
    },
    clone:function(){
        var action = new cc.EaseOut();
        action.initWithAction(this._inner.clone(),this._rate);
        return action;
    }
});
cc.EaseOut.create = function (action, rate) {
    return new cc.EaseOut(action, rate);
};
cc.easeOut = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            return Math.pow(dt, 1 / this._rate);
        },
        reverse: function(){
            return cc.easeOut(1 / this._rate)
        }
    };
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update:function (dt) {
        dt *= 2;
        if (dt < 1)
            this._inner.update(0.5 * Math.pow(dt, this._rate));
        else
            this._inner.update(1.0 - 0.5 * Math.pow(2 - dt, this._rate));
    },
    clone:function(){
        var action = new cc.EaseInOut();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    },
    reverse:function () {
        return new cc.EaseInOut(this._inner.reverse(), this._rate);
    }
});
cc.EaseInOut.create = function (action, rate) {
    return new cc.EaseInOut(action, rate);
};
cc.easeInOut = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            dt *= 2;
            if (dt < 1)
                return 0.5 * Math.pow(dt, this._rate);
            else
                return 1.0 - 0.5 * Math.pow(2 - dt, this._rate);
        },
        reverse: function(){
            return cc.easeInOut(this._rate);
        }
    };
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update:function (dt) {
        this._inner.update(dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1)));
    },
    reverse:function () {
        return new cc.EaseExponentialOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialIn.create = function (action) {
    return new cc.EaseExponentialIn(action);
};
cc._easeExponentialInObj = {
    easing: function(dt){
        return dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1));
    },
    reverse: function(){
        return cc._easeExponentialOutObj;
    }
};
cc.easeExponentialIn = function(){
    return cc._easeExponentialInObj;
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update:function (dt) {
        this._inner.update(dt == 1 ? 1 : (-(Math.pow(2, -10 * dt)) + 1));
    },
    reverse:function () {
        return new cc.EaseExponentialIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialOut.create = function (action) {
    return new cc.EaseExponentialOut(action);
};
cc._easeExponentialOutObj = {
    easing: function(dt){
        return dt == 1 ? 1 : (-(Math.pow(2, -10 * dt)) + 1);
    },
    reverse: function(){
        return cc._easeExponentialInObj;
    }
};
cc.easeExponentialOut = function(){
    return cc._easeExponentialOutObj;
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update:function (dt) {
        if( dt != 1 && dt !== 0) {
            dt *= 2;
            if (dt < 1)
                dt = 0.5 * Math.pow(2, 10 * (dt - 1));
            else
                dt = 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
        }
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseExponentialInOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialInOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialInOut.create = function (action) {
    return new cc.EaseExponentialInOut(action);
};
cc._easeExponentialInOutObj = {
    easing: function(dt){
        if( dt !== 1 && dt !== 0) {
            dt *= 2;
            if (dt < 1)
                return 0.5 * Math.pow(2, 10 * (dt - 1));
            else
                return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
        }
        return dt;
    },
    reverse: function(){
        return cc._easeExponentialInOutObj;
    }
};
cc.easeExponentialInOut = function(){
    return cc._easeExponentialInOutObj;
};
cc.EaseSineIn = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseSineOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseSineIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseSineIn.create = function (action) {
    return new cc.EaseSineIn(action);
};
cc._easeSineInObj = {
    easing: function(dt){
        return (dt===0 || dt===1) ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
    },
    reverse: function(){
        return cc._easeSineOutObj;
    }
};
cc.easeSineIn = function(){
    return cc._easeSineInObj;
};
cc.EaseSineOut = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : Math.sin(dt * Math.PI / 2);
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseSineIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseSineOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseSineOut.create = function (action) {
    return new cc.EaseSineOut(action);
};
cc._easeSineOutObj = {
    easing: function(dt){
        return (dt===0 || dt==1) ? dt : Math.sin(dt * Math.PI / 2);
    },
    reverse: function(){
        return cc._easeSineInObj;
    }
};
cc.easeSineOut = function(){
    return cc._easeSineOutObj;
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
        this._inner.update(dt);
    },
    clone:function(){
        var action = new cc.EaseSineInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseSineInOut(this._inner.reverse());
    }
});
cc.EaseSineInOut.create = function (action) {
    return new cc.EaseSineInOut(action);
};
cc._easeSineInOutObj = {
    easing: function(dt){
        return (dt === 0 || dt === 1) ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
    },
    reverse: function(){
        return cc._easeSineInOutObj;
    }
};
cc.easeSineInOut = function(){
    return cc._easeSineInOutObj;
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor:function(action, period){
        cc.ActionEase.prototype.ctor.call(this);
		action && this.initWithAction(action, period);
    },
    getPeriod:function () {
        return this._period;
    },
    setPeriod:function (period) {
        this._period = period;
    },
    initWithAction:function (action, period) {
        cc.ActionEase.prototype.initWithAction.call(this, action);
        this._period = (period == null) ? 0.3 : period;
        return true;
    },
    reverse:function () {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null;
    },
    clone:function(){
        var action = new cc.EaseElastic();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElastic.create = function (action, period) {
    return new cc.EaseElastic(action, period);
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        if (dt === 0 || dt === 1) {
            newT = dt;
        } else {
            var s = this._period / 4;
            dt = dt - 1;
            newT = -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period);
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticIn();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticIn.create = function (action, period) {
    return new cc.EaseElasticIn(action, period);
};
cc._easeElasticInObj = {
   easing:function(dt){
       if (dt === 0 || dt === 1)
           return dt;
       dt = dt - 1;
       return -Math.pow(2, 10 * dt) * Math.sin((dt - (0.3 / 4)) * Math.PI * 2 / 0.3);
   },
    reverse:function(){
        return cc._easeElasticOutObj;
    }
};
cc.easeElasticIn = function (period) {
    if(period && period !== 0.3){
        return {
            _period: period,
            easing: function (dt) {
                if (dt === 0 || dt === 1)
                    return dt;
                dt = dt - 1;
                return -Math.pow(2, 10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period);
            },
            reverse:function () {
                return cc.easeElasticOut(this._period);
            }
        };
    }
    return cc._easeElasticInObj;
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        if (dt === 0 || dt == 1) {
            newT = dt;
        } else {
            var s = this._period / 4;
            newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period) + 1;
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticOut.create = function (action, period) {
    return new cc.EaseElasticOut(action, period);
};
cc._easeElasticOutObj = {
    easing: function (dt) {
        return (dt === 0 || dt === 1) ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - (0.3 / 4)) * Math.PI * 2 / 0.3) + 1;
    },
    reverse:function(){
        return cc._easeElasticInObj;
    }
};
cc.easeElasticOut = function (period) {
    if(period && period !== 0.3){
        return {
            _period: period,
            easing: function (dt) {
                return (dt === 0 || dt === 1) ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period) + 1;
            },
            reverse:function(){
                return cc.easeElasticIn(this._period);
            }
        };
    }
    return cc._easeElasticOutObj;
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        var locPeriod = this._period;
        if (dt === 0 || dt == 1) {
            newT = dt;
        } else {
            dt = dt * 2;
            if (!locPeriod)
                locPeriod = this._period = 0.3 * 1.5;
            var s = locPeriod / 4;
            dt = dt - 1;
            if (dt < 0)
                newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
            else
                newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1;
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticInOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticInOut.create = function (action, period) {
    return new cc.EaseElasticInOut(action, period);
};
cc.easeElasticInOut = function (period) {
    period = period || 0.3;
    return {
        _period: period,
        easing: function (dt) {
            var newT = 0;
            var locPeriod = this._period;
            if (dt === 0 || dt === 1) {
                newT = dt;
            } else {
                dt = dt * 2;
                if (!locPeriod)
                    locPeriod = this._period = 0.3 * 1.5;
                var s = locPeriod / 4;
                dt = dt - 1;
                if (dt < 0)
                    newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
                else
                    newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1;
            }
            return newT;
        },
        reverse: function(){
            return cc.easeElasticInOut(this._period);
        }
    };
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime:function (time1) {
        if (time1 < 1 / 2.75) {
            return 7.5625 * time1 * time1;
        } else if (time1 < 2 / 2.75) {
            time1 -= 1.5 / 2.75;
            return 7.5625 * time1 * time1 + 0.75;
        } else if (time1 < 2.5 / 2.75) {
            time1 -= 2.25 / 2.75;
            return 7.5625 * time1 * time1 + 0.9375;
        }
        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + 0.984375;
    },
    clone:function(){
        var action = new cc.EaseBounce();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBounce(this._inner.reverse());
    }
});
cc.EaseBounce.create = function (action) {
    return new cc.EaseBounce(action);
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = 1 - this.bounceTime(1 - dt);
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseBounceOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBounceIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBounceIn.create = function (action) {
    return new cc.EaseBounceIn(action);
};
cc._bounceTime = function (time1) {
    if (time1 < 1 / 2.75) {
        return 7.5625 * time1 * time1;
    } else if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + 0.75;
    } else if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + 0.9375;
    }
    time1 -= 2.625 / 2.75;
    return 7.5625 * time1 * time1 + 0.984375;
};
cc._easeBounceInObj = {
    easing: function(dt){
        return 1 - cc._bounceTime(1 - dt);
    },
    reverse: function(){
        return cc._easeBounceOutObj;
    }
};
cc.easeBounceIn = function(){
    return cc._easeBounceInObj;
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = this.bounceTime(dt);
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseBounceIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBounceOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBounceOut.create = function (action) {
    return new cc.EaseBounceOut(action);
};
cc._easeBounceOutObj = {
    easing: function(dt){
        return cc._bounceTime(dt);
    },
    reverse:function () {
        return cc._easeBounceInObj;
    }
};
cc.easeBounceOut = function(){
    return cc._easeBounceOutObj;
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = 0;
        if (dt < 0.5) {
            dt = dt * 2;
            newT = (1 - this.bounceTime(1 - dt)) * 0.5;
        } else {
            newT = this.bounceTime(dt * 2 - 1) * 0.5 + 0.5;
        }
        this._inner.update(newT);
    },
    clone:function(){
        var action = new cc.EaseBounceInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBounceInOut(this._inner.reverse());
    }
});
cc.EaseBounceInOut.create = function (action) {
    return new cc.EaseBounceInOut(action);
};
cc._easeBounceInOutObj = {
    easing: function (time1) {
        var newT;
        if (time1 < 0.5) {
            time1 = time1 * 2;
            newT = (1 - cc._bounceTime(1 - time1)) * 0.5;
        } else {
            newT = cc._bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
        }
        return newT;
    },
    reverse: function(){
        return cc._easeBounceInOutObj;
    }
};
cc.easeBounceInOut = function(){
    return cc._easeBounceInOutObj;
};
cc.EaseBackIn = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158;
        dt = dt===0 || dt==1 ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseBackOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBackIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBackIn.create = function (action) {
    return new cc.EaseBackIn(action);
};
cc._easeBackInObj = {
    easing: function (time1) {
        var overshoot = 1.70158;
        return (time1===0 || time1===1) ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
    },
    reverse: function(){
        return cc._easeBackOutObj;
    }
};
cc.easeBackIn = function(){
    return cc._easeBackInObj;
};
cc.EaseBackOut = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158;
        dt = dt - 1;
        this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) + 1);
    },
    reverse:function () {
        return new cc.EaseBackIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBackOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBackOut.create = function (action) {
    return new cc.EaseBackOut(action);
};
cc._easeBackOutObj = {
    easing: function (time1) {
        var overshoot = 1.70158;
        time1 = time1 - 1;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
    },
    reverse: function(){
        return cc._easeBackInObj;
    }
};
cc.easeBackOut = function(){
    return cc._easeBackOutObj;
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158 * 1.525;
        dt = dt * 2;
        if (dt < 1) {
            this._inner.update((dt * dt * ((overshoot + 1) * dt - overshoot)) / 2);
        } else {
            dt = dt - 2;
            this._inner.update((dt * dt * ((overshoot + 1) * dt + overshoot)) / 2 + 1);
        }
    },
    clone:function(){
        var action = new cc.EaseBackInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBackInOut(this._inner.reverse());
    }
});
cc.EaseBackInOut.create = function (action) {
    return new cc.EaseBackInOut(action);
};
cc._easeBackInOutObj = {
    easing: function (time1) {
        var overshoot = 1.70158 * 1.525;
        time1 = time1 * 2;
        if (time1 < 1) {
            return (time1 * time1 * ((overshoot + 1) * time1 - overshoot)) / 2;
        } else {
            time1 = time1 - 2;
            return (time1 * time1 * ((overshoot + 1) * time1 + overshoot)) / 2 + 1;
        }
    },
    reverse: function(){
        return cc._easeBackInOutObj;
    }
};
cc.easeBackInOut = function(){
    return cc._easeBackInOutObj;
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(action){
        cc.ActionEase.prototype.ctor.call(this, action);
    },
    _updateTime: function(a, b, c, d, t){
        return (Math.pow(1-t,3) * a + 3*t*(Math.pow(1-t,2))*b + 3*Math.pow(t,2)*(1-t)*c + Math.pow(t,3)*d );
    },
    update: function(dt){
        var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, dt);
        this._inner.update(t);
    },
    clone: function(){
        var action = new cc.EaseBezierAction();
        action.initWithAction(this._inner.clone());
        action.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return action;
    },
    reverse: function(){
        var action = new cc.EaseBezierAction(this._inner.reverse());
        action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return action;
    },
    setBezierParamer: function(p0, p1, p2, p3){
        this._p0 = p0 || 0;
        this._p1 = p1 || 0;
        this._p2 = p2 || 0;
        this._p3 = p3 || 0;
    }
});
cc.EaseBezierAction.create = function(action){
    return new cc.EaseBezierAction(action);
};
cc.easeBezierAction = function(p0, p1, p2, p3){
    return {
        easing: function(time){
            return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time);
        },
        reverse: function(){
            return cc.easeBezierAction(p3, p2, p1, p0);
        }
    };
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return Math.pow(time, 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionIn(this._inner.reverse());
    }
});
cc.EaseQuadraticActionIn.create = function(action){
    return new cc.EaseQuadraticActionIn(action);
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionIn;
    }
};
cc.easeQuadraticActionIn = function(){
    return cc._easeQuadraticActionIn;
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        return -time*(time-2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionOut();
        action.initWithAction();
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionOut(this._inner.reverse());
    }
});
cc.EaseQuadraticActionOut.create = function(action){
    return new cc.EaseQuadraticActionOut(action);
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionOut;
    }
};
cc.easeQuadraticActionOut = function(){
    return cc._easeQuadraticActionOut;
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        var resultTime = time;
        time *= 2;
        if(time < 1){
            resultTime = time * time * 0.5;
        }else{
            --time;
            resultTime = -0.5 * ( time * ( time - 2 ) - 1)
        }
        return resultTime;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuadraticActionInOut.create = function(action){
    return new cc.EaseQuadraticActionInOut(action);
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionInOut;
    }
};
cc.easeQuadraticActionInOut = function(){
    return cc._easeQuadraticActionInOut;
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionIn(this._inner.reverse());
    }
});
cc.EaseQuarticActionIn.create = function(action){
    return new cc.EaseQuarticActionIn(action);
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionIn;
    }
};
cc.easeQuarticActionIn = function(){
    return cc._easeQuarticActionIn;
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -= 1;
        return -(time * time * time * time - 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionOut(this._inner.reverse());
    }
});
cc.EaseQuarticActionOut.create = function(action){
    return new cc.EaseQuarticActionOut(action);
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionOut;
    }
};
cc.easeQuarticActionOut = function(){
    return cc._easeQuarticActionOut;
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time * time;
        time -= 2;
        return -0.5 * (time * time * time * time - 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuarticActionInOut.create = function(action){
    return new cc.EaseQuarticActionInOut(action);
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionInOut;
    }
};
cc.easeQuarticActionInOut = function(){
    return cc._easeQuarticActionInOut;
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionIn(this._inner.reverse());
    }
});
cc.EaseQuinticActionIn.create = function(action){
    return new cc.EaseQuinticActionIn(action);
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionIn;
    }
};
cc.easeQuinticActionIn = function(){
    return cc._easeQuinticActionIn;
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -=1;
        return (time * time * time * time * time + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionOut(this._inner.reverse());
    }
});
cc.EaseQuinticActionOut.create = function(action){
    return new cc.EaseQuinticActionOut(action);
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionOut;
    }
};
cc.easeQuinticActionOut = function(){
    return cc._easeQuinticActionOut;
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time * time * time;
        time -= 2;
        return 0.5 * (time * time * time * time * time + 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuinticActionInOut.create = function(action){
    return new cc.EaseQuinticActionInOut(action);
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionInOut;
    }
};
cc.easeQuinticActionInOut = function(){
    return cc._easeQuinticActionInOut;
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return -1 * (Math.sqrt(1 - time * time) - 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionIn(this._inner.reverse());
    }
});
cc.EaseCircleActionIn.create = function(action){
    return new cc.EaseCircleActionIn(action);
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionIn;
    }
};
cc.easeCircleActionIn = function(){
    return cc._easeCircleActionIn;
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time - 1;
        return Math.sqrt(1 - time * time);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionOut(this._inner.reverse());
    }
});
cc.EaseCircleActionOut.create = function(action){
    return new cc.EaseCircleActionOut(action);
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionOut;
    }
};
cc.easeCircleActionOut = function(){
    return cc._easeCircleActionOut;
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time * 2;
        if (time < 1)
            return -0.5 * (Math.sqrt(1 - time * time) - 1);
        time -= 2;
        return 0.5 * (Math.sqrt(1 - time * time) + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionInOut(this._inner.reverse());
    }
});
cc.EaseCircleActionInOut.create = function(action){
    return new cc.EaseCircleActionInOut(action);
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionInOut;
    }
};
cc.easeCircleActionInOut = function(){
    return cc._easeCircleActionInOut;
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionIn(this._inner.reverse());
    }
});
cc.EaseCubicActionIn.create = function(action){
    return new cc.EaseCubicActionIn(action);
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionIn;
    }
};
cc.easeCubicActionIn = function(){
    return cc._easeCubicActionIn;
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -= 1;
        return (time * time * time + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionOut(this._inner.reverse());
    }
});
cc.EaseCubicActionOut.create = function(action){
    return new cc.EaseCubicActionOut(action);
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionOut;
    }
};
cc.easeCubicActionOut = function(){
    return cc._easeCubicActionOut;
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time;
        time -= 2;
        return 0.5 * (time * time * time + 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionInOut(this._inner.reverse());
    }
});
cc.EaseCubicActionInOut.create = function(action){
    return new cc.EaseCubicActionInOut(action);
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionInOut;
    }
};
cc.easeCubicActionInOut = function(){
    return cc._easeCubicActionInOut;
};
cc.cardinalSplineAt = function (p0, p1, p2, p3, tension, t) {
    var t2 = t * t;
    var t3 = t2 * t;
    var s = (1 - tension) / 2;
    var b1 = s * ((-t3 + (2 * t2)) - t);
    var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
    var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
    var b4 = s * (t3 - t2);
    var x = (p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4);
    var y = (p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4);
    return cc.p(x, y);
};
cc.reverseControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = controlPoints.length - 1; i >= 0; i--) {
        newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    }
    return newArray;
};
cc.cloneControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = 0; i < controlPoints.length; i++)
        newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    return newArray;
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function (controlPoints, pos) {
    var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
    return controlPoints[p];
};
cc.reverseControlPointsInline = function (controlPoints) {
    var len = controlPoints.length;
    var mid = 0 | (len / 2);
    for (var i = 0; i < mid; ++i) {
        var temp = controlPoints[i];
        controlPoints[i] = controlPoints[len - i - 1];
        controlPoints[len - i - 1] = temp;
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points:null,
    _deltaT:0,
    _tension:0,
    _previousPosition:null,
    _accumulatedDiff:null,
    ctor: function (duration, points, tension) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
		tension !== undefined && this.initWithDuration(duration, points, tension);
    },
    initWithDuration:function (duration, points, tension) {
        if(!points || points.length == 0)
            throw "Invalid configuration. It must at least have one control point";
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this.setPoints(points);
            this._tension = tension;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.CardinalSplineTo();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var p, lt;
        var ps = this._points;
        if (dt == 1) {
            p = ps.length - 1;
            lt = 1;
        } else {
            var locDT = this._deltaT;
            p = 0 | (dt / locDT);
            lt = (dt - locDT * p) / locDT;
        }
        var newPos = cc.cardinalSplineAt(
            cc.getControlPointAt(ps, p - 1),
            cc.getControlPointAt(ps, p - 0),
            cc.getControlPointAt(ps, p + 1),
            cc.getControlPointAt(ps, p + 2),
            this._tension, lt);
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var tempX, tempY;
            tempX = this.target.getPositionX() - this._previousPosition.x;
            tempY = this.target.getPositionY() - this._previousPosition.y;
            if (tempX != 0 || tempY != 0) {
                var locAccDiff = this._accumulatedDiff;
                tempX = locAccDiff.x + tempX;
                tempY = locAccDiff.y + tempY;
                locAccDiff.x = tempX;
                locAccDiff.y = tempY;
                newPos.x += tempX;
                newPos.y += tempY;
            }
        }
        this.updatePosition(newPos);
    },
    reverse:function () {
        var reversePoints = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
    },
    updatePosition:function (newPos) {
        this.target.setPosition(newPos);
        this._previousPosition = newPos;
    },
    getPoints:function () {
        return this._points;
    },
    setPoints:function (points) {
        this._points = points;
    }
});
cc.cardinalSplineTo = function (duration, points, tension) {
    return new cc.CardinalSplineTo(duration, points, tension);
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition:null,
    ctor:function (duration, points, tension) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
		tension !== undefined && this.initWithDuration(duration, points, tension);
    },
    startWithTarget:function (target) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
        this._startPosition.x = target.getPositionX();
        this._startPosition.y = target.getPositionY();
    },
    reverse:function () {
        var copyConfig = this._points.slice();
        var current;
        var p = copyConfig[0];
        for (var i = 1; i < copyConfig.length; ++i) {
            current = copyConfig[i];
            copyConfig[i] = cc.pSub(current, p);
            p = current;
        }
        var reverseArray = cc.reverseControlPoints(copyConfig);
        p = reverseArray[ reverseArray.length - 1 ];
        reverseArray.pop();
        p.x = -p.x;
        p.y = -p.y;
        reverseArray.unshift(p);
        for (var i = 1; i < reverseArray.length; ++i) {
            current = reverseArray[i];
            current.x = -current.x;
            current.y = -current.y;
            current.x += p.x;
            current.y += p.y;
            reverseArray[i] = current;
            p = current;
        }
        return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
    },
    updatePosition:function (newPos) {
        var pos = this._startPosition;
        var posX = newPos.x + pos.x;
        var posY = newPos.y + pos.y;
	    this._previousPosition.x = posX;
	    this._previousPosition.y = posY;
	    this.target.setPosition(posX, posY);
    },
    clone:function () {
        var a = new cc.CardinalSplineBy();
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a;
    }
});
cc.cardinalSplineBy = function (duration, points, tension) {
    return new cc.CardinalSplineBy(duration, points, tension);
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
	ctor: function(dt, points) {
		points && this.initWithDuration(dt, points);
	},
    initWithDuration:function (dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5);
    },
    clone:function () {
        var action = new cc.CatmullRomTo();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return action;
    }
});
cc.catmullRomTo = function (dt, points) {
    return new cc.CatmullRomTo(dt, points);
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
	ctor: function(dt, points) {
		cc.CardinalSplineBy.prototype.ctor.call(this);
		points && this.initWithDuration(dt, points);
	},
    initWithDuration:function (dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5);
    },
    clone:function () {
        var action = new cc.CatmullRomBy();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return action;
    }
});
cc.catmullRomBy = function (dt, points) {
    return new cc.CatmullRomBy(dt, points);
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction:function(value, key){}
});
cc.ActionTween = cc.ActionInterval.extend({
    key:"",
    from:0,
    to:0,
    delta:0,
    ctor:function(duration, key, from, to){
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
		to !== undefined && this.initWithDuration(duration, key, from, to);
    },
    initWithDuration:function (duration, key, from, to) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this.key = key;
            this.to = to;
            this.from = from;
            return true;
        }
        return false;
    },
    startWithTarget:function (target) {
        if(!target || !target.updateTweenAction)
            throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this.delta = this.to - this.from;
    },
    update:function (dt) {
        this.target.updateTweenAction(this.to - this.delta * (1 - dt), this.key);
    },
    reverse:function () {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from);
    },
    clone:function(){
        var action = new cc.ActionTween();
        action.initWithDuration(this._duration, this.key, this.from, this.to);
        return action;
    }
});
cc.actionTween = function (duration, key, from, to) {
    return new cc.ActionTween(duration, key, from, to);
};
cc.ActionTween.create = cc.actionTween;
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,//"none" or "metadata" or "auto" or "" (empty string) or empty    TODO not used here
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: false,
        _stopped: true,
        _loadState: -1,//-1 : not loaded, 0 : waiting, 1 : loaded, -2 : load failed
        ctor: function (src) {
            var self = this;
            self._events = {};
            self.src = src;
            if (_ctx["createGain"])
                self._volumeNode = _ctx["createGain"]();
            else
                self._volumeNode = _ctx["createGainNode"]();
            self._onSuccess1 = self._onSuccess.bind(this);
            self._onError1 = self._onError.bind(this);
        },
        _play: function (offset) {
            var self = this;
            var sourceNode = self._sourceNode = _ctx["createBufferSource"]();
            var volumeNode = self._volumeNode;
            offset = offset || 0;
            sourceNode.buffer = self._buffer;
            volumeNode["gain"].value = self._volume;
            sourceNode["connect"](volumeNode);
            volumeNode["connect"](_ctx["destination"]);
            sourceNode.loop = self._loop;
            sourceNode._stopped = false;
            if(!sourceNode["playbackState"]){
                sourceNode["onended"] = function(){
                    this._stopped = true;
                };
            }
            self._paused = false;
            self._stopped = false;
            if (sourceNode.start) {
                sourceNode.start(0, offset);
            } else if (sourceNode["noteGrainOn"]) {
                var duration = sourceNode.buffer.duration;
                if (self.loop) {
                    sourceNode["noteGrainOn"](0, offset, duration);
                } else {
                    sourceNode["noteGrainOn"](0, offset, duration - offset);
                }
            } else {
                sourceNode["noteOn"](0);
            }
            self._pauseTime = 0;
        },
        _stop: function () {
            var self = this, sourceNode = self._sourceNode;
            if (self._stopped)
                return;
            if (sourceNode.stop)
                sourceNode.stop(0);
            else
                sourceNode.noteOff(0);
            self._stopped = true;
        },
        play: function () {
            var self = this;
            if (self._loadState == -1) {
                self._loadState = 0;
                return;
            } else if (self._loadState != 1)
                return;
            var sourceNode = self._sourceNode;
            if (!self._stopped && sourceNode && (sourceNode["playbackState"] == 2 || !sourceNode._stopped))
                return;//playing
            self.startTime = _ctx.currentTime;
            this._play(0);
        },
        pause: function () {
            this._pauseTime = _ctx.currentTime;
            this._paused = true;
            this._stop();
        },
        resume: function () {
            var self = this;
            if (self._paused) {
                var offset = self._buffer ? (self._pauseTime - self.startTime) % self._buffer.duration : 0;
                this._play(offset);
            }
        },
        stop: function () {
            this._pauseTime = 0;
            this._paused = false;
            this._stop();
        },
        load: function () {
            var self = this;
            if (self._loadState == 1)
                return;
            self._loadState = -1;//not loaded
            self.played = false;
            self.ended = true;
            var request = new XMLHttpRequest();
            request.open("GET", self.src, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                _ctx["decodeAudioData"](request.response, self._onSuccess1, self._onError1);
            };
            request.send();
        },
        addEventListener: function (eventName, event) {
            this._events[eventName] = event.bind(this);
        },
        removeEventListener: function (eventName) {
            delete this._events[eventName];
        },
        canplay: function () {
            return cc.sys._supportWebAudio;
        },
        _onSuccess: function (buffer) {
            var self = this;
            self._buffer = buffer;
            var success = self._events["success"], canplaythrough = self._events["canplaythrough"];
            if (success)
                success();
            if (canplaythrough)
                canplaythrough();
            if (self._loadState == 0 || self.autoplay == "autoplay" || self.autoplay == true)
                self._play();
            self._loadState = 1;//loaded
        },
        _onError: function () {
            var error = this._events["error"];
            if (error)
                error();
            this._loadState = -2;//load failed
        },
        cloneNode: function () {
            var self = this, obj = new cc.WebAudio(self.src);
            obj.volume = self.volume;
            obj._loadState = self._loadState;
            obj._buffer = self._buffer;
            if (obj._loadState == 0 || obj._loadState == -1)
                obj.load();
            return obj;
        }
    });
    var _p = cc.WebAudio.prototype;
    _p.loop;
    cc.defineGetterSetter(_p, "loop", function () {
        return this._loop;
    }, function (loop) {
        this._loop = loop;
        if (this._sourceNode)
            this._sourceNode.loop = loop;
    });
    _p.volume;
    cc.defineGetterSetter(_p, "volume", function () {
        return this._volume;
    }, function (volume) {
        this._volume = volume;
        this._volumeNode["gain"].value = volume;
    });
    _p.paused;
    cc.defineGetterSetter(_p, "paused", function () {
        return this._paused;
    });
    _p.ended;
    cc.defineGetterSetter(_p, "ended", function () {
        var sourceNode = this._sourceNode;
        if(this._paused)
           return false;
        if(this._stopped && !sourceNode)
            return true;
        if(sourceNode["playbackState"] == null)
            return sourceNode._stopped;
        else
            return sourceNode["playbackState"] == 3;
    });
    _p.played;
    cc.defineGetterSetter(_p, "played", function () {
        var sourceNode = this._sourceNode;
        return sourceNode && (sourceNode["playbackState"] == 2 || !sourceNode._stopped);
    });
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: false,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,//max count of audios that has same url
    _effectPauseCb: null,
    _playings: [],//only store when window is hidden
    ctor: function () {
        var self = this;
        self._soundSupported = cc._audioLoader._supportedAudioTypes.length > 0;
        if (self._effectPauseCb)
            self._effectPauseCb = self._effectPauseCb.bind(self);
    },
    willPlayMusic: function () {
        return false;
    },
    getEffectsVolume: function () {
        return this._effectsVolume;
    },
    playMusic: function (url, loop) {
        var self = this;
        if (!self._soundSupported)
            return;
        var audio = self._currMusic;
        if (audio)
            this._stopAudio(audio);
        if(cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS){
            audio = self._getAudioByUrl(url);
            self._currMusic = audio.cloneNode();
            self._currMusicPath = url;
        }else{
            if (url != self._currMusicPath) {
                audio = self._getAudioByUrl(url);
                self._currMusic = audio;
                self._currMusicPath = url;
            }
        }
        if (!self._currMusic)
            return;
        self._currMusic.loop = loop || false;
        self._playMusic(self._currMusic);
    },
    _getAudioByUrl: function (url) {
        var locLoader = cc.loader, audio = locLoader.getRes(url);
        if (!audio) {
            locLoader.load(url);
            audio = locLoader.getRes(url);
        }
        return audio;
    },
    _playMusic: function (audio) {
        if (!audio.ended) {
            if (audio.stop) {//cc.WebAudio
                audio.stop();
            } else {
                audio.pause();
                if (audio.readyState > 2)
                    audio.currentTime = 0;
            }
        }
        this._musicPlayState = 2;
        audio.play();
    },
    stopMusic: function (releaseData) {
        if (this._musicPlayState > 0) {
            var audio = this._currMusic;
            if (!audio) return;
            if (!this._stopAudio(audio))
                return;
            if (releaseData)
                cc.loader.release(this._currMusicPath);
            this._currMusic = null;
            this._currMusicPath = null;
            this._musicPlayState = 0;
        }
    },
    _stopAudio: function (audio) {
        if (audio && !audio.ended) {
            if (audio.stop) {//cc.WebAudio
                audio.stop();
            } else {
                audio.pause();
                if (audio.readyState > 2 && audio.duration && audio.duration != Infinity)
                    audio.currentTime = audio.duration;
            }
            return true;
        }
        return false;
    },
    pauseMusic: function () {
        if (this._musicPlayState == 2) {
            this._currMusic.pause();
            this._musicPlayState = 1;
        }
    },
    resumeMusic: function () {
        if (this._musicPlayState == 1) {
            var audio = this._currMusic;
            this._resumeAudio(audio);
            this._musicPlayState = 2;
        }
    },
    _resumeAudio: function (audio) {
        if (audio && !audio.ended) {
            if (audio.resume)
                audio.resume();//cc.WebAudio
            else
                audio.play();
        }
    },
    rewindMusic: function () {
        if (this._currMusic)
            this._playMusic(this._currMusic);
    },
    getMusicVolume: function () {
        return this._musicPlayState == 0 ? 0 : this._currMusic.volume;
    },
    setMusicVolume: function (volume) {
        if (this._musicPlayState > 0) {
            this._currMusic.volume = Math.min(Math.max(volume, 0), 1);
        }
    },
    isMusicPlaying: function () {
        return this._musicPlayState == 2 && this._currMusic && !this._currMusic.ended;
    },
    _getEffectList: function (url) {
        var list = this._audioPool[url];
        if (!list)
            list = this._audioPool[url] = [];
        return list;
    },
    _getEffect: function (url) {
        var self = this, audio;
        if (!self._soundSupported) return null;
        var effList = this._getEffectList(url);
        if(cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS){
            audio = this._getEffectAudio(effList, url);
        }else{
            for (var i = 0, li = effList.length; i < li; i++) {
                var eff = effList[i];
                if (eff.ended) {
                    audio = eff;
                    if (audio.readyState > 2)
                        audio.currentTime = 0;
                    if (window.chrome)
                        audio.load();
                    break;
                }
            }
            if (!audio) {
                audio = this._getEffectAudio(effList, url);
                audio && effList.push(audio);
            }
        }
        return audio;
    },
    _getEffectAudio: function(effList, url){
        var audio;
        if (effList.length >= this._maxAudioInstance) {
            cc.log("Error: " + url + " greater than " + this._maxAudioInstance);
            return null;
        }
        audio = this._getAudioByUrl(url);
        if (!audio)
            return null;
        audio = audio.cloneNode(true);
        if (this._effectPauseCb)
            cc._addEventListener(audio, "pause", this._effectPauseCb);
        audio.volume = this._effectsVolume;
        return audio;
    },
    playEffect: function (url, loop) {
        var audio = this._getEffect(url);
        if (!audio) return null;
        audio.loop = loop || false;
        audio.play();
        var audioId = this._audioID++;
        this._effects[audioId] = audio;
        return audioId;
    },
    setEffectsVolume: function (volume) {
        volume = this._effectsVolume = Math.min(Math.max(volume, 0), 1);
        var effects = this._effects;
        for (var key in effects) {
            effects[key].volume = volume;
        }
    },
    pauseEffect: function (audioID) {
        var audio = this._effects[audioID];
        if (audio && !audio.ended) {
            audio.pause();
        }
    },
    pauseAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            var eff = effects[key];
            if (!eff.ended) eff.pause();
        }
    },
    resumeEffect: function (effectId) {
        this._resumeAudio(this._effects[effectId])
    },
    resumeAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            this._resumeAudio(effects[key]);
        }
    },
    stopEffect: function (effectId) {
        this._stopAudio(this._effects[effectId]);
        delete this._effects[effectId];
    },
    stopAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            this._stopAudio(effects[key]);
            delete effects[key];
        }
    },
    unloadEffect: function (url) {
        var locLoader = cc.loader, locEffects = this._effects, effectList = this._getEffectList(url);
        locLoader.release(url);//release the resource in cc.loader first.
        if (effectList.length == 0) return;
        var realUrl = effectList[0].src;
        delete this._audioPool[url];
        for (var key in locEffects) {
            if (locEffects[key].src == realUrl) {
                this._stopAudio(locEffects[key]);
                delete locEffects[key];
            }
        }
    },
    end: function () {
        this.stopMusic();
        this.stopAllEffects();
    },
    _pausePlaying: function () {//in this function, do not change any status of audios
        var self = this, effects = self._effects, eff;
        for (var key in effects) {
            eff = effects[key];
            if (eff && !eff.ended && !eff.paused) {
                self._playings.push(eff);
                eff.pause();
            }
        }
        if (self.isMusicPlaying()) {
            self._playings.push(self._currMusic);
            self._currMusic.pause();
        }
    },
    _resumePlaying: function () {//in this function, do not change any status of audios
        var self = this, playings = this._playings;
        for (var i = 0, li = playings.length; i < li; i++) {
            self._resumeAudio(playings[i]);
        }
        playings.length = 0;
    }
});
if (!cc.sys._supportWebAudio && !cc.sys._supportMultipleAudio) {
    cc.AudioEngineForSingle = cc.AudioEngine.extend({
        _waitingEffIds: [],
        _pausedEffIds: [],
        _currEffect: null,
        _maxAudioInstance: 2,
        _effectCache4Single: {},//{url:audio},
        _needToResumeMusic: false,
        _expendTime4Music: 0,
        _isHiddenMode: false,
        _playMusic: function (audio) {
            this._stopAllEffects();
            this._super(audio);
        },
        resumeMusic: function () {
            var self = this;
            if (self._musicPlayState == 1) {
                self._stopAllEffects();
                self._needToResumeMusic = false;
                self._expendTime4Music = 0;
                self._super();
            }
        },
        playEffect: function (url, loop) {
            var self = this, currEffect = self._currEffect;
            var audio = loop ? self._getEffect(url) : self._getSingleEffect(url);
            if (!audio) return null;
            audio.loop = loop || false;
            var audioId = self._audioID++;
            self._effects[audioId] = audio;
            if (self.isMusicPlaying()) {
                self.pauseMusic();
                self._needToResumeMusic = true;
            }
            if (currEffect) {
                if (currEffect != audio) self._waitingEffIds.push(self._currEffectId);
                self._waitingEffIds.push(audioId);
                currEffect.pause();
            } else {
                self._currEffect = audio;
                self._currEffectId = audioId;
                audio.play();
            }
            return audioId;
        },
        pauseEffect: function (effectId) {
            cc.log("pauseEffect not supported in single audio mode!");
        },
        pauseAllEffects: function () {
            var self = this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds, currEffect = self._currEffect;
            if (!currEffect) return;
            for (var i = 0, li = waitings.length; i < li; i++) {
                pauseds.push(waitings[i]);
            }
            waitings.length = 0;//clear
            pauseds.push(self._currEffectId);
            currEffect.pause();
        },
        resumeEffect: function (effectId) {
            cc.log("resumeEffect not supported in single audio mode!");
        },
        resumeAllEffects: function () {
            var self = this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (self.isMusicPlaying()) {//if music is playing, pause it first
                self.pauseMusic();
                self._needToResumeMusic = true;
            }
            for (var i = 0, li = pauseds.length; i < li; i++) {//move pauseds to waitings
                waitings.push(pauseds[i]);
            }
            pauseds.length = 0;//clear
            if (!self._currEffect && waitings.length >= 0) {//is none currEff, resume the newest effect in waitings
                var effId = waitings.pop();
                var eff = self._effects[effId];
                if (eff) {
                    self._currEffectId = effId;
                    self._currEffect = eff;
                    self._resumeAudio(eff);
                }
            }
        },
        stopEffect: function (effectId) {
            var self = this, currEffect = self._currEffect, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (currEffect && this._currEffectId == effectId) {//if the eff to be stopped is currEff
                this._stopAudio(currEffect);
            } else {//delete from waitings or pauseds
                var index = waitings.indexOf(effectId);
                if (index >= 0) {
                    waitings.splice(index, 1);
                } else {
                    index = pauseds.indexOf(effectId);
                    if (index >= 0) pauseds.splice(index, 1);
                }
            }
        },
        stopAllEffects: function () {
            var self = this;
            self._stopAllEffects();
            if (!self._currEffect && self._needToResumeMusic) {//need to resume music
                self._resumeAudio(self._currMusic);
                self._musicPlayState = 2;
                self._needToResumeMusic = false;
                self._expendTime4Music = 0;
            }
        },
        unloadEffect: function (url) {
            var self = this, locLoader = cc.loader, locEffects = self._effects, effCache = self._effectCache4Single,
                effectList = self._getEffectList(url), currEffect = self._currEffect;
            locLoader.release(url);//release the resource in cc.loader first.
            if (effectList.length == 0 && !effCache[url]) return;
            var realUrl = effectList.length > 0 ? effectList[0].src : effCache[url].src;
            delete self._audioPool[url];
            delete effCache[url];
            for (var key in locEffects) {
                if (locEffects[key].src == realUrl) {
                    delete locEffects[key];
                }
            }
            if (currEffect && currEffect.src == realUrl) self._stopAudio(currEffect);//need to stop currEff
        },
        _getSingleEffect: function (url) {
            var self = this, audio = self._effectCache4Single[url], locLoader = cc.loader,
                waitings = self._waitingEffIds, pauseds = self._pausedEffIds, effects = self._effects;
            if (audio) {
                if (audio.readyState > 2)
                    audio.currentTime = 0;
            } else {
                audio = self._getAudioByUrl(url);
                if (!audio) return null;
                audio = audio.cloneNode(true);
                if (self._effectPauseCb)
                    cc._addEventListener(audio, "pause", self._effectPauseCb);
                audio.volume = self._effectsVolume;
                self._effectCache4Single[url] = audio;
            }
            for (var i = 0, li = waitings.length; i < li;) {//reset waitings
                if (effects[waitings[i]] == audio) {
                    waitings.splice(i, 1);
                } else
                    i++;
            }
            for (var i = 0, li = pauseds.length; i < li;) {//reset pauseds
                if (effects[pauseds[i]] == audio) {
                    pauseds.splice(i, 1);
                } else
                    i++;
            }
            audio._isToPlay = true;//custom flag
            return audio;
        },
        _stopAllEffects: function () {
            var self = this, currEffect = self._currEffect, audioPool = self._audioPool, sglCache = self._effectCache4Single,
                waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (!currEffect && waitings.length == 0 && pauseds.length == 0)
                return;
            for (var key in sglCache) {
                var eff = sglCache[key];
                if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                    eff.currentTime = eff.duration;
            }
            waitings.length = 0;
            pauseds.length = 0;
            for (var key in audioPool) {//reset audios in pool to be ended
                var list = audioPool[key];
                for (var i = 0, li = list.length; i < li; i++) {
                    var eff = list[i];
                    eff.loop = false;
                    if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                        eff.currentTime = eff.duration;
                }
            }
            if (currEffect) self._stopAudio(currEffect);
        },
        _effectPauseCb: function () {
            var self = this;
            if (self._isHiddenMode) return;//in this mode, return
            var currEffect = self._getWaitingEffToPlay();//get eff to play
            if (currEffect) {
                if (currEffect._isToPlay) {
                    delete currEffect._isToPlay;
                    currEffect.play();
                }
                else self._resumeAudio(currEffect);
            } else if (self._needToResumeMusic) {
                var currMusic = self._currMusic;
                if (currMusic.readyState > 2 && currMusic.duration && currMusic.duration != Infinity) {//calculate current time
                    var temp = currMusic.currentTime + self._expendTime4Music;
                    temp = temp - currMusic.duration * ((temp / currMusic.duration) | 0);
                    currMusic.currentTime = temp;
                }
                self._expendTime4Music = 0;
                self._resumeAudio(currMusic);
                self._musicPlayState = 2;
                self._needToResumeMusic = false;
            }
        },
        _getWaitingEffToPlay: function () {
            var self = this, waitings = self._waitingEffIds, effects = self._effects,
                currEffect = self._currEffect;
            var expendTime = currEffect ? currEffect.currentTime - (currEffect.startTime || 0) : 0;
            self._expendTime4Music += expendTime;
            while (true) {//get a audio to play
                if (waitings.length == 0)
                    break;
                var effId = waitings.pop();
                var eff = effects[effId];
                if (!eff)
                    continue;
                if (eff._isToPlay || eff.loop || (eff.duration && eff.currentTime + expendTime < eff.duration)) {
                    self._currEffectId = effId;
                    self._currEffect = eff;
                    if (!eff._isToPlay && eff.readyState > 2 && eff.duration && eff.duration != Infinity) {
                        var temp = eff.currentTime + expendTime;
                        temp = temp - eff.duration * ((temp / eff.duration) | 0);
                        eff.currentTime = temp;
                    }
                    eff._isToPlay = false;
                    return eff;
                } else {
                    if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                        eff.currentTime = eff.duration;
                }
            }
            self._currEffectId = null;
            self._currEffect = null;
            return null;
        },
        _pausePlaying: function () {//in this function, do not change any status of audios
            var self = this, currEffect = self._currEffect;
            self._isHiddenMode = true;
            var audio = self._musicPlayState == 2 ? self._currMusic : currEffect;
            if (audio) {
                self._playings.push(audio);
                audio.pause();
            }
        },
        _resumePlaying: function () {//in this function, do not change any status of audios
            var self = this, playings = self._playings;
            self._isHiddenMode = false;
            if (playings.length > 0) {
                self._resumeAudio(playings[0]);
                playings.length = 0;
            }
        }
    });
}
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function () {
        return cc.loader.audioPath;
    },
    _load: function (realUrl, url, res, count, tryArr, audio, cb) {
        var self = this, locLoader = cc.loader, path = cc.path;
        var types = this._supportedAudioTypes;
        var extname = "";
        if (types.length == 0)
            return cb("can not support audio!");
        if (count == -1) {
            extname = (path.extname(realUrl) || "").toLowerCase();
            if (!self.audioTypeSupported(extname)) {
                extname = types[0];
                count = 0;
            }
        } else if (count < types.length) {
            extname = types[count];
        } else {
            return cb("can not found the resource of audio! Last match url is : " + realUrl);
        }
        if (tryArr.indexOf(extname) >= 0)
            return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);
        realUrl = path.changeExtname(realUrl, extname);
        tryArr.push(extname);
        var delFlag = (count == types.length -1);
        audio = self._loadAudio(realUrl, audio, function (err) {
            if (err)
                return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);//can not found
            cb(null, audio);
        }, delFlag);
        locLoader.cache[url] = audio;
    },
    audioTypeSupported: function (type) {
        if (!type) return false;
        return this._supportedAudioTypes.indexOf(type.toLowerCase()) >= 0;
    },
    _loadAudio: function (url, audio, cb, delFlag) {
        var _Audio;
        if (!cc.isObject(window["cc"]) && cc.sys.browserType == "firefox")
            _Audio = Audio;
        else
            _Audio = (location.origin == "file://") ? Audio : (cc.WebAudio || Audio);
        if (arguments.length == 2) {
            cb = audio;
            audio = new _Audio();
        } else if ((arguments.length > 3 ) && !audio) {
            audio = new _Audio();
        }
        audio.src = url;
        audio.preload = "auto";
        var ua = navigator.userAgent;
        if (/Mobile/.test(ua) && (/iPhone OS/.test(ua) || /iPad/.test(ua) || /Firefox/.test(ua)) || /MSIE/.test(ua)) {
            audio.load();
            cb(null, audio);
        } else {
            var canplaythrough = "canplaythrough", error = "error";
            cc._addEventListener(audio, canplaythrough, function () {
                cb(null, audio);
                this.removeEventListener(canplaythrough, arguments.callee, false);
                this.removeEventListener(error, arguments.callee, false);
            }, false);
            var audioCB = function () {
                audio.removeEventListener("emptied", audioCB);
                audio.removeEventListener(error, audioCB);
                cb("load " + url + " failed");
                if(delFlag){
                    this.removeEventListener(canplaythrough, arguments.callee, false);
                    this.removeEventListener(error, arguments.callee, false);
                }
            };
            if(cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT){
                cc._addEventListener(audio, "emptied", audioCB, false);
            }
            cc._addEventListener(audio, error, audioCB, false);
            audio.load();
        }
        return audio;
    },
    load: function (realUrl, url, res, cb) {
        var tryArr = [];
        this._load(realUrl, url, res, -1, tryArr, null, cb);
    }
};
cc._audioLoader._supportedAudioTypes = function () {
    var au = cc.newElement('audio'), arr = [];
    if (au.canPlayType) {
        var _check = function (typeStr) {
            var result = au.canPlayType(typeStr);
            return result != "no" && result != "";
        };
        if (_check('audio/ogg; codecs="vorbis"')) arr.push(".ogg");
        if (_check("audio/mpeg")) arr.push(".mp3");
        if (_check('audio/wav; codecs="1"')) arr.push(".wav");
        if (_check("audio/mp4")) arr.push(".mp4");
        if (_check("audio/x-m4a") || _check("audio/aac")) arr.push(".m4a");
    }
    return arr;
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle() : new cc.AudioEngine();
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
    cc.audioEngine._pausePlaying();
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
    cc.audioEngine._resumePlaying();
});
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = false;
cc.MenuItem = cc.Node.extend({
    _enabled: false,
    _target: null,
    _callback: null,
    _isSelected: false,
    _className: "MenuItem",
    ctor: function (callback, target) {
        var nodeP = cc.Node.prototype;
        nodeP.ctor.call(this);
        this._target = null;
        this._callback = null;
        this._isSelected = false;
        this._enabled = false;
        nodeP.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = target || null;
        this._callback = callback || null;
        if (this._callback) {
            this._enabled = true;
        }
    },
    isSelected: function () {
        return this._isSelected;
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    setTarget: function (selector, rec) {
        this._target = rec;
        this._callback = selector;
    },
    isEnabled: function () {
        return this._enabled;
    },
    setEnabled: function (enable) {
        this._enabled = enable;
    },
    initWithCallback: function (callback, target) {
        this.anchorX = 0.5;
        this.anchorY = 0.5;
        this._target = target;
        this._callback = callback;
        this._enabled = true;
        this._isSelected = false;
        return true;
    },
    rect: function () {
        var locPosition = this._position, locContentSize = this._contentSize, locAnchorPoint = this._anchorPoint;
        return cc.rect(locPosition.x - locContentSize.width * locAnchorPoint.x,
            locPosition.y - locContentSize.height * locAnchorPoint.y,
            locContentSize.width, locContentSize.height);
    },
    selected: function () {
        this._isSelected = true;
    },
    unselected: function () {
        this._isSelected = false;
    },
    setCallback: function (callback, target) {
        this._target = target;
        this._callback = callback;
    },
    activate: function () {
        if (this._enabled) {
            var locTarget = this._target, locCallback = this._callback;
            if (!locCallback)
                return;
            if (locTarget && cc.isString(locCallback)) {
                locTarget[locCallback](this);
            } else if (locTarget && cc.isFunction(locCallback)) {
                locCallback.call(locTarget, this);
            } else
                locCallback(this);
        }
    }
});
var _p = cc.MenuItem.prototype;
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function (callback, target) {
    return new cc.MenuItem(callback, target);
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function (label, selector, target) {
        cc.MenuItem.prototype.ctor.call(this, selector, target);
        this._disabledColor = null;
        this._label = null;
        this._orginalScale = 0;
        this._colorBackup = null;
        if (label) {
            this._originalScale = 1.0;
            this._colorBackup = cc.color.WHITE;
            this._disabledColor = cc.color(126, 126, 126);
            this.setLabel(label);
            this.cascadeColor = true;
            this.cascadeOpacity = true;
        }
    },
    getDisabledColor: function () {
        return this._disabledColor;
    },
    setDisabledColor: function (color) {
        this._disabledColor = color;
    },
    getLabel: function () {
        return this._label;
    },
    setLabel: function (label) {
        if (label) {
            this.addChild(label);
            label.anchorX = 0;
            label.anchorY = 0;
            this.width = label.width;
            this.height = label.height;
        }
        if (this._label) {
            this.removeChild(this._label, true);
        }
        this._label = label;
    },
    setEnabled: function (enabled) {
        if (this._enabled != enabled) {
            var locLabel = this._label;
            if (!enabled) {
                this._colorBackup = locLabel.color;
                locLabel.color = this._disabledColor;
            } else {
                locLabel.color = this._colorBackup;
            }
        }
        cc.MenuItem.prototype.setEnabled.call(this, enabled);
    },
    setOpacity: function (opacity) {
        this._label.opacity = opacity;
    },
    getOpacity: function () {
        return this._label.opacity;
    },
    setColor: function (color) {
        this._label.color = color;
    },
    getColor: function () {
        return this._label.color;
    },
    initWithLabel: function (label, selector, target) {
        this.initWithCallback(selector, target);
        this._originalScale = 1.0;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(label);
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    setString: function (label) {
        this._label.string = label;
        this.width = this._label.width;
        this.height = this._label.height;
    },
    getString: function () {
        return this._label.string;
    },
    activate: function () {
        if (this._enabled) {
            this.stopAllActions();
            this.scale = this._originalScale;
            cc.MenuItem.prototype.activate.call(this);
        }
    },
    selected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            if (action)
                this.stopAction(action);
            else
                this._originalScale = this.scale;
            var zoomAction = cc.scaleTo(0.1, this._originalScale * 1.2);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    },
    unselected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var zoomAction = cc.scaleTo(0.1, this._originalScale);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    }
});
var _p = cc.MenuItemLabel.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.disabledColor;
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
_p.label;
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function (label, selector, target) {
    return new cc.MenuItemLabel(label, selector, target);
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
        var label;
        if (value && value.length > 0) {
            label = new cc.LabelAtlas(value, charMapFile, itemWidth, itemHeight, startCharMap);
        }
        cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
    },
    initWithString: function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
        if (!value || value.length == 0)
            throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var label = new cc.LabelAtlas();
        label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
        if (this.initWithLabel(label, callback, target)) {
        }
        return true;
    }
});
cc.MenuItemAtlasFont.create = function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
    return new cc.MenuItemAtlasFont(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target);
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function (value, callback, target) {
        var label;
        if (value && value.length > 0) {
            this._fontName = cc._globalFontName;
            this._fontSize = cc._globalFontSize;
            label = new cc.LabelTTF(value, this._fontName, this._fontSize);
        }
        else {
            this._fontSize = 0;
            this._fontName = "";
        }
        cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
    },
    initWithString: function (value, callback, target) {
        if (!value || value.length == 0)
            throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        var label = new cc.LabelTTF(value, this._fontName, this._fontSize);
        if (this.initWithLabel(label, callback, target)) {
        }
        return true;
    },
    setFontSize: function (s) {
        this._fontSize = s;
        this._recreateLabel();
    },
    getFontSize: function () {
        return this._fontSize;
    },
    setFontName: function (name) {
        this._fontName = name;
        this._recreateLabel();
    },
    getFontName: function () {
        return this._fontName;
    },
    _recreateLabel: function () {
        var label = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(label);
    }
});
cc.MenuItemFont.setFontSize = function (fontSize) {
    cc._globalFontSize = fontSize;
};
cc.MenuItemFont.fontSize = function () {
    return cc._globalFontSize;
};
cc.MenuItemFont.setFontName = function (name) {
    if (cc._globalFontNameRelease) {
        cc._globalFontName = '';
    }
    cc._globalFontName = name;
    cc._globalFontNameRelease = true;
};
var _p = cc.MenuItemFont.prototype;
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function () {
    return cc._globalFontName;
};
cc.MenuItemFont.create = function (value, callback, target) {
    return new cc.MenuItemFont(value, callback, target);
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function (normalSprite, selectedSprite, three, four, five) {
        cc.MenuItem.prototype.ctor.call(this);
        this._normalImage = null;
        this._selectedImage = null;
        this._disabledImage = null;
        if (selectedSprite !== undefined) {
            normalSprite = normalSprite;
            selectedSprite = selectedSprite;
            var disabledImage, target, callback;
            if (five !== undefined) {
                disabledImage = three;
                callback = four;
                target = five;
            } else if (four !== undefined && cc.isFunction(four)) {
                disabledImage = three;
                callback = four;
            } else if (four !== undefined && cc.isFunction(three)) {
                target = four;
                callback = three;
                disabledImage = new cc.Sprite(selectedSprite);
            } else if (three === undefined) {
                disabledImage = new cc.Sprite(selectedSprite);
            }
            this.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, callback, target);
        }
    },
    getNormalImage: function () {
        return this._normalImage;
    },
    setNormalImage: function (normalImage) {
        if (this._normalImage == normalImage) {
            return;
        }
        if (normalImage) {
            this.addChild(normalImage, 0, cc.NORMAL_TAG);
            normalImage.anchorX = 0;
            normalImage.anchorY = 0;
        }
        if (this._normalImage) {
            this.removeChild(this._normalImage, true);
        }
        this._normalImage = normalImage;
        this.width = this._normalImage.width;
        this.height = this._normalImage.height;
        this._updateImagesVisibility();
        if (normalImage.textureLoaded && !normalImage.textureLoaded()) {
            normalImage.addEventListener("load", function (sender) {
                this.width = sender.width;
                this.height = sender.height;
            }, this);
        }
    },
    getSelectedImage: function () {
        return this._selectedImage;
    },
    setSelectedImage: function (selectedImage) {
        if (this._selectedImage == selectedImage)
            return;
        if (selectedImage) {
            this.addChild(selectedImage, 0, cc.SELECTED_TAG);
            selectedImage.anchorX = 0;
            selectedImage.anchorY = 0;
        }
        if (this._selectedImage) {
            this.removeChild(this._selectedImage, true);
        }
        this._selectedImage = selectedImage;
        this._updateImagesVisibility();
    },
    getDisabledImage: function () {
        return this._disabledImage;
    },
    setDisabledImage: function (disabledImage) {
        if (this._disabledImage == disabledImage)
            return;
        if (disabledImage) {
            this.addChild(disabledImage, 0, cc.DISABLE_TAG);
            disabledImage.anchorX = 0;
            disabledImage.anchorY = 0;
        }
        if (this._disabledImage)
            this.removeChild(this._disabledImage, true);
        this._disabledImage = disabledImage;
        this._updateImagesVisibility();
    },
    initWithNormalSprite: function (normalSprite, selectedSprite, disabledSprite, callback, target) {
        this.initWithCallback(callback, target);
        this.setNormalImage(normalSprite);
        this.setSelectedImage(selectedSprite);
        this.setDisabledImage(disabledSprite);
        var locNormalImage = this._normalImage;
        if (locNormalImage) {
            this.width = locNormalImage.width;
            this.height = locNormalImage.height;
            if (locNormalImage.textureLoaded && !locNormalImage.textureLoaded()) {
                locNormalImage.addEventListener("load", function (sender) {
                    this.width = sender.width;
                    this.height = sender.height;
                    this.cascadeColor = true;
                    this.cascadeOpacity = true;
                }, this);
            }
        }
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    setColor: function (color) {
        this._normalImage.color = color;
        if (this._selectedImage)
            this._selectedImage.color = color;
        if (this._disabledImage)
            this._disabledImage.color = color;
    },
    getColor: function () {
        return this._normalImage.color;
    },
    setOpacity: function (opacity) {
        this._normalImage.opacity = opacity;
        if (this._selectedImage)
            this._selectedImage.opacity = opacity;
        if (this._disabledImage)
            this._disabledImage.opacity = opacity;
    },
    getOpacity: function () {
        return this._normalImage.opacity;
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        if (this._normalImage) {
            if (this._disabledImage)
                this._disabledImage.visible = false;
            if (this._selectedImage) {
                this._normalImage.visible = false;
                this._selectedImage.visible = true;
            } else
                this._normalImage.visible = true;
        }
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        if (this._normalImage) {
            this._normalImage.visible = true;
            if (this._selectedImage)
                this._selectedImage.visible = false;
            if (this._disabledImage)
                this._disabledImage.visible = false;
        }
    },
    setEnabled: function (bEnabled) {
        if (this._enabled != bEnabled) {
            cc.MenuItem.prototype.setEnabled.call(this, bEnabled);
            this._updateImagesVisibility();
        }
    },
    _updateImagesVisibility: function () {
        var locNormalImage = this._normalImage, locSelImage = this._selectedImage, locDisImage = this._disabledImage;
        if (this._enabled) {
            if (locNormalImage)
                locNormalImage.visible = true;
            if (locSelImage)
                locSelImage.visible = false;
            if (locDisImage)
                locDisImage.visible = false;
        } else {
            if (locDisImage) {
                if (locNormalImage)
                    locNormalImage.visible = false;
                if (locSelImage)
                    locSelImage.visible = false;
                if (locDisImage)
                    locDisImage.visible = true;
            } else {
                if (locNormalImage)
                    locNormalImage.visible = true;
                if (locSelImage)
                    locSelImage.visible = false;
            }
        }
    }
});
var _p = cc.MenuItemSprite.prototype;
_p.normalImage;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
_p.selectedImage;
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
_p.disabledImage;
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function (normalSprite, selectedSprite, three, four, five) {
    return new cc.MenuItemSprite(normalSprite, selectedSprite, three, four, five || undefined);
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function (normalImage, selectedImage, three, four, five) {
        var normalSprite = null,
            selectedSprite = null,
            disabledSprite = null,
            callback = null,
            target = null;
        if (normalImage === undefined) {
            cc.MenuItemSprite.prototype.ctor.call(this);
        }
        else {
            normalSprite = new cc.Sprite(normalImage);
            selectedImage &&
            (selectedSprite = new cc.Sprite(selectedImage));
            if (four === undefined) {
                callback = three;
            }
            else if (five === undefined) {
                callback = three;
                target = four;
            }
            else if (five) {
                disabledSprite = new cc.Sprite(three);
                callback = four;
                target = five;
            }
            cc.MenuItemSprite.prototype.ctor.call(this, normalSprite, selectedSprite, disabledSprite, callback, target);
        }
    },
    setNormalSpriteFrame: function (frame) {
        this.setNormalImage(new cc.Sprite(frame));
    },
    setSelectedSpriteFrame: function (frame) {
        this.setSelectedImage(new cc.Sprite(frame));
    },
    setDisabledSpriteFrame: function (frame) {
        this.setDisabledImage(new cc.Sprite(frame));
    },
    initWithNormalImage: function (normalImage, selectedImage, disabledImage, callback, target) {
        var normalSprite = null;
        var selectedSprite = null;
        var disabledSprite = null;
        if (normalImage) {
            normalSprite = new cc.Sprite(normalImage);
        }
        if (selectedImage) {
            selectedSprite = new cc.Sprite(selectedImage);
        }
        if (disabledImage) {
            disabledSprite = new cc.Sprite(disabledImage);
        }
        return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, callback, target);
    }
});
cc.MenuItemImage.create = function (normalImage, selectedImage, three, four, five) {
    return new cc.MenuItemImage(normalImage, selectedImage, three, four, five);
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function () {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        if(arguments.length > 0)
            this.initWithItems(Array.prototype.slice.apply(arguments));
    },
    getOpacity: function () {
        return this._opacity;
    },
    setOpacity: function (opacity) {
        this._opacity = opacity;
        if (this.subItems && this.subItems.length > 0) {
            for (var it = 0; it < this.subItems.length; it++) {
                this.subItems[it].opacity = opacity;
            }
        }
        this._color.a = opacity;
    },
    getColor: function () {
        var locColor = this._color;
        return cc.color(locColor.r, locColor.g, locColor.b, locColor.a);
    },
    setColor: function (color) {
        var locColor = this._color;
        locColor.r = color.r;
        locColor.g = color.g;
        locColor.b = color.b;
        if (this.subItems && this.subItems.length > 0) {
            for (var it = 0; it < this.subItems.length; it++) {
                this.subItems[it].setColor(color);
            }
        }
        if (color.a !== undefined && !color.a_undefined) {
            this.setOpacity(color.a);
        }
    },
    getSelectedIndex: function () {
        return this._selectedIndex;
    },
    setSelectedIndex: function (SelectedIndex) {
        if (SelectedIndex != this._selectedIndex) {
            this._selectedIndex = SelectedIndex;
            var currItem = this.getChildByTag(cc.CURRENT_ITEM);
            if (currItem)
                currItem.removeFromParent(false);
            var item = this.subItems[this._selectedIndex];
            this.addChild(item, 0, cc.CURRENT_ITEM);
            var w = item.width, h = item.height;
            this.width = w;
            this.height = h;
            item.setPosition(w / 2, h / 2);
        }
    },
    getSubItems: function () {
        return this.subItems;
    },
    setSubItems: function (subItems) {
        this.subItems = subItems;
    },
    initWithItems: function (args) {
        var l = args.length;
        if (cc.isFunction(args[args.length - 2])) {
            this.initWithCallback(args[args.length - 2], args[args.length - 1]);
            l = l - 2;
        } else if (cc.isFunction(args[args.length - 1])) {
            this.initWithCallback(args[args.length - 1], null);
            l = l - 1;
        } else {
            this.initWithCallback(null, null);
        }
        var locSubItems = this.subItems;
        locSubItems.length = 0;
        for (var i = 0; i < l; i++) {
            if (args[i])
                locSubItems.push(args[i]);
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    addSubItem: function (item) {
        this.subItems.push(item);
    },
    activate: function () {
        if (this._enabled) {
            var newIndex = (this._selectedIndex + 1) % this.subItems.length;
            this.setSelectedIndex(newIndex);
        }
        cc.MenuItem.prototype.activate.call(this);
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected();
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected();
    },
    setEnabled: function (enabled) {
        if (this._enabled != enabled) {
            cc.MenuItem.prototype.setEnabled.call(this, enabled);
            var locItems = this.subItems;
            if (locItems && locItems.length > 0) {
                for (var it = 0; it < locItems.length; it++)
                    locItems[it].enabled = enabled;
            }
        }
    },
    selectedItem: function () {
        return this.subItems[this._selectedIndex];
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex);
    }
});
var _p = cc.MenuItemToggle.prototype;
_p.selectedIndex;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function () {
    if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var ret = new cc.MenuItemToggle();
    ret.initWithItems(Array.prototype.slice.apply(arguments));
    return ret;
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: false,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function (menuItems) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = false;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: true,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var argc = arguments.length, items;
        if (argc == 0) {
            items = [];
        } else if (argc == 1) {
            if (menuItems instanceof Array) {
                items = menuItems;
            }
            else items = [menuItems];
        }
        else if (argc > 1) {
            items = [];
            for (var i = 0; i < argc; i++) {
                if (arguments[i])
                    items.push(arguments[i]);
            }
        }
        this.initWithArray(items);
    },
    onEnter: function () {
        var locListener = this._touchListener;
        if (!locListener._isRegistered())
            cc.eventManager.addListener(locListener, this);
        cc.Node.prototype.onEnter.call(this);
    },
    isEnabled: function () {
        return this.enabled;
    },
    setEnabled: function (enabled) {
        this.enabled = enabled;
    },
    initWithItems: function (args) {
        var pArray = [];
        if (args) {
            for (var i = 0; i < args.length; i++) {
                if (args[i])
                    pArray.push(args[i]);
            }
        }
        return this.initWithArray(pArray);
    },
    initWithArray: function (arrayOfItems) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = true;
            var winSize = cc.winSize;
            this.setPosition(winSize.width / 2, winSize.height / 2);
            this.setContentSize(winSize);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(true);
            if (arrayOfItems) {
                for (var i = 0; i < arrayOfItems.length; i++)
                    this.addChild(arrayOfItems[i], i);
            }
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            this.cascadeColor = true;
            this.cascadeOpacity = true;
            return true;
        }
        return false;
    },
    addChild: function (child, zOrder, tag) {
        if (!(child instanceof cc.MenuItem))
            throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, child, zOrder, tag);
    },
    alignItemsVertically: function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsVerticallyWithPadding: function (padding) {
        var height = -padding, locChildren = this._children, len, i, locScaleY, locHeight, locChild;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++)
                height += locChildren[i].height * locChildren[i].scaleY + padding;
            var y = height / 2.0;
            for (i = 0, len = locChildren.length; i < len; i++) {
                locChild = locChildren[i];
                locHeight = locChild.height;
                locScaleY = locChild.scaleY;
                locChild.setPosition(0, y - locHeight * locScaleY / 2);
                y -= locHeight * locScaleY + padding;
            }
        }
    },
    alignItemsHorizontally: function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsHorizontallyWithPadding: function (padding) {
        var width = -padding, locChildren = this._children, i, len, locScaleX, locWidth, locChild;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++)
                width += locChildren[i].width * locChildren[i].scaleX + padding;
            var x = -width / 2.0;
            for (i = 0, len = locChildren.length; i < len; i++) {
                locChild = locChildren[i];
                locScaleX = locChild.scaleX;
                locWidth = locChildren[i].width;
                locChild.setPosition(x + locWidth * locScaleX / 2, 0);
                x += locWidth * locScaleX + padding;
            }
        }
    },
    alignItemsInColumns: function () {
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var rows = [];
        for (var i = 0; i < arguments.length; i++) {
            rows.push(arguments[i]);
        }
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns, tmp, len;
        var locChildren = this._children;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                if (row >= rows.length)
                    continue;
                rowColumns = rows[row];
                if (!rowColumns)
                    continue;
                tmp = locChildren[i].height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    height += rowHeight + 5;
                    columnsOccupied = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
        var winSize = cc.director.getWinSize();
        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0.0;
        var x = 0.0;
        var y = (height / 2);
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                var child = locChildren[i];
                if (rowColumns == 0) {
                    rowColumns = rows[row];
                    w = winSize.width / (1 + rowColumns);
                    x = w;
                }
                tmp = child._getHeight();
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                child.setPosition(x - winSize.width / 2, y - tmp / 2);
                x += w;
                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    y -= rowHeight + 5;
                    columnsOccupied = 0;
                    rowColumns = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
    },
    alignItemsInRows: function () {
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var columns = [], i;
        for (i = 0; i < arguments.length; i++) {
            columns.push(arguments[i]);
        }
        var columnWidths = [];
        var columnHeights = [];
        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows, child, len, tmp;
        var locChildren = this._children;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                child = locChildren[i];
                if (column >= columns.length)
                    continue;
                columnRows = columns[column];
                if (!columnRows)
                    continue;
                tmp = child.width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);
                columnHeight += (child.height + 5);
                ++rowsOccupied;
                if (rowsOccupied >= columnRows) {
                    columnWidths.push(columnWidth);
                    columnHeights.push(columnHeight);
                    width += columnWidth + 10;
                    rowsOccupied = 0;
                    columnWidth = 0;
                    columnHeight = -5;
                    ++column;
                }
            }
        }
        var winSize = cc.director.getWinSize();
        column = 0;
        columnWidth = 0;
        columnRows = 0;
        var x = -width / 2;
        var y = 0.0;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                child = locChildren[i];
                if (columnRows == 0) {
                    columnRows = columns[column];
                    y = columnHeights[column];
                }
                tmp = child._getWidth();
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);
                child.setPosition(x + columnWidths[column] / 2, y - winSize.height / 2);
                y -= child.height + 10;
                ++rowsOccupied;
                if (rowsOccupied >= columnRows) {
                    x += columnWidth + 5;
                    rowsOccupied = 0;
                    columnRows = 0;
                    columnWidth = 0;
                    ++column;
                }
            }
        }
    },
    removeChild: function (child, cleanup) {
        if (child == null)
            return;
        if (!(child instanceof cc.MenuItem)) {
            cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
            return;
        }
        if (this._selectedItem == child)
            this._selectedItem = null;
        cc.Node.prototype.removeChild.call(this, child, cleanup);
    },
    _onTouchBegan: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state != cc.MENU_STATE_WAITING || !target._visible || !target.enabled)
            return false;
        for (var c = target.parent; c != null; c = c.parent) {
            if (!c.isVisible())
                return false;
        }
        target._selectedItem = target._itemForTouch(touch);
        if (target._selectedItem) {
            target._state = cc.MENU_STATE_TRACKING_TOUCH;
            target._selectedItem.selected();
            return true;
        }
        return false;
    },
    _onTouchEnded: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchEnded(): invalid state");
            return;
        }
        if (target._selectedItem) {
            target._selectedItem.unselected();
            target._selectedItem.activate();
        }
        target._state = cc.MENU_STATE_WAITING;
    },
    _onTouchCancelled: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchCancelled(): invalid state");
            return;
        }
        if (this._selectedItem)
            target._selectedItem.unselected();
        target._state = cc.MENU_STATE_WAITING;
    },
    _onTouchMoved: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchMoved(): invalid state");
            return;
        }
        var currentItem = target._itemForTouch(touch);
        if (currentItem != target._selectedItem) {
            if (target._selectedItem)
                target._selectedItem.unselected();
            target._selectedItem = currentItem;
            if (target._selectedItem)
                target._selectedItem.selected();
        }
    },
    onExit: function () {
        if (this._state == cc.MENU_STATE_TRACKING_TOUCH) {
            if (this._selectedItem) {
                this._selectedItem.unselected();
                this._selectedItem = null;
            }
            this._state = cc.MENU_STATE_WAITING;
        }
        cc.Node.prototype.onExit.call(this);
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    _itemForTouch: function (touch) {
        var touchLocation = touch.getLocation();
        var itemChildren = this._children, locItemChild;
        if (itemChildren && itemChildren.length > 0) {
            for (var i = itemChildren.length - 1; i >= 0; i--) {
                locItemChild = itemChildren[i];
                if (locItemChild.isVisible() && locItemChild.isEnabled()) {
                    var local = locItemChild.convertToNodeSpace(touchLocation);
                    var r = locItemChild.rect();
                    r.x = 0;
                    r.y = 0;
                    if (cc.rectContainsPoint(r, local))
                        return locItemChild;
                }
            }
        }
        return null;
    }
});
var _p = cc.Menu.prototype;
_p.enabled;
cc.Menu.create = function (menuItems) {
    var argc = arguments.length;
    if ((argc > 0) && (arguments[argc - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var ret;
    if (argc == 0)
        ret = new cc.Menu();
    else if (argc == 1)
        ret = new cc.Menu(menuItems);
    else
        ret = new cc.Menu(Array.prototype.slice.call(arguments, 0));
    return ret;
};
