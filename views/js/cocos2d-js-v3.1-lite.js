var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
window._p;
_p = window;
_p.gl;
_p.WebGLRenderingContext;
_p.DeviceOrientationEvent;
_p.DeviceMotionEvent;
_p.AudioContext;
_p.webkitAudioContext;
_p.mozAudioContext;
_p = Object.prototype;
_p._super;
_p.ctor;
delete window._p;
cc.newElement = function (x) {
    return document.createElement(x);
};
cc._addEventListener = function (element, type, listener, useCapture) {
    element.addEventListener(type, listener, useCapture);
};
cc._isNodeJs = typeof require !== 'undefined' && require("fs");
cc.each = function (obj, iterator, context) {
    if (!obj)
        return;
    if (obj instanceof Array) {
        for (var i = 0, li = obj.length; i < li; i++) {
            if (iterator.call(context, obj[i], i) === false)
                return;
        }
    } else {
        for (var key in obj) {
            if (iterator.call(context, obj[key], key) === false)
                return;
        }
    }
};
cc.extend = function(target) {
    var sources = arguments.length >= 2 ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(sources, function(src) {
        for(var key in src) {
            if (src.hasOwnProperty(key)) {
                target[key] = src[key];
            }
        }
    });
    return target;
};
cc.isFunction = function(obj) {
    return typeof obj == 'function';
};
cc.isNumber = function(obj) {
    return typeof obj == 'number' || Object.prototype.toString.call(obj) == '[object Number]';
};
cc.isString = function(obj) {
    return typeof obj == 'string' || Object.prototype.toString.call(obj) == '[object String]';
};
cc.isArray = function(obj) {
    return Object.prototype.toString.call(obj) == '[object Array]';
};
cc.isUndefined = function(obj) {
    return typeof obj == 'undefined';
};
cc.isObject = function(obj) {
    var type = typeof obj;
    return type == 'function' || (obj && type == 'object');
};
cc.isCrossOrigin = function (url) {
    if (!url) {
        cc.log("invalid URL");
        return false;
    }
    var startIndex = url.indexOf("://");
    if (startIndex == -1)
        return false;
    var endIndex = url.indexOf("/", startIndex + 3);
    var urlOrigin = (endIndex == -1) ? url : url.substring(0, endIndex);
    return urlOrigin != location.origin;
};
cc.AsyncPool = function(srcObj, limit, iterator, onEnd, target){
    var self = this;
    self._srcObj = srcObj;
    self._limit = limit;
    self._pool = [];
    self._iterator = iterator;
    self._iteratorTarget = target;
    self._onEnd = onEnd;
    self._onEndTarget = target;
    self._results = srcObj instanceof Array ? [] : {};
    self._isErr = false;
    cc.each(srcObj, function(value, index){
        self._pool.push({index : index, value : value});
    });
    self.size = self._pool.length;
    self.finishedSize = 0;
    self._workingSize = 0;
    self._limit = self._limit || self.size;
    self.onIterator = function(iterator, target){
        self._iterator = iterator;
        self._iteratorTarget = target;
    };
    self.onEnd = function(endCb, endCbTarget){
        self._onEnd = endCb;
        self._onEndTarget = endCbTarget;
    };
    self._handleItem = function(){
        var self = this;
        if(self._pool.length == 0)
            return;
        if(self._workingSize >= self._limit)
            return;
        var item = self._pool.shift();
        var value = item.value, index = item.index;
        self._workingSize++;
        self._iterator.call(self._iteratorTarget, value, index, function(err){
            if(self._isErr)
                return;
            self.finishedSize++;
            self._workingSize--;
            if(err) {
                self._isErr = true;
                if(self._onEnd)
                    self._onEnd.call(self._onEndTarget, err);
                return;
            }
            var arr = Array.prototype.slice.call(arguments, 1);
            self._results[this.index] = arr[0];
            if(self.finishedSize == self.size) {
                if(self._onEnd)
                    self._onEnd.call(self._onEndTarget, null, self._results);
                return;
            }
            self._handleItem();
        }.bind(item), self);
    };
    self.flow = function(){
        var self = this;
        if(self._pool.length == 0) {
            if(self._onEnd)
                self._onEnd.call(self._onEndTarget, null, []);
                return;
        }
        for(var i = 0; i < self._limit; i++)
            self._handleItem();
    }
};
cc.async = {
    series : function(tasks, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, 1, function(func, index, cb1){
            func.call(target, cb1);
        }, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    parallel : function(tasks, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, 0, function(func, index, cb1){
            func.call(target, cb1);
        }, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    waterfall : function(tasks, cb, target){
        var args = [];
        var lastResults = [null];//the array to store the last results
        var asyncPool = new cc.AsyncPool(tasks, 1,
            function (func, index, cb1) {
                args.push(function (err) {
                    args = Array.prototype.slice.call(arguments, 1);
                    if(tasks.length - 1 == index) lastResults = lastResults.concat(args);//while the last task
                    cb1.apply(null, arguments);
                });
                func.apply(target, args);
            }, function (err) {
                if (!cb)
                    return;
                if (err)
                    return cb.call(target, err);
                cb.apply(target, lastResults);
            });
        asyncPool.flow();
        return asyncPool;
    },
    map : function(tasks, iterator, cb, target){
        var locIterator = iterator;
        if(typeof(iterator) == "object"){
            cb = iterator.cb;
            target = iterator.iteratorTarget;
            locIterator = iterator.iterator;
        }
        var asyncPool = new cc.AsyncPool(tasks, 0, locIterator, cb, target);
        asyncPool.flow();
        return asyncPool;
    },
    mapLimit : function(tasks, limit, iterator, cb, target){
        var asyncPool = new cc.AsyncPool(tasks, limit, iterator, cb, target);
        asyncPool.flow();
        return asyncPool;
    }
};
cc.path = {
    join: function () {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) {
            result = (result + (result == "" ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        }
        return result;
    },
    extname: function (pathStr) {
        var temp = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(pathStr);
        return temp ? temp[1] : null;
    },
    mainFileName: function(fileName){
        if(fileName){
           var idx = fileName.lastIndexOf(".");
            if(idx !== -1)
               return fileName.substring(0,idx);
        }
        return fileName;
    },
    basename: function (pathStr, extname) {
        var index = pathStr.indexOf("?");
        if (index > 0) pathStr = pathStr.substring(0, index);
        var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
        if (!result) return null;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() == extname.toLowerCase())
            return baseName.substring(0, baseName.length - extname.length);
        return baseName;
    },
    dirname: function (pathStr) {
        return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, '$2');
    },
    changeExtname: function (pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
    },
    changeBasename: function (pathStr, basename, isSameExt) {
        if (basename.indexOf(".") == 0) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
    }
};
cc.loader = {
    _jsCache: {},//cache for js
    _register: {},//register of loaders
    _langPathCache: {},//cache for lang path
    _aliases: {},//aliases for res url
    resPath: "",//root path of resource
    audioPath: "",//root path of audio
    cache: {},//cache for data loaded
    getXMLHttpRequest: function () {
        return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    },
    _getArgs4Js: function (args) {
        var a0 = args[0], a1 = args[1], a2 = args[2], results = ["", null, null];
        if (args.length === 1) {
            results[1] = a0 instanceof Array ? a0 : [a0];
        } else if (args.length === 2) {
            if (typeof a1 == "function") {
                results[1] = a0 instanceof Array ? a0 : [a0];
                results[2] = a1;
            } else {
                results[0] = a0 || "";
                results[1] = a1 instanceof Array ? a1 : [a1];
            }
        } else if (args.length === 3) {
            results[0] = a0 || "";
            results[1] = a1 instanceof Array ? a1 : [a1];
            results[2] = a2;
        } else throw "arguments error to load js!";
        return results;
    },
    loadJs: function (baseDir, jsList, cb) {
        var self = this, localJsCache = self._jsCache,
            args = self._getArgs4Js(arguments);
        var preDir = args[0], list = args[1], callback = args[2];
        if (navigator.userAgent.indexOf("Trident/5") > -1) {
            self._loadJs4Dependency(preDir, list, 0, callback);
        } else {
            cc.async.map(list, function (item, index, cb1) {
                var jsPath = cc.path.join(preDir, item);
                if (localJsCache[jsPath]) return cb1(null);
                self._createScript(jsPath, false, cb1);
            }, callback);
        }
    },
    loadJsWithImg: function (baseDir, jsList, cb) {
        var self = this, jsLoadingImg = self._loadJsImg(),
            args = self._getArgs4Js(arguments);
        this.loadJs(args[0], args[1], function (err) {
            if (err) throw err;
            jsLoadingImg.parentNode.removeChild(jsLoadingImg);//remove loading gif
            if (args[2]) args[2]();
        });
    },
    _createScript: function (jsPath, isAsync, cb) {
        var d = document, self = this, s = cc.newElement('script');
        s.async = isAsync;
        s.src = jsPath;
        self._jsCache[jsPath] = true;
        cc._addEventListener(s, 'load', function () {
            s.parentNode.removeChild(s);
            this.removeEventListener('load', arguments.callee, false);
            cb();
        }, false);
        cc._addEventListener(s, 'error', function () {
            s.parentNode.removeChild(s);
            cb("Load " + jsPath + " failed!");
        }, false);
        d.body.appendChild(s);
    },
    _loadJs4Dependency: function (baseDir, jsList, index, cb) {
        if (index >= jsList.length) {
            if (cb) cb();
            return;
        }
        var self = this;
        self._createScript(cc.path.join(baseDir, jsList[index]), false, function (err) {
            if (err) return cb(err);
            self._loadJs4Dependency(baseDir, jsList, index + 1, cb);
        });
    },
    _loadJsImg: function () {
        var d = document, jsLoadingImg = d.getElementById("cocos2d_loadJsImg");
        if (!jsLoadingImg) {
            jsLoadingImg = cc.newElement('img');
            if (cc._loadingImage)
                jsLoadingImg.src = cc._loadingImage;
            var canvasNode = d.getElementById(cc.game.config["id"]);
            canvasNode.style.backgroundColor = "black";
            canvasNode.parentNode.appendChild(jsLoadingImg);
            var canvasStyle = getComputedStyle ? getComputedStyle(canvasNode) : canvasNode.currentStyle;
            if (!canvasStyle)
                canvasStyle = {width: canvasNode.width, height: canvasNode.height};
            jsLoadingImg.style.left = canvasNode.offsetLeft + (parseFloat(canvasStyle.width) - jsLoadingImg.width) / 2 + "px";
            jsLoadingImg.style.top = canvasNode.offsetTop + (parseFloat(canvasStyle.height) - jsLoadingImg.height) / 2 + "px";
            jsLoadingImg.style.position = "absolute";
        }
        return jsLoadingImg;
    },
    loadTxt: function (url, cb) {
        if (!cc._isNodeJs) {
            var xhr = this.getXMLHttpRequest(),
                errInfo = "load " + url + " failed!";
            xhr.open("GET", url, true);
            if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                xhr.setRequestHeader("Accept-Charset", "utf-8");
                xhr.onreadystatechange = function () {
                    if(xhr.readyState == 4)
                        xhr.status == 200 ? cb(null, xhr.responseText) : cb(errInfo);
                };
            } else {
                if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=utf-8");
                xhr.onload = function () {
                    if(xhr.readyState == 4)
                        xhr.status == 200 ? cb(null, xhr.responseText) : cb(errInfo);
                };
            }
            xhr.send(null);
        } else {
            var fs = require("fs");
            fs.readFile(url, function (err, data) {
                err ? cb(err) : cb(null, data.toString());
            });
        }
    },
    _loadTxtSync: function (url) {
        if (!cc._isNodeJs) {
            var xhr = this.getXMLHttpRequest();
            xhr.open("GET", url, false);
            if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                xhr.setRequestHeader("Accept-Charset", "utf-8");
            } else {
                if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=utf-8");
            }
            xhr.send(null);
            if (!xhr.readyState == 4 || xhr.status != 200) {
                return null;
            }
            return xhr.responseText;
        } else {
            var fs = require("fs");
            return fs.readFileSync(url).toString();
        }
    },
    loadCsb: function(url, cb){
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            var arrayBuffer = xhr.response;
            if (arrayBuffer) {
                window.msg = arrayBuffer;
            }
            if(xhr.readyState == 4)
                xhr.status == 200 ? cb(null, xhr.response) : cb("load " + url + " failed!");
        };
        xhr.send(null);
    },
    loadJson: function (url, cb) {
        this.loadTxt(url, function (err, txt) {
            try {
                err ? cb(err) : cb(null, JSON.parse(txt));
            } catch (e) {
                throw "load json [" + url + "] failed : " + e;
            }
        });
    },
    _checkIsImageURL: function (url) {
        var ext = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(url);
        return (ext != null);
    },
    loadImg: function (url, option, cb) {
        var opt = {
            isCrossOrigin: true
        };
        if (cb !== undefined)
            opt.isCrossOrigin = option.isCrossOrigin == null ? opt.isCrossOrigin : option.isCrossOrigin;
        else if (option !== undefined)
            cb = option;
        var img = new Image();
        if (opt.isCrossOrigin && location.origin != "file://")
            img.crossOrigin = "Anonymous";
        var lcb = function () {
            this.removeEventListener('load', lcb, false);
            this.removeEventListener('error', ecb, false);
            if (cb)
                cb(null, img);
        };
        var ecb = function () {
            this.removeEventListener('error', ecb, false);
            if(img.crossOrigin && img.crossOrigin.toLowerCase() == "anonymous"){
                opt.isCrossOrigin = false;
                cc.loader.loadImg(url, opt, cb);
            }else{
                typeof cb == "function" && cb("load image failed");
            }
        };
        cc._addEventListener(img, "load", lcb);
        cc._addEventListener(img, "error", ecb);
        img.src = url;
        return img;
    },
    _loadResIterator: function (item, index, cb) {
        var self = this, url = null;
        var type = item.type;
        if (type) {
            type = "." + type.toLowerCase();
            url = item.src ? item.src : item.name + type;
        } else {
            url = item;
            type = cc.path.extname(url);
        }
        var obj = self.cache[url];
        if (obj)
            return cb(null, obj);
        var loader = null;
        if (type) {
            loader = self._register[type.toLowerCase()];
        }
        if (!loader) {
            cc.error("loader for [" + type + "] not exists!");
            return cb();
        }
        var basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
        var realUrl = self.getUrl(basePath, url);
        loader.load(realUrl, url, item, function (err, data) {
            if (err) {
                cc.log(err);
                self.cache[url] = null;
                delete self.cache[url];
                cb();
            } else {
                self.cache[url] = data;
                cb(null, data);
            }
        });
    },
    getUrl: function (basePath, url) {
        var self = this, langPathCache = self._langPathCache, path = cc.path;
        if (basePath !== undefined && url === undefined) {
            url = basePath;
            var type = path.extname(url);
            type = type ? type.toLowerCase() : "";
            var loader = self._register[type];
            if (!loader)
                basePath = self.resPath;
            else
                basePath = loader.getBasePath ? loader.getBasePath() : self.resPath;
        }
        url = cc.path.join(basePath || "", url);
        if (url.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (langPathCache[url])
                return langPathCache[url];
            var extname = path.extname(url) || "";
            url = langPathCache[url] = url.substring(0, url.length - extname.length) + "_" + cc.sys.language + extname;
        }
        return url;
    },
    load : function(resources, option, cb){
        var self = this;
        var len = arguments.length;
        if(len == 0)
            throw "arguments error!";
        if(len == 3){
            if(typeof option == "function"){
                if(typeof cb == "function")
                    option = {trigger : option, cb : cb };
                else
                    option = { cb : option, cbTarget : cb};
            }
        }else if(len == 2){
            if(typeof option == "function")
                option = {cb : option};
        }else if(len == 1){
            option = {};
        }
        if(!(resources instanceof Array))
            resources = [resources];
        var asyncPool = new cc.AsyncPool(resources, 0, function(value, index, cb1, aPool){
            self._loadResIterator(value, index, function(err){
                if(err)
                    return cb1(err);
                var arr = Array.prototype.slice.call(arguments, 1);
                if(option.trigger)
                    option.trigger.call(option.triggerTarget, arr[0], aPool.size, aPool.finishedSize);
                cb1(null, arr[0]);
            });
        }, option.cb, option.cbTarget);
        asyncPool.flow();
        return asyncPool;
    },
    _handleAliases: function (fileNames, cb) {
        var self = this, aliases = self._aliases;
        var resList = [];
        for (var key in fileNames) {
            var value = fileNames[key];
            aliases[key] = value;
            resList.push(value);
        }
        this.load(resList, cb);
    },
    loadAliases: function (url, cb) {
        var self = this, dict = self.getRes(url);
        if (!dict) {
            self.load(url, function (err, results) {
                self._handleAliases(results[0]["filenames"], cb);
            });
        } else
            self._handleAliases(dict["filenames"], cb);
    },
    register: function (extNames, loader) {
        if (!extNames || !loader) return;
        var self = this;
        if (typeof extNames == "string")
            return this._register[extNames.trim().toLowerCase()] = loader;
        for (var i = 0, li = extNames.length; i < li; i++) {
            self._register["." + extNames[i].trim().toLowerCase()] = loader;
        }
    },
    getRes: function (url) {
        return this.cache[url] || this.cache[this._aliases[url]];
    },
    release: function (url) {
        var cache = this.cache, aliases = this._aliases;
        delete cache[url];
        delete cache[aliases[url]];
        delete aliases[url];
    },
    releaseAll: function () {
        var locCache = this.cache, aliases = this._aliases;
        for (var key in locCache)
            delete locCache[key];
        for (var key in aliases)
            delete aliases[key];
    }
};
cc.formatStr = function(){
    var args = arguments;
    var l = args.length;
    if(l < 1)
        return "";
    var str = args[0];
    var needToFormat = true;
    if(typeof str == "object"){
        needToFormat = false;
    }
    for(var i = 1; i < l; ++i){
        var arg = args[i];
        if(needToFormat){
            while(true){
                var result = null;
                if(typeof arg == "number"){
                    result = str.match(/(%d)|(%s)/);
                    if(result){
                        str = str.replace(/(%d)|(%s)/, arg);
                        break;
                    }
                }
                result = str.match(/%s/);
                if(result)
                    str = str.replace(/%s/, arg);
                else
                    str += "    " + arg;
                break;
            }
        }else
            str += "    " + arg;
    }
    return str;
};
(function () {
    var win = window, hidden, visibilityChange, _undef = "undefined";
    if (!cc.isUndefined(document.hidden)) {
        hidden = "hidden";
        visibilityChange = "visibilitychange";
    } else if (!cc.isUndefined(document.mozHidden)) {
        hidden = "mozHidden";
        visibilityChange = "mozvisibilitychange";
    } else if (!cc.isUndefined(document.msHidden)) {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
    } else if (!cc.isUndefined(document.webkitHidden)) {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
    }
    var onHidden = function () {
        if (cc.eventManager && cc.game._eventHide)
            cc.eventManager.dispatchEvent(cc.game._eventHide);
    };
    var onShow = function () {
        if (cc.eventManager && cc.game._eventShow)
            cc.eventManager.dispatchEvent(cc.game._eventShow);
        if(cc.game._intervalId){
            window.cancelAnimationFrame(cc.game._intervalId);
            cc.game._runMainLoop();
        }
    };
    if (hidden) {
        cc._addEventListener(document, visibilityChange, function () {
            if (document[hidden]) onHidden();
            else onShow();
        }, false);
    } else {
        cc._addEventListener(win, "blur", onHidden, false);
        cc._addEventListener(win, "focus", onShow, false);
    }
    if(navigator.userAgent.indexOf("MicroMessenger") > -1){
        win.onfocus = function(){ onShow() };
    }
    if ("onpageshow" in window && "onpagehide" in window) {
        cc._addEventListener(win, "pagehide", onHidden, false);
        cc._addEventListener(win, "pageshow", onShow, false);
    }
    win = null;
    visibilityChange = null;
})();
cc.log = cc.warn = cc.error = cc.assert = function () {
};
cc.create3DContext = function (canvas, opt_attribs) {
    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    var context = null;
    for (var ii = 0; ii < names.length; ++ii) {
        try {
            context = canvas.getContext(names[ii], opt_attribs);
        } catch (e) {
        }
        if (context) {
            break;
        }
    }
    return context;
};
cc._initSys = function (config, CONFIG_KEY) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    cc.sys = {};
    var sys = cc.sys;
    sys.LANGUAGE_ENGLISH = "en";
    sys.LANGUAGE_CHINESE = "zh";
    sys.LANGUAGE_FRENCH = "fr";
    sys.LANGUAGE_ITALIAN = "it";
    sys.LANGUAGE_GERMAN = "de";
    sys.LANGUAGE_SPANISH = "es";
    sys.LANGUAGE_DUTCH = "du";
    sys.LANGUAGE_RUSSIAN = "ru";
    sys.LANGUAGE_KOREAN = "ko";
    sys.LANGUAGE_JAPANESE = "ja";
    sys.LANGUAGE_HUNGARIAN = "hu";
    sys.LANGUAGE_PORTUGUESE = "pt";
    sys.LANGUAGE_ARABIC = "ar";
    sys.LANGUAGE_NORWEGIAN = "no";
    sys.LANGUAGE_POLISH = "pl";
    sys.OS_WINDOWS = "Windows";
    sys.OS_IOS = "iOS";
    sys.OS_OSX = "OS X";
    sys.OS_UNIX = "UNIX";
    sys.OS_LINUX = "Linux";
    sys.OS_ANDROID = "Android";
    sys.OS_UNKNOWN = "Unknown";
    sys.WINDOWS = 0;
    sys.LINUX = 1;
    sys.MACOS = 2;
    sys.ANDROID = 3;
    sys.IPHONE = 4;
    sys.IPAD = 5;
    sys.BLACKBERRY = 6;
    sys.NACL = 7;
    sys.EMSCRIPTEN = 8;
    sys.TIZEN = 9;
    sys.WINRT = 10;
    sys.WP8 = 11;
    sys.MOBILE_BROWSER = 100;
    sys.DESKTOP_BROWSER = 101;
    sys.BROWSER_TYPE_WECHAT = "wechat";
    sys.BROWSER_TYPE_ANDROID = "androidbrowser";
    sys.BROWSER_TYPE_IE = "ie";
    sys.BROWSER_TYPE_QQ = "qqbrowser";
    sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    sys.BROWSER_TYPE_UC = "ucbrowser";
    sys.BROWSER_TYPE_360 = "360browser";
    sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    sys.BROWSER_TYPE_BAIDU = "baidubrowser";
    sys.BROWSER_TYPE_MAXTHON = "maxthon";
    sys.BROWSER_TYPE_OPERA = "opera";
    sys.BROWSER_TYPE_OUPENG = "oupeng";
    sys.BROWSER_TYPE_MIUI = "miuibrowser";
    sys.BROWSER_TYPE_FIREFOX = "firefox";
    sys.BROWSER_TYPE_SAFARI = "safari";
    sys.BROWSER_TYPE_CHROME = "chrome";
    sys.BROWSER_TYPE_UNKNOWN = "unknown";
    sys.isNative = false;
    var browserSupportWebGL = [sys.BROWSER_TYPE_BAIDU, sys.BROWSER_TYPE_OPERA, sys.BROWSER_TYPE_FIREFOX, sys.BROWSER_TYPE_CHROME, sys.BROWSER_TYPE_SAFARI];
    var osSupportWebGL = [sys.OS_IOS, sys.OS_WINDOWS, sys.OS_OSX, sys.OS_LINUX];
    var multipleAudioWhiteList = [
        sys.BROWSER_TYPE_BAIDU, sys.BROWSER_TYPE_OPERA, sys.BROWSER_TYPE_FIREFOX, sys.BROWSER_TYPE_CHROME, sys.BROWSER_TYPE_BAIDU_APP,
        sys.BROWSER_TYPE_SAFARI, sys.BROWSER_TYPE_UC, sys.BROWSER_TYPE_QQ, sys.BROWSER_TYPE_MOBILE_QQ, sys.BROWSER_TYPE_IE
    ];
    var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
    var ua = nav.userAgent.toLowerCase();
    sys.isMobile = ua.indexOf('mobile') != -1 || ua.indexOf('android') != -1;
    sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
    var currLanguage = nav.language;
    currLanguage = currLanguage ? currLanguage : nav.browserLanguage;
    currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
    sys.language = currLanguage;
    var browserType = sys.BROWSER_TYPE_UNKNOWN;
    var browserTypes = ua.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i)
        || ua.match(/chrome|safari/i);
    if (browserTypes && browserTypes.length > 0) {
        browserType = browserTypes[0].toLowerCase();
        if (browserType == 'micromessenger') {
            browserType = sys.BROWSER_TYPE_WECHAT;
        } else if (browserType === "safari" && (ua.match(/android.*applewebkit/)))
            browserType = sys.BROWSER_TYPE_ANDROID;
        else if (browserType == "trident") browserType = sys.BROWSER_TYPE_IE;
    }
    sys.browserType = browserType;
    var iOS = ( ua.match(/(iPad|iPhone|iPod)/i) ? true : false );
    var isAndroid = ua.match(/android/i) || nav.platform.match(/android/i) ? true : false;
    var osName = sys.OS_UNKNOWN;
    if (nav.appVersion.indexOf("Win") != -1) osName = sys.OS_WINDOWS;
    else if (iOS) osName = sys.OS_IOS;
    else if (nav.appVersion.indexOf("Mac") != -1) osName = sys.OS_OSX;
    else if (nav.appVersion.indexOf("X11") != -1) osName = sys.OS_UNIX;
    else if (isAndroid) osName = sys.OS_ANDROID;
    else if (nav.appVersion.indexOf("Linux") != -1) osName = sys.OS_LINUX;
    sys.os = osName;
    sys._supportMultipleAudio = multipleAudioWhiteList.indexOf(sys.browserType) > -1;
    var userRenderMode = parseInt(config[CONFIG_KEY.renderMode]);
    var renderType = cc._RENDER_TYPE_WEBGL;
    var tempCanvas = cc.newElement("Canvas");
    cc._supportRender = true;
    var notSupportGL = !window.WebGLRenderingContext || browserSupportWebGL.indexOf(sys.browserType) == -1 || osSupportWebGL.indexOf(sys.os) == -1;
    if (userRenderMode === 1 || (userRenderMode === 0 && notSupportGL) || (location.origin == "file://")) {
        renderType = cc._RENDER_TYPE_CANVAS;
    }
    sys._canUseCanvasNewBlendModes = function(){
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        var context = canvas.getContext('2d');
        context.fillStyle = '#000';
        context.fillRect(0,0,1,1);
        context.globalCompositeOperation = 'multiply';
        var canvas2 = document.createElement('canvas');
        canvas2.width = 1;
        canvas2.height = 1;
        var context2 = canvas2.getContext('2d');
        context2.fillStyle = '#fff';
        context2.fillRect(0,0,1,1);
        context.drawImage(canvas2, 0, 0, 1, 1);
        return context.getImageData(0,0,1,1).data[0] === 0;
    };
    sys._supportCanvasNewBlendModes = sys._canUseCanvasNewBlendModes();
    if (renderType == cc._RENDER_TYPE_WEBGL) {
        if (!win.WebGLRenderingContext
            || !cc.create3DContext(tempCanvas, {'stencil': true, 'preserveDrawingBuffer': true })) {
            if (userRenderMode == 0) renderType = cc._RENDER_TYPE_CANVAS;
            else cc._supportRender = false;
        }
    }
    if (renderType == cc._RENDER_TYPE_CANVAS) {
        try {
            tempCanvas.getContext("2d");
        } catch (e) {
            cc._supportRender = false;
        }
    }
    cc._renderType = renderType;
    try {
        sys._supportWebAudio = !!(new (win.AudioContext || win.webkitAudioContext || win.mozAudioContext)());
    } catch (e) {
        sys._supportWebAudio = false;
    }
    try {
        var localStorage = sys.localStorage = win.localStorage;
        localStorage.setItem("storage", "");
        localStorage.removeItem("storage");
        localStorage = null;
    } catch (e) {
        if (e.name === "SECURITY_ERR" || e.name === "QuotaExceededError") {
            cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option");
        }
        sys.localStorage = function () {
        };
    }
    var capabilities = sys.capabilities = {"canvas": true};
    if (cc._renderType == cc._RENDER_TYPE_WEBGL)
        capabilities["opengl"] = true;
    if (docEle['ontouchstart'] !== undefined || nav.msPointerEnabled)
        capabilities["touches"] = true;
    if (docEle['onmouseup'] !== undefined)
        capabilities["mouse"] = true;
    if (docEle['onkeyup'] !== undefined)
        capabilities["keyboard"] = true;
    if (win.DeviceMotionEvent || win.DeviceOrientationEvent)
        capabilities["accelerometer"] = true;
    sys.garbageCollect = function () {
    };
    sys.dumpRoot = function () {
    };
    sys.restartVM = function () {
    };
    sys.dump = function () {
        var self = this;
        var str = "";
        str += "isMobile : " + self.isMobile + "\r\n";
        str += "language : " + self.language + "\r\n";
        str += "browserType : " + self.browserType + "\r\n";
        str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
        str += "os : " + self.os + "\r\n";
        str += "platform : " + self.platform + "\r\n";
        cc.log(str);
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = false;
cc._setupCalled = false;
cc._setup = function (el, width, height) {
    if (cc._setupCalled) return;
    else cc._setupCalled = true;
    var win = window;
    var lastTime = new Date();
    var frameTime = 1000 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
    var stTime = function(callback){
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, frameTime - (currTime - lastTime));
        var id = window.setTimeout(function() { callback(); },
            timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    var ctTime = function(id){
        clearTimeout(id);
    };
    if(cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT){
        win.requestAnimFrame = stTime;
        win.cancelAnimationFrame = ctTime;
    }else if(cc.game.config[cc.game.CONFIG_KEY.frameRate] != 60){
        win.requestAnimFrame = stTime;
        win.cancelAnimationFrame = ctTime;
    }else{
        win.requestAnimFrame = win.requestAnimationFrame ||
            win.webkitRequestAnimationFrame ||
            win.mozRequestAnimationFrame ||
            win.oRequestAnimationFrame ||
            win.msRequestAnimationFrame ||
            stTime;
        win.cancelAnimationFrame = window.cancelAnimationFrame ||
            window.cancelRequestAnimationFrame ||
            window.msCancelRequestAnimationFrame ||
            window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame ||
            window.webkitCancelRequestAnimationFrame ||
            window.msCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.oCancelAnimationFrame ||
            ctTime;
    }
    var element = cc.$(el) || cc.$('#' + el);
    var localCanvas, localContainer, localConStyle;
    if (element.tagName == "CANVAS") {
        width = width || element.width;
        height = height || element.height;
        localContainer = cc.container = cc.newElement("DIV");
        localCanvas = cc._canvas = element;
        localCanvas.parentNode.insertBefore(localContainer, localCanvas);
        localCanvas.appendTo(localContainer);
        localContainer.setAttribute('id', 'Cocos2dGameContainer');
    } else {//we must make a new canvas and place into this element
        if (element.tagName != "DIV") {
            cc.log("Warning: target element is not a DIV or CANVAS");
        }
        width = width || element.clientWidth;
        height = height || element.clientHeight;
        localContainer = cc.container = element;
        localCanvas = cc._canvas = cc.$(cc.newElement("CANVAS"));
        element.appendChild(localCanvas);
    }
    localCanvas.addClass("gameCanvas");
    localCanvas.setAttribute("width", width || 480);
    localCanvas.setAttribute("height", height || 320);
    localCanvas.setAttribute("tabindex", 99);
    localCanvas.style.outline = "none";
    localConStyle = localContainer.style;
    localConStyle.width = (width || 480) + "px";
    localConStyle.height = (height || 320) + "px";
    localConStyle.margin = "0 auto";
    localConStyle.position = 'relative';
    localConStyle.overflow = 'hidden';
    localContainer.top = '100%';
    if (cc._renderType == cc._RENDER_TYPE_WEBGL)
        cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, {
            'stencil': true,
            'preserveDrawingBuffer': true,
            'antialias': !cc.sys.isMobile,
            'alpha': false});
    if (cc._renderContext) {
        win.gl = cc._renderContext;
        cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext);
        cc._rendererInitialized = true;
        cc.textureCache._initializingRenderer();
        cc.shaderCache._init();
    } else {
        cc._renderContext = localCanvas.getContext("2d");
        cc._mainRenderContextBackup = cc._renderContext;
        cc._renderContext.translate(0, localCanvas.height);
        cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null;
    }
    cc._gameDiv = localContainer;
    cc.log(cc.ENGINE_VERSION);
    cc._setContextMenuEnable(false);
    if (cc.sys.isMobile) {
        var fontStyle = cc.newElement("style");
        fontStyle.type = "text/css";
        document.body.appendChild(fontStyle);
        fontStyle.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;"
            + "-webkit-tap-highlight-color:rgba(0,0,0,0);}";
    }
    cc.view = cc.EGLView._getInstance();
    cc.inputManager.registerSystemEvent(cc._canvas);
    cc.director = cc.Director._getInstance();
    if (cc.director.setOpenGLView)
        cc.director.setOpenGLView(cc.view);
    cc.winSize = cc.director.getWinSize();
    cc.saxParser = new cc.SAXParser();
    cc.plistParser = new cc.PlistParser();
};
cc._checkWebGLRenderMode = function () {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL)
        throw "This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = false;
cc._setContextMenuEnable = function (enabled) {
    cc._isContextMenuEnable = enabled;
    cc._canvas.oncontextmenu = function () {
        if (!cc._isContextMenuEnable) return false;
    };
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: false,//whether the prepare function has been called
    _prepared: false,//whether the engine has prepared
    _paused: true,//whether the game is paused
    _intervalId: null,//interval target of main
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function (frameRate) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        config[CONFIG_KEY.frameRate] = frameRate;
        if (self._intervalId)
            window.cancelAnimationFrame(self._intervalId);
        self._paused = true;
        self._runMainLoop();
    },
    _runMainLoop: function () {
        var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY,
            director = cc.director;
        director.setDisplayStats(config[CONFIG_KEY.showFPS]);
        callback = function () {
            if (!self._paused) {
                director.mainLoop();
                if(self._intervalId)
                    window.cancelAnimationFrame(self._intervalId);
                self._intervalId = window.requestAnimFrame(callback);
            }
        };
        window.requestAnimFrame(callback);
        self._paused = false;
    },
    run: function (id) {
        var self = this;
        var _run = function () {
            if (id) {
                self.config[self.CONFIG_KEY.id] = id;
            }
            if (!self._prepareCalled) {
                self.prepare(function () {
                    self._prepared = true;
                });
            }
            if (cc._supportRender) {
                self._checkPrepare = setInterval(function () {
                    if (self._prepared) {
                        cc._setup(self.config[self.CONFIG_KEY.id]);
                        self._runMainLoop();
                        self._eventHide = self._eventHide || new cc.EventCustom(self.EVENT_HIDE);
                        self._eventHide.setUserData(self);
                        self._eventShow = self._eventShow || new cc.EventCustom(self.EVENT_SHOW);
                        self._eventShow.setUserData(self);
                        self.onStart();
                        clearInterval(self._checkPrepare);
                    }
                }, 10);
            }
        };
        document.body ?
            _run() :
            cc._addEventListener(window, 'load', function () {
                this.removeEventListener('load', arguments.callee, false);
                _run();
            }, false);
    },
    _initConfig: function () {
        var self = this, CONFIG_KEY = self.CONFIG_KEY;
        var _init = function (cfg) {
            cfg[CONFIG_KEY.engineDir] = cfg[CONFIG_KEY.engineDir] || "frameworks/cocos2d-html5";
            if(cfg[CONFIG_KEY.debugMode] == null)
                cfg[CONFIG_KEY.debugMode] = 0;
            cfg[CONFIG_KEY.frameRate] = cfg[CONFIG_KEY.frameRate] || 60;
            if(cfg[CONFIG_KEY.renderMode] == null)
                cfg[CONFIG_KEY.renderMode] = 1;
            return cfg;
        };
        if (document["ccConfig"]) {
            self.config = _init(document["ccConfig"]);
        } else {
            try {
                var cocos_script = document.getElementsByTagName('script');
                for(var i=0;i<cocos_script.length;i++){
                    var _t = cocos_script[i].getAttribute('cocos');
                    if(_t == '' || _t){break;}
                }
                var _src, txt, _resPath;
                if(i < cocos_script.length){
                    _src = cocos_script[i].src;
                    if(_src){
                        _resPath = /(.*)\//.exec(_src)[0];
                        cc.loader.resPath = _resPath;
                        _src = cc.path.join(_resPath, 'project.json');
                    }
                    txt = cc.loader._loadTxtSync(_src);
                }
                if(!txt){
                    txt = cc.loader._loadTxtSync("project.json");
                }
                var data = JSON.parse(txt);
                self.config = _init(data || {});
            } catch (e) {
                cc.log("Failed to read or parse project.json");
                self.config = _init({});
            }
        }
        cc._initSys(self.config, CONFIG_KEY);
    },
    _jsAddedCache: {},
    _getJsListOfModule: function (moduleMap, moduleName, dir) {
        var jsAddedCache = this._jsAddedCache;
        if (jsAddedCache[moduleName]) return null;
        dir = dir || "";
        var jsList = [];
        var tempList = moduleMap[moduleName];
        if (!tempList) throw "can not find module [" + moduleName + "]";
        var ccPath = cc.path;
        for (var i = 0, li = tempList.length; i < li; i++) {
            var item = tempList[i];
            if (jsAddedCache[item]) continue;
            var extname = ccPath.extname(item);
            if (!extname) {
                var arr = this._getJsListOfModule(moduleMap, item, dir);
                if (arr) jsList = jsList.concat(arr);
            } else if (extname.toLowerCase() == ".js") jsList.push(ccPath.join(dir, item));
            jsAddedCache[item] = 1;
        }
        return jsList;
    },
    prepare: function (cb) {
        var self = this;
        var config = self.config, CONFIG_KEY = self.CONFIG_KEY, engineDir = config[CONFIG_KEY.engineDir], loader = cc.loader;
        if (!cc._supportRender) {
            throw "The renderer doesn't support the renderMode " + config[CONFIG_KEY.renderMode];
        }
        self._prepareCalled = true;
        var jsList = config[CONFIG_KEY.jsList] || [];
        if (cc.Class) {//is single file
            loader.loadJsWithImg("", jsList, function (err) {
                if (err) throw err;
                self._prepared = true;
                if (cb) cb();
            });
        } else {
            var ccModulesPath = cc.path.join(engineDir, "moduleConfig.json");
            loader.loadJson(ccModulesPath, function (err, modulesJson) {
                if (err) throw err;
                var modules = config["modules"] || [];
                var moduleMap = modulesJson["module"];
                var newJsList = [];
                if (cc._renderType == cc._RENDER_TYPE_WEBGL) modules.splice(0, 0, "shaders");
                else if (modules.indexOf("core") < 0) modules.splice(0, 0, "core");
                for (var i = 0, li = modules.length; i < li; i++) {
                    var arr = self._getJsListOfModule(moduleMap, modules[i], engineDir);
                    if (arr) newJsList = newJsList.concat(arr);
                }
                newJsList = newJsList.concat(jsList);
                cc.loader.loadJsWithImg(newJsList, function (err) {
                    if (err) throw err;
                    self._prepared = true;
                    if (cb) cb();
                });
            });
        }
    }
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function (oThis) {
    if (!cc.isFunction(this)) {
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }
    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis
                ? this
                : oThis,
                aArgs.concat(Array.prototype.slice.call(arguments)));
        };
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
};

var cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,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";
cc._loaderImage = "data:image/jpeg;base64,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";
cc.loader.loadBinary = function (url, cb) {
    var self = this;
    var xhr = this.getXMLHttpRequest(),
        errInfo = "load " + url + " failed!";
    xhr.open("GET", url, true);
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        xhr.setRequestHeader("Accept-Charset", "x-user-defined");
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                var fileContents = cc._convertResponseBodyToText(xhr["responseBody"]);
                cb(null, self._str2Uint8Array(fileContents));
            } else cb(errInfo);
        };
    } else {
        if (xhr.overrideMimeType) xhr.overrideMimeType("text\/plain; charset=x-user-defined");
        xhr.onload = function () {
            xhr.readyState == 4 && xhr.status == 200 ? cb(null, self._str2Uint8Array(xhr.responseText)) : cb(errInfo);
        };
    }
    xhr.send(null);
};
cc.loader._str2Uint8Array = function (strData) {
    if (!strData)
        return null;
    var arrData = new Uint8Array(strData.length);
    for (var i = 0; i < strData.length; i++) {
        arrData[i] = strData.charCodeAt(i) & 0xff;
    }
    return arrData;
};
cc.loader.loadBinarySync = function (url) {
    var self = this;
    var req = this.getXMLHttpRequest();
    var errInfo = "load " + url + " failed!";
    req.open('GET', url, false);
    var arrayInfo = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        req.setRequestHeader("Accept-Charset", "x-user-defined");
        req.send(null);
        if (req.status != 200) {
            cc.log(errInfo);
            return null;
        }
        var fileContents = cc._convertResponseBodyToText(req["responseBody"]);
        if (fileContents) {
            arrayInfo = self._str2Uint8Array(fileContents);
        }
    } else {
        if (req.overrideMimeType)
            req.overrideMimeType('text\/plain; charset=x-user-defined');
        req.send(null);
        if (req.status != 200) {
            cc.log(errInfo);
            return null;
        }
        arrayInfo = this._str2Uint8Array(req.responseText);
    }
    return arrayInfo;
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script =
        "<!-- IEBinaryToArray_ByteStr -->\r\n" +
            "Function IEBinaryToArray_ByteStr(Binary)\r\n" +
            "   IEBinaryToArray_ByteStr = CStr(Binary)\r\n" +
            "End Function\r\n" +
            "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n" +
            "   Dim lastIndex\r\n" +
            "   lastIndex = LenB(Binary)\r\n" +
            "   if lastIndex mod 2 Then\r\n" +
            "       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n" +
            "   Else\r\n" +
            "       IEBinaryToArray_ByteStr_Last = " + '""' + "\r\n" +
            "   End If\r\n" +
            "End Function\r\n";// +
    var myVBScript = cc.newElement('script');
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function (binary) {
        var byteMapping = {};
        for (var i = 0; i < 256; i++) {
            for (var j = 0; j < 256; j++) {
                byteMapping[ String.fromCharCode(i + j * 256) ] =
                    String.fromCharCode(i) + String.fromCharCode(j);
            }
        }
        var rawBytes = IEBinaryToArray_ByteStr(binary);
        var lastChr = IEBinaryToArray_ByteStr_Last(binary);
        return rawBytes.replace(/[\s\S]/g,
            function (match) {
                return byteMapping[match];
            }) + lastChr;
    };
}
var cc = cc || {};
var ClassManager = {
    id : (0|(Math.random()*998)),
    instanceId : (0|(Math.random()*998)),
    compileSuper : function(func, name, id){
        var str = func.toString();
        var pstart = str.indexOf('('), pend = str.indexOf(')');
        var params = str.substring(pstart+1, pend);
        params = params.trim();
        var bstart = str.indexOf('{'), bend = str.lastIndexOf('}');
        var str = str.substring(bstart+1, bend);
        while(str.indexOf('this._super')!= -1)
        {
            var sp = str.indexOf('this._super');
            var bp = str.indexOf('(', sp);
            var bbp = str.indexOf(')', bp);
            var superParams = str.substring(bp+1, bbp);
            superParams = superParams.trim();
            var coma = superParams? ',':'';
            str = str.substring(0, sp)+  'ClassManager['+id+'].'+name+'.call(this'+coma+str.substring(bp+1);
        }
        return Function(params, str);
    },
    getNewID : function(){
        return this.id++;
    },
    getNewInstanceId : function(){
        return this.instanceId++;
    }
};
ClassManager.compileSuper.ClassManager = ClassManager;
(function () {
    var fnTest = /\b_super\b/;
    var config = cc.game.config;
    var releaseMode = config[cc.game.CONFIG_KEY.classReleaseMode];
    if(releaseMode) {
        console.log("release Mode");
    }
    cc.Class = function () {
    };
    cc.Class.extend = function (props) {
        var _super = this.prototype;
        var prototype = Object.create(_super);
        var classId = ClassManager.getNewID();
        ClassManager[classId] = _super;
        var desc = { writable: true, enumerable: false, configurable: true };
	    prototype.__instanceId = null;
	    function Class() {
		    this.__instanceId = ClassManager.getNewInstanceId();
		    if (this.ctor)
			    this.ctor.apply(this, arguments);
	    }
	    Class.id = classId;
	    desc.value = classId;
	    Object.defineProperty(prototype, '__pid', desc);
	    Class.prototype = prototype;
	    desc.value = Class;
	    Object.defineProperty(Class.prototype, 'constructor', desc);
	    this.__getters__ && (Class.__getters__ = cc.clone(this.__getters__));
	    this.__setters__ && (Class.__setters__ = cc.clone(this.__setters__));
        for(var idx = 0, li = arguments.length; idx < li; ++idx) {
            var prop = arguments[idx];
            for (var name in prop) {
                var isFunc = (typeof prop[name] === "function");
                var override = (typeof _super[name] === "function");
                var hasSuperCall = fnTest.test(prop[name]);
                if (releaseMode && isFunc && override && hasSuperCall) {
                    desc.value = ClassManager.compileSuper(prop[name], name, classId);
                    Object.defineProperty(prototype, name, desc);
                } else if (isFunc && override && hasSuperCall) {
                    desc.value = (function (name, fn) {
                        return function () {
                            var tmp = this._super;
                            this._super = _super[name];
                            var ret = fn.apply(this, arguments);
                            this._super = tmp;
                            return ret;
                        };
                    })(name, prop[name]);
                    Object.defineProperty(prototype, name, desc);
                } else if (isFunc) {
                    desc.value = prop[name];
                    Object.defineProperty(prototype, name, desc);
                } else {
                    prototype[name] = prop[name];
                }
                if (isFunc) {
                    var getter, setter, propertyName;
                    if (this.__getters__ && this.__getters__[name]) {
                        propertyName = this.__getters__[name];
                        for (var i in this.__setters__) {
                            if (this.__setters__[i] == propertyName) {
                                setter = i;
                                break;
                            }
                        }
                        cc.defineGetterSetter(prototype, propertyName, prop[name], prop[setter] ? prop[setter] : prototype[setter], name, setter);
                    }
                    if (this.__setters__ && this.__setters__[name]) {
                        propertyName = this.__setters__[name];
                        for (var i in this.__getters__) {
                            if (this.__getters__[i] == propertyName) {
                                getter = i;
                                break;
                            }
                        }
                        cc.defineGetterSetter(prototype, propertyName, prop[getter] ? prop[getter] : prototype[getter], prop[name], getter, name);
                    }
                }
            }
        }
        Class.extend = cc.Class.extend;
        Class.implement = function (prop) {
            for (var name in prop) {
                prototype[name] = prop[name];
            }
        };
        return Class;
    };
})();
cc.defineGetterSetter = function (proto, prop, getter, setter, getterName, setterName){
    if (proto.__defineGetter__) {
        getter && proto.__defineGetter__(prop, getter);
        setter && proto.__defineSetter__(prop, setter);
    } else if (Object.defineProperty) {
        var desc = { enumerable: false, configurable: true };
        getter && (desc.get = getter);
        setter && (desc.set = setter);
        Object.defineProperty(proto, prop, desc);
    } else {
        throw new Error("browser does not support getters");
    }
    if(!getterName && !setterName) {
        var hasGetter = (getter != null), hasSetter = (setter != undefined), props = Object.getOwnPropertyNames(proto);
        for (var i = 0; i < props.length; i++) {
            var name = props[i];
            if( (proto.__lookupGetter__ ? proto.__lookupGetter__(name)
                                        : Object.getOwnPropertyDescriptor(proto, name))
                || typeof proto[name] !== "function" )
                continue;
            var func = proto[name];
            if (hasGetter && func === getter) {
                getterName = name;
                if(!hasSetter || setterName) break;
            }
            if (hasSetter && func === setter) {
                setterName = name;
                if(!hasGetter || getterName) break;
            }
        }
    }
    var ctor = proto.constructor;
    if (getterName) {
        if (!ctor.__getters__) {
            ctor.__getters__ = {};
        }
        ctor.__getters__[getterName] = prop;
    }
    if (setterName) {
        if (!ctor.__setters__) {
            ctor.__setters__ = {};
        }
        ctor.__setters__[setterName] = prop;
    }
};
cc.clone = function (obj) {
    var newObj = (obj.constructor) ? new obj.constructor : {};
    for (var key in obj) {
        var copy = obj[key];
        if (((typeof copy) == "object") && copy &&
            !(copy instanceof cc.Node) && !(copy instanceof HTMLElement)) {
            newObj[key] = cc.clone(copy);
        } else {
            newObj[key] = copy;
        }
    }
    return newObj;
};
cc.Point = function (x, y) {
    this.x = x || 0;
    this.y = y || 0;
};
cc.p = function (x, y) {
    if (x == undefined)
        return {x: 0, y: 0};
    if (y == undefined)
        return {x: x.x, y: x.y};
    return {x: x, y: y};
};
cc.pointEqualToPoint = function (point1, point2) {
    return point1 && point2 && (point1.x === point2.x) && (point1.y === point2.y);
};
cc.Size = function (width, height) {
    this.width = width || 0;
    this.height = height || 0;
};
cc.size = function (w, h) {
    if (w === undefined)
        return {width: 0, height: 0};
    if (h === undefined)
        return {width: w.width, height: w.height};
    return {width: w, height: h};
};
cc.sizeEqualToSize = function (size1, size2) {
    return (size1 && size2 && (size1.width == size2.width) && (size1.height == size2.height));
};
cc.Rect = function (x, y, width, height) {
    this.x = x||0;
    this.y = y||0;
    this.width = width||0;
    this.height = height||0;
};
cc.rect = function (x, y, w, h) {
    if (x === undefined)
        return {x: 0, y: 0, width: 0, height: 0};
    if (y === undefined)
        return {x: x.x, y: x.y, width: x.width, height: x.height};
    return {x: x, y: y, width: w, height: h };
};
cc.rectEqualToRect = function (rect1, rect2) {
    return rect1 && rect2 && (rect1.x === rect2.x) && (rect1.y === rect2.y) && (rect1.width === rect2.width) && (rect1.height === rect2.height);
};
cc._rectEqualToZero = function(rect){
    return rect && (rect.x === 0) && (rect.y === 0) && (rect.width === 0) && (rect.height === 0);
};
cc.rectContainsRect = function (rect1, rect2) {
    if (!rect1 || !rect2)
        return false;
    return !((rect1.x >= rect2.x) || (rect1.y >= rect2.y) ||
        ( rect1.x + rect1.width <= rect2.x + rect2.width) ||
        ( rect1.y + rect1.height <= rect2.y + rect2.height));
};
cc.rectGetMaxX = function (rect) {
    return (rect.x + rect.width);
};
cc.rectGetMidX = function (rect) {
    return (rect.x + rect.width / 2.0);
};
cc.rectGetMinX = function (rect) {
    return rect.x;
};
cc.rectGetMaxY = function (rect) {
    return(rect.y + rect.height);
};
cc.rectGetMidY = function (rect) {
    return rect.y + rect.height / 2.0;
};
cc.rectGetMinY = function (rect) {
    return rect.y;
};
cc.rectContainsPoint = function (rect, point) {
    return (point.x >= cc.rectGetMinX(rect) && point.x <= cc.rectGetMaxX(rect) &&
        point.y >= cc.rectGetMinY(rect) && point.y <= cc.rectGetMaxY(rect)) ;
};
cc.rectIntersectsRect = function (ra, rb) {
    var maxax = ra.x + ra.width,
        maxay = ra.y + ra.height,
        maxbx = rb.x + rb.width,
        maxby = rb.y + rb.height;
    return !(maxax < rb.x || maxbx < ra.x || maxay < rb.y || maxby < ra.y);
};
cc.rectOverlapsRect = function (rectA, rectB) {
    return !((rectA.x + rectA.width < rectB.x) ||
        (rectB.x + rectB.width < rectA.x) ||
        (rectA.y + rectA.height < rectB.y) ||
        (rectB.y + rectB.height < rectA.y));
};
cc.rectUnion = function (rectA, rectB) {
    var rect = cc.rect(0, 0, 0, 0);
    rect.x = Math.min(rectA.x, rectB.x);
    rect.y = Math.min(rectA.y, rectB.y);
    rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
    rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
    return rect;
};
cc.rectIntersection = function (rectA, rectB) {
    var intersection = cc.rect(
        Math.max(cc.rectGetMinX(rectA), cc.rectGetMinX(rectB)),
        Math.max(cc.rectGetMinY(rectA), cc.rectGetMinY(rectB)),
        0, 0);
    intersection.width = Math.min(cc.rectGetMaxX(rectA), cc.rectGetMaxX(rectB)) - cc.rectGetMinX(intersection);
    intersection.height = Math.min(cc.rectGetMaxY(rectA), cc.rectGetMaxY(rectB)) - cc.rectGetMinY(intersection);
    return intersection;
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function () {
        if (window.DOMParser) {
            this._isSupportDOMParser = true;
            this._parser = new DOMParser();
        } else {
            this._isSupportDOMParser = false;
        }
    },
    parse : function(xmlTxt){
        return this._parseXML(xmlTxt);
    },
    _parseXML: function (textxml) {
        var xmlDoc;
        if (this._isSupportDOMParser) {
            xmlDoc = this._parser.parseFromString(textxml, "text/xml");
        } else {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = "false";
            xmlDoc.loadXML(textxml);
        }
        return xmlDoc;
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse : function (xmlTxt) {
        var xmlDoc = this._parseXML(xmlTxt);
        var plist = xmlDoc.documentElement;
        if (plist.tagName != 'plist')
            throw "Not a plist file!";
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == 1)
                break;
        }
        xmlDoc = null;
        return this._parseNode(node);
    },
    _parseNode: function (node) {
        var data = null, tagName = node.tagName;
        if(tagName == "dict"){
            data = this._parseDict(node);
        }else if(tagName == "array"){
            data = this._parseArray(node);
        }else if(tagName == "string"){
            if (node.childNodes.length == 1)
                data = node.firstChild.nodeValue;
            else {
                data = "";
                for (var i = 0; i < node.childNodes.length; i++)
                    data += node.childNodes[i].nodeValue;
            }
        }else if(tagName == "false"){
            data = false;
        }else if(tagName == "true"){
            data = true;
        }else if(tagName == "real"){
            data = parseFloat(node.firstChild.nodeValue);
        }else if(tagName == "integer"){
            data = parseInt(node.firstChild.nodeValue, 10);
        }
        return data;
    },
    _parseArray: function (node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1)
                continue;
            data.push(this._parseNode(child));
        }
        return data;
    },
    _parseDict: function (node) {
        var data = {};
        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1)
                continue;
            if (child.tagName == 'key')
                key = child.firstChild.nodeValue;
            else
                data[key] = this._parseNode(child);
        }
        return data;
    }
});
cc._txtLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadTxt(realUrl, cb);
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadJson(realUrl, cb);
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.cache[url] =  cc.loader.loadImg(realUrl, function(err, img){
            if(err)
                return cb(err);
            cc.textureCache.handleLoadedTexture(url);
            cb(null, img);
        });
    }
};
cc.loader.register(["png", "jpg", "bmp","jpeg","gif", "ico"], cc._imgLoader);
cc._serverImgLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.cache[url] =  cc.loader.loadImg(res.src, function(err, img){
            if(err)
                return cb(err);
            cc.textureCache.handleLoadedTexture(url);
            cb(null, img);
        });
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadTxt(realUrl, function(err, txt){
            if(err)
                return cb(err);
            cb(null, cc.plistParser.parse(txt));
        });
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE : {
        ".eot" : "embedded-opentype",
        ".ttf" : "truetype",
        ".woff" : "woff",
        ".svg" : "svg"
    },
    _loadFont : function(name, srcs, type){
        var doc = document, path = cc.path, TYPE = this.TYPE, fontStyle = cc.newElement("style");
        fontStyle.type = "text/css";
        doc.body.appendChild(fontStyle);
        var fontStr = "@font-face { font-family:" + name + "; src:";
        if(srcs instanceof Array){
            for(var i = 0, li = srcs.length; i < li; i++){
                var src = srcs[i];
                type = path.extname(src).toLowerCase();
                fontStr += "url('" + srcs[i] + "') format('" + TYPE[type] + "')";
                fontStr += (i == li - 1) ? ";" : ",";
            }
        }else{
            fontStr += "url('" + srcs + "') format('" + TYPE[type] + "');";
        }
        fontStyle.textContent += fontStr + "};";
        var preloadDiv = cc.newElement("div");
        var _divStyle =  preloadDiv.style;
        _divStyle.fontFamily = name;
        preloadDiv.innerHTML = ".";
        _divStyle.position = "absolute";
        _divStyle.left = "-100px";
        _divStyle.top = "-100px";
        doc.body.appendChild(preloadDiv);
    },
    load : function(realUrl, url, res, cb){
        var self = this;
        var type = res.type, name = res.name, srcs = res.srcs;
        if(cc.isString(res)){
            type = cc.path.extname(res);
            name = cc.path.basename(res, type);
            self._loadFont(name, res, type);
        }else{
            self._loadFont(name, srcs);
        }
        cb(null, true);
    }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
    load : function(realUrl, url, res, cb){
        cc.loader.loadBinary(realUrl, cb);
    }
};
cc._csbLoader = {
    load: function(realUrl, url, res, cb){
        cc.loader.loadCsb(realUrl, cb);
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window["CocosEngine"] = cc.ENGINE_VERSION = "Cocos2d-JS v3.1";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function (x) {
    var parent = (this == cc) ? document : this;
    var el = (x instanceof HTMLElement) ? x : parent.querySelector(x);
    if (el) {
        el.find = el.find || cc.$;
        el.hasClass = el.hasClass || function (cls) {
            return this.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
        };
        el.addClass = el.addClass || function (cls) {
            if (!this.hasClass(cls)) {
                if (this.className) {
                    this.className += " ";
                }
                this.className += cls;
            }
            return this;
        };
        el.removeClass = el.removeClass || function (cls) {
            if (this.hasClass(cls)) {
                this.className = this.className.replace(cls, '');
            }
            return this;
        };
        el.remove = el.remove || function () {
            if (this.parentNode)
                this.parentNode.removeChild(this);
            return this;
        };
        el.appendTo = el.appendTo || function (x) {
            x.appendChild(this);
            return this;
        };
        el.prependTo = el.prependTo || function (x) {
            ( x.childNodes[0]) ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
            return this;
        };
        el.transforms = el.transforms || function () {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this;
        };
        el.position = el.position || {x: 0, y: 0};
        el.rotation = el.rotation || 0;
        el.scale = el.scale || {x: 1, y: 1};
        el.skew = el.skew || {x: 0, y: 0};
        el.translates = function (x, y) {
            this.position.x = x;
            this.position.y = y;
            this.transforms();
            return this
        };
        el.rotate = function (x) {
            this.rotation = x;
            this.transforms();
            return this
        };
        el.resize = function (x, y) {
            this.scale.x = x;
            this.scale.y = y;
            this.transforms();
            return this
        };
        el.setSkew = function (x, y) {
            this.skew.x = x;
            this.skew.y = y;
            this.transforms();
            return this
        };
    }
    return el;
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = true;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = true;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = false;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = false;
        break;
    default:
        cc.$.pfx = "webkit";
        cc.$.hd = true;
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = (cc.$.hd) ? function (a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = (cc.$.hd) ? function (a) {
    return "rotateZ(" + a + "deg) ";
} : function (a) {
    return "rotate(" + a + "deg) ";
};
cc.$.scale = function (a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
};
cc.$new = function (x) {
    return cc.$(document.createElement(x))
};
cc.$.findpos = function (obj) {
    var curleft = 0;
    var curtop = 0;
    do {
        curleft += obj.offsetLeft;
        curtop += obj.offsetTop;
    } while (obj = obj.offsetParent);
    return {x: curleft, y: curtop};
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat('3.402823466e+38F');
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 0xffffffff;
cc.swap = function (x, y, ref) {
    if (cc.isObject(ref) && !cc.isUndefined(ref.x) && !cc.isUndefined(ref.y)) {
        var tmp = ref[x];
        ref[x] = ref[y];
        ref[y] = tmp;
    } else
        cc.log(cc._LogInfos.swap);
};
cc.lerp = function (a, b, r) {
    return a + (b - a) * r;
};
cc.rand = function () {
	return Math.random() * 0xffffff;
};
cc.randomMinus1To1 = function () {
    return (Math.random() - 0.5) * 2;
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function (angle) {
    return angle * cc.RAD;
};
cc.radiansToDegrees = function (angle) {
    return angle * cc.DEG;
};
cc.radiansToDegress = function (angle) {
    cc.log(cc._LogInfos.radiansToDegress);
    return angle * cc.DEG;
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 0x0302;
cc.BLEND_DST = 0x0303;
cc.nodeDrawSetup = function (node) {
    if (node._shaderProgram) {
        node._shaderProgram.use();
        node._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
    }
};
cc.enableDefaultGLStates = function () {
};
cc.disableDefaultGLStates = function () {
};
cc.incrementGLDraws = function (addNumber) {
    cc.g_NumberOfDraws += addNumber;
};
cc.FLT_EPSILON = 0.0000001192092896;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.director.getContentScaleFactor();
} : function () {
    return 1;
};
cc.pointPointsToPixels = function (points) {
    var scale = cc.contentScaleFactor();
    return cc.p(points.x * scale, points.y * scale);
};
cc.pointPixelsToPoints = function (pixels) {
	var scale = cc.contentScaleFactor();
	return cc.p(pixels.x / scale, pixels.y / scale);
};
cc._pointPixelsToPointsOut = function(pixels, outPoint){
	var scale = cc.contentScaleFactor();
	outPoint.x = pixels.x / scale;
	outPoint.y = pixels.y / scale;
};
cc.sizePointsToPixels = function (sizeInPoints) {
    var scale = cc.contentScaleFactor();
    return cc.size(sizeInPoints.width * scale, sizeInPoints.height * scale);
};
cc.sizePixelsToPoints = function (sizeInPixels) {
    var scale = cc.contentScaleFactor();
    return cc.size(sizeInPixels.width / scale, sizeInPixels.height / scale);
};
cc._sizePixelsToPointsOut = function (sizeInPixels, outSize) {
    var scale = cc.contentScaleFactor();
    outSize.width = sizeInPixels.width / scale;
    outSize.height = sizeInPixels.height / scale;
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (pixel) {
    var scale = cc.contentScaleFactor();
    return cc.rect(pixel.x / scale, pixel.y / scale,
        pixel.width / scale, pixel.height / scale);
} : function (p) {
    return p;
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (point) {
   var scale = cc.contentScaleFactor();
    return cc.rect(point.x * scale, point.y * scale,
        point.width * scale, point.height * scale);
} : function (p) {
    return p;
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 0x0302;
cc.SRC_ALPHA_SATURATE = 0x308;
cc.SRC_COLOR = 0x300;
cc.DST_ALPHA = 0x304;
cc.DST_COLOR = 0x306;
cc.ONE_MINUS_SRC_ALPHA = 0x0303;
cc.ONE_MINUS_SRC_COLOR = 0x301;
cc.ONE_MINUS_DST_ALPHA = 0x305;
cc.ONE_MINUS_DST_COLOR = 0x0307;
cc.ONE_MINUS_CONSTANT_ALPHA	= 0x8004;
cc.ONE_MINUS_CONSTANT_COLOR	= 0x8002;
cc.checkGLErrorDebug = function () {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var _error = cc._renderContext.getError();
        if (_error) {
            cc.log(cc._LogInfos.checkGLErrorDebug, _error);
        }
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1 << 0;
cc.VERTEX_ATTRIB_FLAG_COLOR = 1 << 1;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 1 << 2;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = ( cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS );
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 0xc0c05001;
cc.ZOOM_ACTION_TAG = 0xc0c05002;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function (arr, type) {
    if (arr && arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
            if (!(arr[i] instanceof  type)) {
                cc.log("element type is wrong!");
                return false;
            }
        }
    }
    return true;
};
cc.arrayRemoveObject = function (arr, delObj) {
    for (var i = 0, l = arr.length; i < l; i++) {
        if (arr[i] == delObj) {
            arr.splice(i, 1);
            break;
        }
    }
};
cc.arrayRemoveArray = function (arr, minusArr) {
    for (var i = 0, l = minusArr.length; i < l; i++) {
        cc.arrayRemoveObject(arr, minusArr[i]);
    }
};
cc.arrayAppendObjectsToIndex = function(arr, addObjs,index){
    arr.splice.apply(arr, [index, 0].concat(addObjs));
    return arr;
};
cc.copyArray = function(arr){
    var i, len = arr.length, arr_clone = new Array(len);
    for (i = 0; i < len; i += 1)
        arr_clone[i] = arr[i];
    return arr_clone;
};
cc._tmp.PrototypeColor = function () {
    var _p = cc.color;
    _p._getWhite = function () {
        return _p(255, 255, 255);
    };
    _p._getYellow = function () {
        return _p(255, 255, 0);
    };
    _p._getBlue = function () {
        return  _p(0, 0, 255);
    };
    _p._getGreen = function () {
        return _p(0, 255, 0);
    };
    _p._getRed = function () {
        return _p(255, 0, 0);
    };
    _p._getMagenta = function () {
        return _p(255, 0, 255);
    };
    _p._getBlack = function () {
        return _p(0, 0, 0);
    };
    _p._getOrange = function () {
        return _p(255, 127, 0);
    };
    _p._getGray = function () {
        return _p(166, 166, 166);
    };
    _p.WHITE;
    cc.defineGetterSetter(_p, "WHITE", _p._getWhite);
    _p.YELLOW;
    cc.defineGetterSetter(_p, "YELLOW", _p._getYellow);
    _p.BLUE;
    cc.defineGetterSetter(_p, "BLUE", _p._getBlue);
    _p.GREEN;
    cc.defineGetterSetter(_p, "GREEN", _p._getGreen);
    _p.RED;
    cc.defineGetterSetter(_p, "RED", _p._getRed);
    _p.MAGENTA;
    cc.defineGetterSetter(_p, "MAGENTA", _p._getMagenta);
    _p.BLACK;
    cc.defineGetterSetter(_p, "BLACK", _p._getBlack);
    _p.ORANGE;
    cc.defineGetterSetter(_p, "ORANGE", _p._getOrange);
    _p.GRAY;
    cc.defineGetterSetter(_p, "GRAY", _p._getGray);
    cc.BlendFunc._disable = function(){
        return new cc.BlendFunc(cc.ONE, cc.ZERO);
    };
    cc.BlendFunc._alphaPremultiplied = function(){
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._alphaNonPremultiplied = function(){
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
    };
    cc.BlendFunc._additive = function(){
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE);
    };
    cc.BlendFunc.DISABLE;
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.BlendFunc.ALPHA_PREMULTIPLIED;
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.BlendFunc.ADDITIVE;
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
};
cc.Color = function (r, g, b, a) {
    this.r = r || 0;
    this.g = g || 0;
    this.b = b || 0;
    this.a = (a == null) ? 255 : a;
};
cc.color = function (r, g, b, a) {
    if (r === undefined)
        return {r: 0, g: 0, b: 0, a: 255};
    if (cc.isString(r))
        return cc.hexToColor(r);
    if (cc.isObject(r))
        return {r: r.r, g: r.g, b: r.b, a: (r.a == null) ? 255 : r.a};
    return  {r: r, g: g, b: b, a: (a == null ? 255 : a)};
};
cc.colorEqual = function (color1, color2) {
    return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
};
cc.Acceleration = function (x, y, z, timestamp) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.timestamp = timestamp || 0;
};
cc.Vertex2F = function (x1, y1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
};
cc.vertex2 = function (x, y) {
    return new cc.Vertex2F(x, y);
};
cc.Vertex3F = function (x1, y1, z1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
    this.z = z1 || 0;
};
cc.vertex3 = function (x, y, z) {
    return new cc.Vertex3F(x, y, z);
};
cc.Tex2F = function (u1, v1) {
    this.u = u1 || 0;
    this.v = v1 || 0;
};
cc.tex2 = function (u, v) {
    return new cc.Tex2F(u, v);
};
cc.BlendFunc = function (src1, dst1) {
    this.src = src1;
    this.dst = dst1;
};
cc.blendFuncDisable = function () {
    return new cc.BlendFunc(cc.ONE, cc.ZERO);
};
cc.hexToColor = function (hex) {
    hex = hex.replace(/^#?/, "0x");
    var c = parseInt(hex);
    var r = c >> 16;
    var g = (c >> 8) % 256;
    var b = c % 256;
    return cc.color(r, g, b);
};
cc.colorToHex = function (color) {
    var hR = color.r.toString(16), hG = color.g.toString(16), hB = color.b.toString(16);
    return "#" + (color.r < 16 ? ("0" + hR) : hR) + (color.g < 16 ? ("0" + hG) : hG) + (color.b < 16 ? ("0" + hB) : hB);
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | (Math.random() * 10));
    },
    __getKey: function () {
        this.__currId++;
        return "key_" + this.__currId;
    },
    setObject: function (value, key) {
        if (key == null)
            return;
        var keyId = this.__getKey();
        this._keyMapTb[keyId] = key;
        this._valueMapTb[keyId] = value;
    },
    objectForKey: function (key) {
        if (key == null)
            return null;
        var locKeyMapTb = this._keyMapTb;
        for (var keyId in locKeyMapTb) {
            if (locKeyMapTb[keyId] === key)
                return this._valueMapTb[keyId];
        }
        return null;
    },
    valueForKey: function (key) {
        return this.objectForKey(key);
    },
    removeObjectForKey: function (key) {
        if (key == null)
            return;
        var locKeyMapTb = this._keyMapTb;
        for (var keyId in locKeyMapTb) {
            if (locKeyMapTb[keyId] === key) {
                delete this._valueMapTb[keyId];
                delete locKeyMapTb[keyId];
                return;
            }
        }
    },
    removeObjectsForKeys: function (keys) {
        if (keys == null)
            return;
        for (var i = 0; i < keys.length; i++)
            this.removeObjectForKey(keys[i]);
    },
    allKeys: function () {
        var keyArr = [], locKeyMapTb = this._keyMapTb;
        for (var key in locKeyMapTb)
            keyArr.push(locKeyMapTb[key]);
        return keyArr;
    },
    removeAllObjects: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
    },
    count: function () {
        return this.allKeys().length;
    }
});
cc.FontDefinition = function () {
    var _t = this;
    _t.fontName = "Arial";
    _t.fontSize = 12;
    _t.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    _t.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    _t.fillStyle = cc.color(255, 255, 255, 255);
    _t.boundingWidth = 0;
    _t.boundingHeight = 0;
    _t.strokeEnabled = false;
    _t.strokeStyle = cc.color(255, 255, 255, 255);
    _t.lineWidth = 1;
    _t.shadowEnabled = false;
    _t.shadowOffsetX = 0;
    _t.shadowOffsetY = 0;
    _t.shadowBlur = 0;
    _t.shadowOpacity = 1.0;
};
if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
    cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js");
    cc._tmp.WebGLColor();
    delete cc._tmp.WebGLColor;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
	_retinaEnabled: false,
    _autoFullScreen: true,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: false,
    _captured: false,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: false,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1.0,
    __resizeWithBrowserSize: false,
    _isAdjustViewPort: true,
    _targetDensityDPI: null,
    ctor: function () {
        var _t = this, d = document, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
        _t._frame = (cc.container.parentNode === d.body) ? d.documentElement : cc.container.parentNode;
        _t._frameSize = cc.size(0, 0);
        _t._initFrameSize();
        var w = cc._canvas.width, h = cc._canvas.height;
        _t._designResolutionSize = cc.size(w, h);
        _t._originalDesignResolutionSize = cc.size(w, h);
        _t._viewPortRect = cc.rect(0, 0, w, h);
        _t._visibleRect = cc.rect(0, 0, w, h);
        _t._contentTranslateLeftTop = {left: 0, top: 0};
        _t._viewName = "Cocos2dHTML5";
	    var sys = cc.sys;
        _t.enableRetina(sys.os == sys.OS_IOS || sys.os == sys.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
        _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
        _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
        _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
        _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
        _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
        _t._hDC = cc._canvas;
        _t._hRC = cc._renderContext;
        _t._targetDensityDPI = cc.DENSITYDPI_HIGH;
    },
    _resizeEvent: function () {
        var width = this._originalDesignResolutionSize.width;
        var height = this._originalDesignResolutionSize.height;
        if (this._resizeCallback) {
            this._initFrameSize();
            this._resizeCallback.call();
        }
        if (width > 0)
            this.setDesignResolutionSize(width, height, this._resolutionPolicy);
    },
    setTargetDensityDPI: function(densityDPI){
        this._targetDensityDPI = densityDPI;
        this._setViewPortMeta();
    },
    getTargetDensityDPI: function(){
        return this._targetDensityDPI;
    },
    resizeWithBrowserSize: function (enabled) {
        var adjustSize, _t = this;
        if (enabled) {
            if (!_t.__resizeWithBrowserSize) {
                _t.__resizeWithBrowserSize = true;
                adjustSize = _t._resizeEvent.bind(_t);
                cc._addEventListener(window, 'resize', adjustSize, false);
            }
        } else {
            if (_t.__resizeWithBrowserSize) {
                _t.__resizeWithBrowserSize = true;
                adjustSize = _t._resizeEvent.bind(_t);
                window.removeEventListener('resize', adjustSize, false);
            }
        }
    },
    setResizeCallback: function (callback) {
        if (cc.isFunction(callback) || callback == null) {
            this._resizeCallback = callback;
        }
    },
    _initFrameSize: function () {
        var locFrameSize = this._frameSize;
        locFrameSize.width = this._frame.clientWidth;
        locFrameSize.height = this._frame.clientHeight;
    },
    _adjustSizeKeepCanvasSize: function () {
        var designWidth = this._originalDesignResolutionSize.width;
        var designHeight = this._originalDesignResolutionSize.height;
        if (designWidth > 0)
            this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
    },
    _setViewPortMeta: function () {
        if (this._isAdjustViewPort) {
            var vp = document.getElementById("cocosMetaElement");
            if(vp){
                document.head.removeChild(vp);
            }
            var viewportMetas,
                elems = document.getElementsByName("viewport"),
                currentVP = elems ? elems[0] : null,
                content;
            vp = cc.newElement("meta");
            vp.id = "cocosMetaElement";
            vp.name = "viewport";
            vp.content = "";
            if (cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX) {
                viewportMetas = {"width": "device-width", "initial-scale": "1.0"};
            }else{
                viewportMetas = {"width": "device-width", "user-scalable": "no", "maximum-scale": "1.0", "initial-scale": "1.0"};
            }
            if(cc.sys.isMobile)
                viewportMetas["target-densitydpi"] = this._targetDensityDPI;
            content = currentVP ? currentVP.content : "";
            for (var key in viewportMetas) {
                var pattern = new RegExp(key);
                if (!pattern.test(content)) {
                    content += "," + key + "=" + viewportMetas[key];
                }
            }
            if(content != "")
                content = content.substr(1);
            vp.content = content;
            if (currentVP)
                currentVP.content = content;
            document.head.appendChild(vp);
        }
    },
    _setScaleXYForRenderTexture: function () {
        var scaleFactor = cc.contentScaleFactor();
        this._scaleX = scaleFactor;
        this._scaleY = scaleFactor;
    },
    _resetScale: function () {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY;
    },
    _adjustSizeToBrowser: function () {
    },
    initialize: function () {
        this._initialized = true;
    },
    adjustViewPort: function (enabled) {
        this._isAdjustViewPort = enabled;
    },
	enableRetina: function(enabled) {
		this._retinaEnabled = enabled ? true : false;
	},
	isRetinaEnabled: function() {
		return this._retinaEnabled;
	},
    enableAutoFullScreen: function(enabled) {
        this._autoFullScreen = enabled ? true : false;
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen;
    },
    end: function () {
    },
    isOpenGLReady: function () {
        return (this._hDC != null && this._hRC != null);
    },
    setFrameZoomFactor: function (zoomFactor) {
        this._frameZoomFactor = zoomFactor;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection());
    },
    swapBuffers: function () {
    },
    setIMEKeyboardState: function (isOpen) {
    },
    setContentTranslateLeftTop: function (offsetLeft, offsetTop) {
        this._contentTranslateLeftTop = {left: offsetLeft, top: offsetTop};
    },
    getContentTranslateLeftTop: function () {
        return this._contentTranslateLeftTop;
    },
    getFrameSize: function () {
        return cc.size(this._frameSize.width, this._frameSize.height);
    },
    setFrameSize: function (width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        this._frame.style.width = width + "px";
        this._frame.style.height = height + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection());
    },
    centerWindow: function () {
    },
    getVisibleSize: function () {
        return cc.size(this._visibleRect.width,this._visibleRect.height);
    },
    getVisibleOrigin: function () {
        return cc.p(this._visibleRect.x,this._visibleRect.y);
    },
    canSetContentScaleFactor: function () {
        return true;
    },
    getResolutionPolicy: function () {
        return this._resolutionPolicy;
    },
    setResolutionPolicy: function (resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) {
            _t._resolutionPolicy = resolutionPolicy;
        }
        else {
            var _locPolicy = cc.ResolutionPolicy;
            if(resolutionPolicy === _locPolicy.EXACT_FIT)
                _t._resolutionPolicy = _t._rpExactFit;
            if(resolutionPolicy === _locPolicy.SHOW_ALL)
                _t._resolutionPolicy = _t._rpShowAll;
            if(resolutionPolicy === _locPolicy.NO_BORDER)
                _t._resolutionPolicy = _t._rpNoBorder;
            if(resolutionPolicy === _locPolicy.FIXED_HEIGHT)
                _t._resolutionPolicy = _t._rpFixedHeight;
            if(resolutionPolicy === _locPolicy.FIXED_WIDTH)
                _t._resolutionPolicy = _t._rpFixedWidth;
        }
    },
    setDesignResolutionSize: function (width, height, resolutionPolicy) {
        if (isNaN(width) || width == 0 || isNaN(height) || height == 0) {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
            return;
        }
        var _t = this;
        _t.setResolutionPolicy(resolutionPolicy);
        var policy = _t._resolutionPolicy;
        if (policy)
            policy.preApply(_t);
        else {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
            return;
        }
        if (cc.sys.isMobile)
            _t._setViewPortMeta();
        _t._initFrameSize();
        _t._designResolutionSize = cc.size(width, height);
        _t._originalDesignResolutionSize = cc.size(width, height);
        var result = policy.apply(_t, _t._designResolutionSize);
        if (result.scale && result.scale.length == 2) {
            _t._scaleX = result.scale[0];
            _t._scaleY = result.scale[1];
        }
        if (result.viewport) {
            var vp = _t._viewPortRect = result.viewport, visible = _t._visibleRect;
            visible.width = cc._canvas.width / _t._scaleX;
            visible.height = cc._canvas.height / _t._scaleY;
            visible.x = -vp.x / _t._scaleX;
            visible.y = -vp.y / _t._scaleY;
        }
        var director = cc.director;
        director._winSizeInPoints.width = _t._designResolutionSize.width;
        director._winSizeInPoints.height = _t._designResolutionSize.height;
        policy.postApply(_t);
        cc.winSize.width = director._winSizeInPoints.width;
        cc.winSize.height = director._winSizeInPoints.height;
        if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
            director._createStatsLabel();
            director.setGLDefaultValues();
        }
        _t._originalScaleX = _t._scaleX;
        _t._originalScaleY = _t._scaleY;
        if (cc.DOM)
            cc.DOM._resetEGLViewDiv();
        cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
    },
    getDesignResolutionSize: function () {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
    },
    setViewPortInPoints: function (x, y, w, h) {
        var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc._renderContext.viewport((x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor),
            (y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor),
            (w * locScaleX * locFrameZoomFactor),
            (h * locScaleY * locFrameZoomFactor));
    },
    setScissorInPoints: function (x, y, w, h) {
        var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc._renderContext.scissor((x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor),
            (y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor),
            (w * locScaleX * locFrameZoomFactor),
            (h * locScaleY * locFrameZoomFactor));
    },
    isScissorEnabled: function () {
        var gl = cc._renderContext;
        return gl.isEnabled(gl.SCISSOR_TEST);
    },
    getScissorRect: function () {
        var gl = cc._renderContext, scaleX = this._scaleX, scaleY = this._scaleY;
        var boxArr = gl.getParameter(gl.SCISSOR_BOX);
        return cc.rect((boxArr[0] - this._viewPortRect.x) / scaleX, (boxArr[1] - this._viewPortRect.y) / scaleY,
            boxArr[2] / scaleX, boxArr[3] / scaleY);
    },
    setViewName: function (viewName) {
        if (viewName != null && viewName.length > 0) {
            this._viewName = viewName;
        }
    },
    getViewName: function () {
        return this._viewName;
    },
    getViewPortRect: function () {
        return this._viewPortRect;
    },
    getScaleX: function () {
        return this._scaleX;
    },
    getScaleY: function () {
        return this._scaleY;
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio;
    },
    convertToLocationInView: function (tx, ty, relatedPos) {
        return {x: this._devicePixelRatio * (tx - relatedPos.left), y: this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty)};
    },
    _convertMouseToLocationInView: function(point, relatedPos) {
        var locViewPortRect = this._viewPortRect, _t = this;
        point.x = ((_t._devicePixelRatio * (point.x - relatedPos.left)) - locViewPortRect.x) / _t._scaleX;
        point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - point.y) - locViewPortRect.y) / _t._scaleY;
    },
    _convertTouchesWithScale: function(touches){
        var locViewPortRect = this._viewPortRect, locScaleX = this._scaleX, locScaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for( var i = 0; i < touches.length; i ++){
            selTouch = touches[i];
            selPoint = selTouch._point;
	        selPrePoint = selTouch._prevPoint;
            selTouch._setPoint((selPoint.x - locViewPortRect.x) / locScaleX,
                (selPoint.y - locViewPortRect.y) / locScaleY);
            selTouch._setPrevPoint((selPrePoint.x - locViewPortRect.x) / locScaleX,
                (selPrePoint.y - locViewPortRect.y) / locScaleY);
        }
    }
});
cc.EGLView._getInstance = function () {
    if (!this._instance) {
        this._instance = this._instance || new cc.EGLView();
        this._instance.initialize();
    }
    return this._instance;
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function (view) {
    },
    apply: function (view, designedResolution) {
    },
    postApply: function (view) {
    },
    _setupContainer: function (view, w, h) {
        var frame = view._frame;
        if (cc.view._autoFullScreen && cc.sys.isMobile && frame == document.documentElement) {
            cc.screen.autoFullScreen(frame);
        }
        var locCanvasElement = cc._canvas, locContainer = cc.container;
        locContainer.style.width = locCanvasElement.style.width = w + "px";
        locContainer.style.height = locCanvasElement.style.height = h + "px";
        var devicePixelRatio = view._devicePixelRatio = 1;
        if (view.isRetinaEnabled())
            devicePixelRatio = view._devicePixelRatio = window.devicePixelRatio || 1;
        locCanvasElement.width = w * devicePixelRatio;
        locCanvasElement.height = h * devicePixelRatio;
        var body = document.body, style;
        if (body && (style = body.style)) {
            style.paddingTop = style.paddingTop || "0px";
            style.paddingRight = style.paddingRight || "0px";
            style.paddingBottom = style.paddingBottom || "0px";
            style.paddingLeft = style.paddingLeft || "0px";
            style.borderTop = style.borderTop || "0px";
            style.borderRight = style.borderRight || "0px";
            style.borderBottom = style.borderBottom || "0px";
            style.borderLeft = style.borderLeft || "0px";
            style.marginTop = style.marginTop || "0px";
            style.marginRight = style.marginRight || "0px";
            style.marginBottom = style.marginBottom || "0px";
            style.marginLeft = style.marginLeft || "0px";
        }
    },
    _fixContainer: function () {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function (containerW, containerH, contentW, contentH, scaleX, scaleY) {
	    Math.abs(containerW - contentW) < 2 && (contentW = containerW);
	    Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect(Math.round((containerW - contentW) / 2),
                               Math.round((containerH - contentH) / 2),
                               contentW, contentH);
        if (cc._renderType == cc._RENDER_TYPE_CANVAS)
            cc._renderContext.translate(viewport.x, viewport.y + contentH);
        this._result.scale = [scaleX, scaleY];
        this._result.viewport = viewport;
        return this._result;
    },
    preApply: function (view) {
    },
    apply: function (view, designedResolution) {
        return {"scale": [1, 1]};
    },
    postApply: function (view) {
    }
});
(function () {
    var EqualToFrame = cc.ContainerStrategy.extend({
        apply: function (view) {
            this._setupContainer(view, view._frameSize.width, view._frameSize.height);
        }
    });
    var ProportionalToFrame = cc.ContainerStrategy.extend({
        apply: function (view, designedResolution) {
            var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.container.style,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = frameW / designW, scaleY = frameH / designH,
                containerW, containerH;
            scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, containerH = frameH);
            var offx = Math.round((frameW - containerW) / 2);
            var offy = Math.round((frameH - containerH) / 2);
            containerW = frameW - 2 * offx;
            containerH = frameH - 2 * offy;
            this._setupContainer(view, containerW, containerH);
            containerStyle.marginLeft = offx + "px";
            containerStyle.marginRight = offx + "px";
            containerStyle.marginTop = offy + "px";
            containerStyle.marginBottom = offy + "px";
        }
    });
    var EqualToWindow = EqualToFrame.extend({
        preApply: function (view) {
	        this._super(view);
            view._frame = document.documentElement;
        },
        apply: function (view) {
            this._super(view);
            this._fixContainer();
        }
    });
    var ProportionalToWindow = ProportionalToFrame.extend({
        preApply: function (view) {
	        this._super(view);
            view._frame = document.documentElement;
        },
        apply: function (view, designedResolution) {
            this._super(view, designedResolution);
            this._fixContainer();
        }
    });
    var OriginalContainer = cc.ContainerStrategy.extend({
        apply: function (view) {
            this._setupContainer(view, cc._canvas.width, cc._canvas.height);
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
    var ExactFit = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
    });
    var ShowAll = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = containerW / designW, scaleY = containerH / designH, scale = 0,
                contentW, contentH;
	        scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale)
                : (scale = scaleY, contentW = designW * scale, contentH = containerH);
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
    });
    var NoBorder = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, designH = designedResolution.height,
                scaleX = containerW / designW, scaleY = containerH / designH, scale,
                contentW, contentH;
            scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH)
                : (scale = scaleX, contentW = containerW, contentH = designH * scale);
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
    });
    var FixedHeight = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designH = designedResolution.height, scale = containerH / designH,
                contentW = containerW, contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function (view) {
            cc.director._winSizeInPoints = view.getVisibleSize();
        }
    });
    var FixedWidth = cc.ContentStrategy.extend({
        apply: function (view, designedResolution) {
            var containerW = cc._canvas.width, containerH = cc._canvas.height,
                designW = designedResolution.width, scale = containerW / designW,
                contentW = containerW, contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function (view) {
            cc.director._winSizeInPoints = view.getVisibleSize();
        }
    });
    cc.ContentStrategy.EXACT_FIT = new ExactFit();
    cc.ContentStrategy.SHOW_ALL = new ShowAll();
    cc.ContentStrategy.NO_BORDER = new NoBorder();
    cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
    cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
})();
cc.ResolutionPolicy = cc.Class.extend({
	_containerStrategy: null,
    _contentStrategy: null,
    ctor: function (containerStg, contentStg) {
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
    },
    preApply: function (view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
    },
    apply: function (view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
    },
    postApply: function (view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
    },
    setContainerStrategy: function (containerStg) {
        if (containerStg instanceof cc.ContainerStrategy)
            this._containerStrategy = containerStg;
    },
    setContentStrategy: function (contentStg) {
        if (contentStg instanceof cc.ContentStrategy)
            this._contentStrategy = contentStg;
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: false,
    _preOnFullScreenChange: null,
    _touchEvent: "",
	_fn: null,
	_fnMap: [
		[
			'requestFullscreen',
			'exitFullscreen',
			'fullscreenchange',
			'fullscreenEnabled',
			'fullscreenElement'
		],
		[
			'requestFullScreen',
			'exitFullScreen',
			'fullScreenchange',
			'fullScreenEnabled',
			'fullScreenElement'
		],
		[
			'webkitRequestFullScreen',
			'webkitCancelFullScreen',
			'webkitfullscreenchange',
			'webkitIsFullScreen',
			'webkitCurrentFullScreenElement'
		],
		[
			'mozRequestFullScreen',
			'mozCancelFullScreen',
			'mozfullscreenchange',
			'mozFullScreen',
			'mozFullScreenElement'
		],
		[
			'msRequestFullscreen',
			'msExitFullscreen',
			'MSFullscreenChange',
			'msFullscreenEnabled',
			'msFullscreenElement'
		]
	],
    init: function () {
	    this._fn = {};
	    var i, val, map = this._fnMap, valL;
	    for (i = 0, l = map.length; i < l; i++ ) {
		    val = map[ i ];
		    if ( val && val[1] in document ) {
			    for ( i = 0, valL = val.length; i < valL; i++ ) {
				    this._fn[ map[0][ i ] ] = val[ i ];
			    }
			    break;
		    }
	    }
		this._supportsFullScreen = (this._fn.requestFullscreen != undefined);
        this._touchEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
    },
    fullScreen: function() {
	    return this._supportsFullScreen && document[ this._fn.fullscreenEnabled ];
    },
    requestFullScreen: function (element, onFullScreenChange) {
	    if (!this._supportsFullScreen) return;
	    element = element || document.documentElement;
	    element[ this._fn.requestFullscreen ]();
	    if (onFullScreenChange) {
		    var eventName = this._fn.fullscreenchange;
		    if (this._preOnFullScreenChange)
			    document.removeEventListener(eventName, this._preOnFullScreenChange);
		    this._preOnFullScreenChange = onFullScreenChange;
            cc._addEventListener(document, eventName, onFullScreenChange, false);
	    }
        return element[ this._fn.requestFullscreen ]();
    },
    exitFullScreen: function () {
        return this._supportsFullScreen ? document[ this._fn.exitFullscreen ]() : true;
    },
    autoFullScreen: function (element, onFullScreenChange) {
	    element = element || document.body;
	    var touchTarget = cc._canvas || element;
        var theScreen = this;
        function callback() {
            theScreen.requestFullScreen(element, onFullScreenChange);
            touchTarget.removeEventListener(theScreen._touchEvent, callback);
        }
        this.requestFullScreen(element, onFullScreenChange);
        cc._addEventListener(touchTarget, this._touchEvent, callback);
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft:cc.p(0,0),
    topRight:cc.p(0,0),
    top:cc.p(0,0),
    bottomLeft:cc.p(0,0),
    bottomRight:cc.p(0,0),
    bottom:cc.p(0,0),
    center:cc.p(0,0),
    left:cc.p(0,0),
    right:cc.p(0,0),
    width:0,
    height:0,
    init:function(visibleRect){
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x,
            b = visibleRect.y,
            t = b + h,
            r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w/2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w/2;
        this.bottom.y = b;
        this.center.x = l + w/2;
        this.center.y = b + h/2;
        this.left.x = l;
        this.left.y = b + h/2;
        this.right.x = r;
        this.right.y = b + h/2;
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: false,
    _isRegisterEvent: false,
    _preTouchPoint: cc.p(0,0),
    _prevMousePoint: cc.p(0,0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict:{},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: false,
    _accelInterval: 1/30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function () {
        var temp = this._indexBitsUsed;
        for (var i = 0; i < this._maxTouches; i++) {
            if (!(temp & 0x00000001)) {
                this._indexBitsUsed |= (1 << i);
                return i;
            }
            temp >>= 1;
        }
        return -1;
    },
    _removeUsedIndexBit: function (index) {
        if (index < 0 || index >= this._maxTouches)
            return;
        var temp = 1 << index;
        temp = ~temp;
        this._indexBitsUsed &= temp;
    },
    _glView: null,
    handleTouchesBegin: function (touches) {
        var selTouch, index, curTouch, touchID, handleTouches = [], locTouchIntDict = this._touchesIntegerDict;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = locTouchIntDict[touchID];
            if(index == null){
                var unusedIndex = this._getUnUsedIndex();
                if (unusedIndex == -1) {
                    cc.log(cc._LogInfos.inputManager_handleTouchesBegin, unusedIndex);
                    continue;
                }
                curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
                curTouch._setPrevPoint(selTouch._prevPoint);
                locTouchIntDict[touchID] = unusedIndex;
                handleTouches.push(curTouch);
            }
        }
        if(handleTouches.length > 0){
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.BEGAN;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesMove: function(touches){
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = this._touchesIntegerDict[touchID];
            if(index == null){
                continue;
            }
            if(locTouches[index]){
                locTouches[index]._setPoint(selTouch._point);
                locTouches[index]._setPrevPoint(selTouch._prevPoint);
                handleTouches.push(locTouches[index]);
            }
        }
        if(handleTouches.length > 0){
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.MOVED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesEnd: function(touches){
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if(handleTouches.length > 0) {
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.ENDED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    handleTouchesCancel: function(touches){
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if(handleTouches.length > 0) {
            this._glView._convertTouchesWithScale(handleTouches);
            var touchEvent = new cc.EventTouch(handleTouches);
            touchEvent._eventCode = cc.EventTouch.EventCode.CANCELLED;
            cc.eventManager.dispatchEvent(touchEvent);
        }
    },
    getSetOfTouchesEndOrCancel: function(touches) {
        var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
        for(var i = 0, len = touches.length; i< len; i ++){
            selTouch = touches[i];
            touchID = selTouch.getID();
            index = locTouchesIntDict[touchID];
            if(index == null){
                continue;
            }
            if(locTouches[index]){
                locTouches[index]._setPoint(selTouch._point);
                locTouches[index]._setPrevPoint(selTouch._prevPoint);
                handleTouches.push(locTouches[index]);
                this._removeUsedIndexBit(index);
                delete locTouchesIntDict[touchID];
            }
        }
        return handleTouches;
    },
    getHTMLElementPosition: function (element) {
        var docElem = document.documentElement;
        var win = window;
        var box = null;
        if (cc.isFunction(element.getBoundingClientRect)) {
            box = element.getBoundingClientRect();
        } else {
            if (element instanceof HTMLCanvasElement) {
                box = {
                    left: 0,
                    top: 0,
                    width: element.width,
                    height: element.height
                };
            } else {
                box = {
                    left: 0,
                    top: 0,
                    width: parseInt(element.style.width),
                    height: parseInt(element.style.height)
                };
            }
        }
        return {
            left: box.left + win.pageXOffset - docElem.clientLeft,
            top: box.top + win.pageYOffset - docElem.clientTop,
            width: box.width,
            height: box.height
        };
    },
    getPreTouch: function(touch){
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
            if (locPreTouchPool[i].getID() == id) {
                preTouch = locPreTouchPool[i];
                break;
            }
        }
        if (!preTouch)
            preTouch = touch;
        return preTouch;
    },
    setPreTouch: function(touch){
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
            if (locPreTouchPool[i].getID() == id) {
                locPreTouchPool[i] = touch;
                find = true;
                break;
            }
        }
        if (!find) {
            if (locPreTouchPool.length <= 50) {
                locPreTouchPool.push(touch);
            } else {
                locPreTouchPool[this._preTouchPoolPointer] = touch;
                this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
            }
        }
    },
    getTouchByXY: function(tx, ty, pos){
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x,  location.y);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
    },
    getMouseEvent: function(location, pos, eventType){
        var locPreMouse = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(location, pos);
        var mouseEvent = new cc.EventMouse(eventType);
        mouseEvent.setLocation(location.x, location.y);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        return mouseEvent;
    },
    getPointByEvent: function(event, pos){
        if (event.pageX != null)
            return {x: event.pageX, y: event.pageY};
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        return {x: event.clientX, y: event.clientY};
    },
    getTouchesByEvent: function(event, pos){
        var touchArr = [], locView = this._glView;
        var touch_event, touch, preLocation;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
            touch_event = event.changedTouches[i];
            if (touch_event) {
                var location;
                if (cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType)
                    location = locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos);
                else
                    location = locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
                if (touch_event.identifier != null) {
                    touch = new cc.Touch(location.x, location.y, touch_event.identifier);
                    preLocation = this.getPreTouch(touch).getLocation();
                    touch._setPrevPoint(preLocation.x, preLocation.y);
                    this.setPreTouch(touch);
                } else {
                    touch = new cc.Touch(location.x, location.y);
                    touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                }
                locPreTouch.x = location.x;
                locPreTouch.y = location.y;
                touchArr.push(touch);
            }
        }
        return touchArr;
    },
    registerSystemEvent: function(element){
        if(this._isRegisterEvent) return;
        var locView = this._glView = cc.view;
        var selfPointer = this;
        var supportMouse = ('mouse' in cc.sys.capabilities), supportTouches = ('touches' in cc.sys.capabilities);
        if (supportMouse) {
            cc._addEventListener(window, 'mousedown', function () {
                selfPointer._mousePressed = true;
            }, false);
            cc._addEventListener(window, 'mouseup', function (event) {
                var savePressed = selfPointer._mousePressed;
                selfPointer._mousePressed = false;
                if(!savePressed)
                    return;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if (!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), location)){
                    if(!supportTouches)
                        selfPointer.handleTouchesEnd([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                    var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.UP);
                    mouseEvent.setButton(event.button);
                    cc.eventManager.dispatchEvent(mouseEvent);
                }
            }, false);
            cc._addEventListener(element,"mousedown", function (event) {
                selfPointer._mousePressed = true;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesBegin([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.DOWN);
                mouseEvent.setButton(event.button);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
                element.focus();
            }, false);
            cc._addEventListener(element, "mouseup", function (event) {
                selfPointer._mousePressed = false;
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesEnd([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.UP);
                mouseEvent.setButton(event.button);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "mousemove", function (event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                if(!supportTouches)
                    selfPointer.handleTouchesMove([selfPointer.getTouchByXY(location.x, location.y, pos)]);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.MOVE);
                if(selfPointer._mousePressed)
                    mouseEvent.setButton(event.button);
                else
                    mouseEvent.setButton(null);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "mousewheel", function (event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.SCROLL);
                mouseEvent.setButton(event.button);
                mouseEvent.setScrollData(0, event.wheelDelta);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "DOMMouseScroll", function(event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location,pos,cc.EventMouse.SCROLL);
                mouseEvent.setButton(event.button);
                mouseEvent.setScrollData(0, event.detail * -120);
                cc.eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
            }, false);
        }
        if(window.navigator.msPointerEnabled){
            var _pointerEventsMap = {
                "MSPointerDown"     : selfPointer.handleTouchesBegin,
                "MSPointerMove"     : selfPointer.handleTouchesMove,
                "MSPointerUp"       : selfPointer.handleTouchesEnd,
                "MSPointerCancel"   : selfPointer.handleTouchesCancel
            };
            for(var eventName in _pointerEventsMap){
                (function(_pointerEvent, _touchEvent){
                    cc._addEventListener(element, _pointerEvent, function (event){
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.documentElement.scrollLeft;
                        pos.top -= document.documentElement.scrollTop;
                        _touchEvent.call(selfPointer, [selfPointer.getTouchByXY(event.clientX, event.clientY, pos)]);
                        event.stopPropagation();
                    }, false);
                })(eventName, _pointerEventsMap[eventName]);
            }
        }
        if(supportTouches) {
            cc._addEventListener(element,"touchstart", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesBegin(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
                element.focus();
            }, false);
            cc._addEventListener(element, "touchmove", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesMove(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "touchend", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesEnd(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
            cc._addEventListener(element, "touchcancel", function (event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                selfPointer.handleTouchesCancel(selfPointer.getTouchesByEvent(event, pos));
                event.stopPropagation();
                event.preventDefault();
            }, false);
        }
        this._registerKeyboardEvent();
        this._registerAccelerometerEvent();
        this._isRegisterEvent = true;
    },
    _registerKeyboardEvent: function(){},
    _registerAccelerometerEvent: function(){},
    update:function(dt){
        if(this._accelCurTime > this._accelInterval){
            this._accelCurTime -= this._accelInterval;
            cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
    }
};
cc.AffineTransform = function (a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
};
cc.affineTransformMake = function (a, b, c, d, tx, ty) {
    return {a: a, b: b, c: c, d: d, tx: tx, ty: ty};
};
cc.pointApplyAffineTransform = function (point, t) {
    return {x: t.a * point.x + t.c * point.y + t.tx, y: t.b * point.x + t.d * point.y + t.ty};
};
cc._pointApplyAffineTransform = function (x, y, t) {
    return {x: t.a * x + t.c * y + t.tx,
        y: t.b * x + t.d * y + t.ty};
};
cc.sizeApplyAffineTransform = function (size, t) {
    return {width: t.a * size.width + t.c * size.height, height: t.b * size.width + t.d * size.height};
};
cc.affineTransformMakeIdentity = function () {
    return {a: 1.0, b: 0.0, c: 0.0, d: 1.0, tx: 0.0, ty: 0.0};
};
cc.affineTransformIdentity = function () {
    return {a: 1.0, b: 0.0, c: 0.0, d: 1.0, tx: 0.0, ty: 0.0};
};
cc.rectApplyAffineTransform = function (rect, anAffineTransform) {
    var top = cc.rectGetMinY(rect);
    var left = cc.rectGetMinX(rect);
    var right = cc.rectGetMaxX(rect);
    var bottom = cc.rectGetMaxY(rect);
    var topLeft = cc._pointApplyAffineTransform(left, top, anAffineTransform);
    var topRight = cc._pointApplyAffineTransform(right, top, anAffineTransform);
    var bottomLeft = cc._pointApplyAffineTransform(left, bottom, anAffineTransform);
    var bottomRight = cc._pointApplyAffineTransform(right, bottom, anAffineTransform);
    var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    return cc.rect(minX, minY, (maxX - minX), (maxY - minY));
};
cc._rectApplyAffineTransformIn = function(rect, anAffineTransform){
    var top = cc.rectGetMinY(rect);
    var left = cc.rectGetMinX(rect);
    var right = cc.rectGetMaxX(rect);
    var bottom = cc.rectGetMaxY(rect);
    var topLeft = cc._pointApplyAffineTransform(left, top, anAffineTransform);
    var topRight = cc._pointApplyAffineTransform(right, top, anAffineTransform);
    var bottomLeft = cc._pointApplyAffineTransform(left, bottom, anAffineTransform);
    var bottomRight = cc._pointApplyAffineTransform(right, bottom, anAffineTransform);
    var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
    var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
    rect.x = minX;
    rect.y = minY;
    rect.width = maxX - minX;
    rect.height = maxY - minY;
    return rect;
};
cc.affineTransformTranslate = function (t, tx, ty) {
    return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx + t.a * tx + t.c * ty,
        ty: t.ty + t.b * tx + t.d * ty
    };
};
cc.affineTransformScale = function (t, sx, sy) {
    return {a: t.a * sx, b: t.b * sx, c: t.c * sy, d: t.d * sy, tx: t.tx, ty: t.ty};
};
cc.affineTransformRotate = function (aTransform, anAngle) {
    var fSin = Math.sin(anAngle);
    var fCos = Math.cos(anAngle);
    return {a: aTransform.a * fCos + aTransform.c * fSin,
        b: aTransform.b * fCos + aTransform.d * fSin,
        c: aTransform.c * fCos - aTransform.a * fSin,
        d: aTransform.d * fCos - aTransform.b * fSin,
        tx: aTransform.tx,
        ty: aTransform.ty};
};
cc.affineTransformConcat = function (t1, t2) {
    return {a: t1.a * t2.a + t1.b * t2.c,
        b: t1.a * t2.b + t1.b * t2.d,
        c: t1.c * t2.a + t1.d * t2.c,
        d: t1.c * t2.b + t1.d * t2.d,
        tx: t1.tx * t2.a + t1.ty * t2.c + t2.tx,
        ty: t1.tx * t2.b + t1.ty * t2.d + t2.ty};
};
cc.affineTransformEqualToTransform = function (t1, t2) {
    return ((t1.a === t2.a) && (t1.b === t2.b) && (t1.c === t2.c) && (t1.d === t2.d) && (t1.tx === t2.tx) && (t1.ty === t2.ty));
};
cc.affineTransformInvert = function (t) {
    var determinant = 1 / (t.a * t.d - t.b * t.c);
    return {a: determinant * t.d, b: -determinant * t.b, c: -determinant * t.c, d: determinant * t.a,
        tx: determinant * (t.c * t.ty - t.d * t.tx), ty: determinant * (t.b * t.tx - t.a * t.ty)};
};
cc.POINT_EPSILON = parseFloat('1.192092896e-07F');
cc.pNeg = function (point) {
    return cc.p(-point.x, -point.y);
};
cc.pAdd = function (v1, v2) {
    return cc.p(v1.x + v2.x, v1.y + v2.y);
};
cc.pSub = function (v1, v2) {
    return cc.p(v1.x - v2.x, v1.y - v2.y);
};
cc.pMult = function (point, floatVar) {
    return cc.p(point.x * floatVar, point.y * floatVar);
};
cc.pMidpoint = function (v1, v2) {
    return cc.pMult(cc.pAdd(v1, v2), 0.5);
};
cc.pDot = function (v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};
cc.pCross = function (v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
};
cc.pPerp = function (point) {
    return cc.p(-point.y, point.x);
};
cc.pRPerp = function (point) {
    return cc.p(point.y, -point.x);
};
cc.pProject = function (v1, v2) {
    return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
};
cc.pRotate = function (v1, v2) {
    return cc.p(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
};
cc.pUnrotate = function (v1, v2) {
    return cc.p(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
};
cc.pLengthSQ = function (v) {
    return cc.pDot(v, v);
};
cc.pDistanceSQ = function(point1, point2){
    return cc.pLengthSQ(cc.pSub(point1,point2));
};
cc.pLength = function (v) {
    return Math.sqrt(cc.pLengthSQ(v));
};
cc.pDistance = function (v1, v2) {
    return cc.pLength(cc.pSub(v1, v2));
};
cc.pNormalize = function (v) {
    return cc.pMult(v, 1.0 / cc.pLength(v));
};
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a));
};
cc.pToAngle = function (v) {
    return Math.atan2(v.y, v.x);
};
cc.clampf = function (value, min_inclusive, max_inclusive) {
    if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
    }
    return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};
cc.pClamp = function (p, min_inclusive, max_inclusive) {
    return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
};
cc.pFromSize = function (s) {
    return cc.p(s.width, s.height);
};
cc.pCompOp = function (p, opFunc) {
    return cc.p(opFunc(p.x), opFunc(p.y));
};
cc.pLerp = function (a, b, alpha) {
    return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
};
cc.pFuzzyEqual = function (a, b, variance) {
    if (a.x - variance <= b.x && b.x <= a.x + variance) {
        if (a.y - variance <= b.y && b.y <= a.y + variance)
            return true;
    }
    return false;
};
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y);
};
cc.pAngleSigned = function (a, b) {
    var a2 = cc.pNormalize(a);
    var b2 = cc.pNormalize(b);
    var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
    if (Math.abs(angle) < cc.POINT_EPSILON)
        return 0.0;
    return angle;
};
cc.pAngle = function (a, b) {
    var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    if (Math.abs(angle) < cc.POINT_EPSILON) return 0.0;
    return angle;
};
cc.pRotateByAngle = function (v, pivot, angle) {
    var r = cc.pSub(v, pivot);
    var cosa = Math.cos(angle), sina = Math.sin(angle);
    var t = r.x;
    r.x = t * cosa - r.y * sina + pivot.x;
    r.y = t * sina + r.y * cosa + pivot.y;
    return r;
};
cc.pLineIntersect = function (A, B, C, D, retP) {
    if ((A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)) {
        return false;
    }
    var BAx = B.x - A.x;
    var BAy = B.y - A.y;
    var DCx = D.x - C.x;
    var DCy = D.y - C.y;
    var ACx = A.x - C.x;
    var ACy = A.y - C.y;
    var denom = DCy * BAx - DCx * BAy;
    retP.x = DCx * ACy - DCy * ACx;
    retP.y = BAx * ACy - BAy * ACx;
    if (denom == 0) {
        if (retP.x == 0 || retP.y == 0) {
            return true;
        }
        return false;
    }
    retP.x = retP.x / denom;
    retP.y = retP.y / denom;
    return true;
};
cc.pSegmentIntersect = function (A, B, C, D) {
    var retP = cc.p(0, 0);
    if (cc.pLineIntersect(A, B, C, D, retP))
        if (retP.x >= 0.0 && retP.x <= 1.0 && retP.y >= 0.0 && retP.y <= 1.0)
            return true;
    return false;
};
cc.pIntersectPoint = function (A, B, C, D) {
    var retP = cc.p(0, 0);
    if (cc.pLineIntersect(A, B, C, D, retP)) {
        var P = cc.p(0, 0);
        P.x = A.x + retP.x * (B.x - A.x);
        P.y = A.y + retP.x * (B.y - A.y);
        return P;
    }
    return cc.p(0,0);
};
cc.pSameAs = function (A, B) {
    if ((A != null) && (B != null)) {
        return (A.x == B.x && A.y == B.y);
    }
    return false;
};
cc.pZeroIn = function(v) {
    v.x = 0;
    v.y = 0;
};
cc.pIn = function(v1, v2) {
    v1.x = v2.x;
    v1.y = v2.y;
};
cc.pMultIn = function(point, floatVar) {
    point.x *= floatVar;
    point.y *= floatVar;
};
cc.pSubIn = function(v1, v2) {
    v1.x -= v2.x;
    v1.y -= v2.y;
};
cc.pAddIn = function(v1, v2) {
    v1.x += v2.x;
    v1.y += v2.y;
};
cc.pNormalizeIn = function(v) {
    cc.pMultIn(v, 1.0 / Math.sqrt(v.x * v.x + v.y * v.y));
};
cc.Touch = cc.Class.extend({
    _point:null,
    _prevPoint:null,
    _id:0,
    _startPointCaptured: false,
    _startPoint:null,
    ctor:function (x, y, id) {
        this._point = cc.p(x || 0, y || 0);
        this._id = id || 0;
    },
    getLocation:function () {
        return {x: this._point.x, y: this._point.y};
    },
	getLocationX: function () {
		return this._point.x;
	},
	getLocationY: function () {
		return this._point.y;
	},
    getPreviousLocation:function () {
        return {x: this._prevPoint.x, y: this._prevPoint.y};
    },
    getStartLocation: function() {
        return {x: this._startPoint.x, y: this._startPoint.y};
    },
    getDelta:function () {
        return cc.pSub(this._point, this._prevPoint);
    },
    getLocationInView: function() {
        return {x: this._point.x, y: this._point.y};
    },
    getPreviousLocationInView: function(){
        return {x: this._prevPoint.x, y: this._prevPoint.y};
    },
    getStartLocationInView: function(){
        return {x: this._startPoint.x, y: this._startPoint.y};
    },
    getID:function () {
        return this._id;
    },
    getId:function () {
        cc.log("getId is deprecated. Please use getID instead.")
        return this._id;
    },
    setTouchInfo:function (id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.p(x || 0, y || 0);
        this._id = id;
        if(!this._startPointCaptured){
            this._startPoint = cc.p(this._point);
            this._startPointCaptured = true;
        }
    },
    _setPoint: function(x, y){
        if(y === undefined){
            this._point.x = x.x;
            this._point.y = x.y;
        }else{
            this._point.x = x;
            this._point.y = y;
        }
    },
    _setPrevPoint:function (x, y) {
        if(y === undefined)
            this._prevPoint = cc.p(x.x, x.y);
        else
            this._prevPoint = cc.p(x || 0, y || 0);
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: false,
    _currentTarget: null,
    _setCurrentTarget: function (target) {
        this._currentTarget = target;
    },
    ctor: function (type) {
        this._type = type;
    },
    getType: function () {
        return this._type;
    },
    stopPropagation: function () {
        this._isStopped = true;
    },
    isStopped: function () {
        return this._isStopped;
    },
    getCurrentTarget: function () {
        return this._currentTarget;
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function (eventName) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = eventName;
    },
    setUserData: function (data) {
        this._userData = data;
    },
    getUserData: function () {
        return this._userData;
    },
    getEventName: function () {
        return this._eventName;
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function (eventType) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = eventType;
    },
    setScrollData: function (scrollX, scrollY) {
        this._scrollX = scrollX;
        this._scrollY = scrollY;
    },
    getScrollX: function () {
        return this._scrollX;
    },
    getScrollY: function () {
        return this._scrollY;
    },
    setLocation: function (x, y) {
        this._x = x;
        this._y = y;
    },
    getLocation: function () {
        return {x: this._x, y: this._y};
    },
	getLocationInView: function() {
		return {x: this._x, y: cc.view._designResolutionSize.height - this._y};
	},
    _setPrevCursor: function (x, y) {
        this._prevX = x;
        this._prevY = y;
    },
    getDelta: function () {
        return {x: this._x - this._prevX, y: this._y - this._prevY};
    },
    getDeltaX: function () {
        return this._x - this._prevX;
    },
    getDeltaY: function () {
        return this._y - this._prevY;
    },
    setButton: function (button) {
        this._button = button;
    },
    getButton: function () {
        return this._button;
    },
    getLocationX: function () {
        return this._x;
    },
    getLocationY: function () {
        return this._y;
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function (arr) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = arr || [];
    },
    getEventCode: function () {
        return this._eventCode;
    },
    getTouches: function () {
        return this._touches;
    },
    _setEventCode: function (eventCode) {
        this._eventCode = eventCode;
    },
    _setTouches: function (touches) {
        this._touches = touches;
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {BEGAN: 0, MOVED: 1, ENDED: 2, CANCELLED: 3};
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: false,
    _fixedPriority: 0,
    _node: null,
    _paused: true,
    _isEnabled: true,
    ctor: function (type, listenerID, callback) {
        this._onEvent = callback;
        this._type = type || 0;
        this._listenerID = listenerID || "";
    },
    _setPaused: function (paused) {
        this._paused = paused;
    },
    _isPaused: function () {
        return this._paused;
    },
    _setRegistered: function (registered) {
        this._registered = registered;
    },
    _isRegistered: function () {
        return this._registered;
    },
    _getType: function () {
        return this._type;
    },
    _getListenerID: function () {
        return this._listenerID;
    },
    _setFixedPriority: function (fixedPriority) {
        this._fixedPriority = fixedPriority;
    },
    _getFixedPriority: function () {
        return this._fixedPriority;
    },
    _setSceneGraphPriority: function (node) {
        this._node = node;
    },
    _getSceneGraphPriority: function () {
        return this._node;
    },
    checkAvailable: function () {
        return this._onEvent != null;
    },
    clone: function () {
        return null;
    },
    setEnabled: function(enabled){
        this._isEnabled = enabled;
    },
    isEnabled: function(){
        return this._isEnabled;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function (listenerId, callback) {
        this._onCustomEvent = callback;
        var selfPointer = this;
        var listener = function (event) {
            if (selfPointer._onCustomEvent != null)
                selfPointer._onCustomEvent(event);
        };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, listenerId, listener);
    },
    checkAvailable: function () {
        return (cc.EventListener.prototype.checkAvailable.call(this) && this._onCustomEvent != null);
    },
    clone: function () {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
    }
});
cc._EventListenerCustom.create = function (eventName, callback) {
    return new cc._EventListenerCustom(eventName, callback);
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function () {
        var selfPointer = this;
        var listener = function (event) {
            var eventType = cc.EventMouse;
            switch (event._eventType) {
                case eventType.DOWN:
                    if (selfPointer.onMouseDown)
                        selfPointer.onMouseDown(event);
                    break;
                case eventType.UP:
                    if (selfPointer.onMouseUp)
                        selfPointer.onMouseUp(event);
                    break;
                case eventType.MOVE:
                    if (selfPointer.onMouseMove)
                        selfPointer.onMouseMove(event);
                    break;
                case eventType.SCROLL:
                    if (selfPointer.onMouseScroll)
                        selfPointer.onMouseScroll(event);
                    break;
                default:
                    break;
            }
        };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, listener);
    },
    clone: function () {
        var eventListener = new cc._EventListenerMouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
    },
    checkAvailable: function () {
        return true;
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function () {
    return new cc._EventListenerMouse();
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: false,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = [];
    },
    setSwallowTouches: function (needSwallow) {
        this.swallowTouches = needSwallow;
    },
    clone: function () {
        var eventListener = new cc._EventListenerTouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
    },
    checkAvailable: function () {
        if(!this.onTouchBegan){
            cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable);
            return false;
        }
        return true;
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function () {
    return new cc._EventListenerTouchOneByOne();
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function(){
       cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
    },
    clone: function(){
        var eventListener = new cc._EventListenerTouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
    },
    checkAvailable: function(){
        if (this.onTouchesBegan == null && this.onTouchesMoved == null
            && this.onTouchesEnded == null && this.onTouchesCancelled == null) {
            cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable);
            return false;
        }
        return true;
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function(){
     return new cc._EventListenerTouchAllAtOnce();
};
cc.EventListener.create = function(argObj){
    cc.assert(argObj&&argObj.event, cc._LogInfos.EventListener_create);
    var listenerType = argObj.event;
    delete argObj.event;
    var listener = null;
    if(listenerType === cc.EventListener.TOUCH_ONE_BY_ONE)
        listener = new cc._EventListenerTouchOneByOne();
    else if(listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE)
        listener = new cc._EventListenerTouchAllAtOnce();
    else if(listenerType === cc.EventListener.MOUSE)
        listener = new cc._EventListenerMouse();
    else if(listenerType === cc.EventListener.CUSTOM){
        listener = new cc._EventListenerCustom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
    } else if(listenerType === cc.EventListener.KEYBOARD)
        listener = new cc._EventListenerKeyboard();
    else if(listenerType === cc.EventListener.ACCELERATION){
        listener = new cc._EventListenerAcceleration(argObj.callback);
        delete argObj.callback;
    }
    for(var key in argObj) {
        listener[key] = argObj[key];
    }
    return listener;
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function () {
        this._fixedListeners = [];
        this._sceneGraphListeners = [];
    },
    size: function () {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
    },
    empty: function () {
        return (this._fixedListeners.length === 0) && (this._sceneGraphListeners.length === 0);
    },
    push: function (listener) {
        if (listener._getFixedPriority() == 0)
            this._sceneGraphListeners.push(listener);
        else
            this._fixedListeners.push(listener);
    },
    clearSceneGraphListeners: function () {
        this._sceneGraphListeners.length = 0;
    },
    clearFixedListeners: function () {
        this._fixedListeners.length = 0;
    },
    clear: function () {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
    },
    getFixedPriorityListeners: function () {
        return this._fixedListeners;
    },
    getSceneGraphPriorityListeners: function () {
        return this._sceneGraphListeners;
    }
});
cc.__getListenerID = function (event) {
    var eventType = cc.Event, getType = event.getType();
    if(getType === eventType.ACCELERATION)
        return cc._EventListenerAcceleration.LISTENER_ID;
    if(getType === eventType.CUSTOM)
        return event.getEventName();
    if(getType === eventType.KEYBOARD)
        return cc._EventListenerKeyboard.LISTENER_ID;
    if(getType === eventType.MOUSE)
        return cc._EventListenerMouse.LISTENER_ID;
    if(getType === eventType.TOUCH){
        cc.log(cc._LogInfos.__getListenerID);
    }
    return "";
};
cc.eventManager = {
    DIRTY_NONE:0,
    DIRTY_FIXED_PRIORITY:1 <<0,
    DIRTY_SCENE_GRAPH_PRIORITY : 1<< 1,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: false,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs:[cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function (node) {
        if (this._nodeListenersMap[node.__instanceId] != null)
            this._dirtyNodes.push(node);
        var _children = node.getChildren();
        for(var i = 0, len = _children.length; i < len; i++)
            this._setDirtyForNode(_children[i]);
    },
    pauseTarget: function (node, recursive) {
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners) {
            for ( i = 0, len = listeners.length; i < len; i++)
                listeners[i]._setPaused(true);
        }
        if (recursive === true) {
            var locChildren = node.getChildren();
            for ( i = 0, len = locChildren.length; i< len; i++)
                this.pauseTarget(locChildren[i], true);
        }
    },
    resumeTarget: function (node, recursive) {
        var listeners = this._nodeListenersMap[node.__instanceId], i, len;
        if (listeners){
            for ( i = 0, len = listeners.length; i < len; i++)
                listeners[i]._setPaused(false);
        }
        this._setDirtyForNode(node);
        if (recursive === true) {
            var locChildren = node.getChildren();
            for ( i = 0, len = locChildren.length; i< len; i++)
                this.resumeTarget(locChildren[i], true);
        }
    },
    _addListener: function (listener) {
        if (this._inDispatch === 0)
            this._forceAddEventListener(listener);
        else
            this._toAddedListeners.push(listener);
    },
    _forceAddEventListener: function (listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
            listeners = new cc._EventListenerVector();
            this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (listener._getFixedPriority() == 0) {
            this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
            var node = listener._getSceneGraphPriority();
            if (node == null)
                cc.log(cc._LogInfos.eventManager__forceAddEventListener);
            this._associateNodeAndEventListener(node, listener);
            if (node.isRunning())
                this.resumeTarget(node);
        } else
            this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
    },
    _getListeners: function (listenerID) {
        return this._listenersMap[listenerID];
    },
    _updateDirtyFlagForSceneGraph: function () {
        if (this._dirtyNodes.length == 0)
            return;
        var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
        for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
            selListeners = locNodeListenersMap[locDirtyNodes[i].__instanceId];
            if (selListeners) {
                for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
                    selListener = selListeners[j];
                    if (selListener)
                        this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                }
            }
        }
        this._dirtyNodes.length = 0;
    },
    _removeAllListenersInVector: function (listenerVector) {
        if (!listenerVector)
            return;
        var selListener;
        for (var i = 0; i < listenerVector.length;) {
            selListener = listenerVector[i];
            selListener._setRegistered(false);
            if (selListener._getSceneGraphPriority() != null){
                this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                selListener._setSceneGraphPriority(null);
            }
            if (this._inDispatch === 0)
                cc.arrayRemoveObject(listenerVector, selListener);
            else
                ++i;
        }
    },
    _removeListenersForListenerID: function (listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
            var fixedPriorityListeners = listeners.getFixedPriorityListeners();
            var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(sceneGraphPriorityListeners);
            this._removeAllListenersInVector(fixedPriorityListeners);
            delete this._priorityDirtyFlagMap[listenerID];
            if (!this._inDispatch) {
                listeners.clear();
                delete this._listenersMap[listenerID];
            }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = 0; i < locToAddedListeners.length;) {
            listener = locToAddedListeners[i];
            if (listener && listener._getListenerID() == listenerID)
                cc.arrayRemoveObject(locToAddedListeners, listener);
            else
                ++i;
        }
    },
    _sortEventListeners: function (listenerID) {
        var dirtyFlag = this.DIRTY_NONE,  locFlagMap = this._priorityDirtyFlagMap;
        if (locFlagMap[listenerID])
            dirtyFlag = locFlagMap[listenerID];
        if (dirtyFlag != this.DIRTY_NONE) {
            locFlagMap[listenerID] = this.DIRTY_NONE;
            if (dirtyFlag & this.DIRTY_FIXED_PRIORITY)
                this._sortListenersOfFixedPriority(listenerID);
            if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY){
                var rootNode = cc.director.getRunningScene();
                if(rootNode)
                    this._sortListenersOfSceneGraphPriority(listenerID, rootNode);
                else
                    locFlagMap[listenerID] = this.DIRTY_SCENE_GRAPH_PRIORITY;
            }
        }
    },
    _sortListenersOfSceneGraphPriority: function (listenerID, rootNode) {
        var listeners = this._getListeners(listenerID);
        if (!listeners)
            return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if(!sceneGraphListener || sceneGraphListener.length === 0)
            return;
        this._nodePriorityIndex = 0;
        this._nodePriorityMap = {};
        this._visitTarget(rootNode, true);
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
    },
    _sortEventListenersOfSceneGraphPriorityDes : function(l1, l2){
        var locNodePriorityMap = cc.eventManager._nodePriorityMap;
        if(!l1 || !l2 || !l1._getSceneGraphPriority() || !l2._getSceneGraphPriority())
            return -1;
        return locNodePriorityMap[l2._getSceneGraphPriority().__instanceId] - locNodePriorityMap[l1._getSceneGraphPriority().__instanceId];
    },
    _sortListenersOfFixedPriority: function (listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners)
            return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if(!fixedListeners || fixedListeners.length === 0)
            return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len;) {
            if (fixedListeners[index]._getFixedPriority() >= 0)
                break;
            ++index;
        }
        listeners.gt0Index = index;
    },
    _sortListenersOfFixedPriorityAsc: function (l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
    },
    _onUpdateListeners: function (listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners)
            return;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener;
        if (sceneGraphPriorityListeners) {
            for (i = 0; i < sceneGraphPriorityListeners.length;) {
                selListener = sceneGraphPriorityListeners[i];
                if (!selListener._isRegistered()) {
                    cc.arrayRemoveObject(sceneGraphPriorityListeners, selListener);
                } else
                    ++i;
            }
        }
        if (fixedPriorityListeners) {
            for (i = 0; i < fixedPriorityListeners.length;) {
                selListener = fixedPriorityListeners[i];
                if (!selListener._isRegistered())
                    cc.arrayRemoveObject(fixedPriorityListeners, selListener);
                else
                    ++i;
            }
        }
        if (sceneGraphPriorityListeners && sceneGraphPriorityListeners.length === 0)
            listeners.clearSceneGraphListeners();
        if (fixedPriorityListeners && fixedPriorityListeners.length === 0)
            listeners.clearFixedListeners();
    },
    _updateListeners: function (event) {
        var locInDispatch = this._inDispatch;
        cc.assert(locInDispatch > 0, cc._LogInfos.EventManager__updateListeners);
        if (event.getType() == cc.Event.TOUCH) {
            this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
            this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        } else
            this._onUpdateListeners(cc.__getListenerID(event));
        if(locInDispatch > 1)
            return;
        cc.assert(locInDispatch == 1, cc._LogInfos.EventManager__updateListeners_2);
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) {
            if (locListenersMap[selKey].empty()) {
                delete locPriorityDirtyFlagMap[selKey];
                delete locListenersMap[selKey];
            }
        }
        var locToAddedListeners = this._toAddedListeners;
        if (locToAddedListeners.length !== 0) {
            for (var i = 0, len = locToAddedListeners.length; i < len; i++)
                this._forceAddEventListener(locToAddedListeners[i]);
            this._toAddedListeners.length = 0;
        }
    },
    _onTouchEventCallback: function(listener, argsObj){
        if (!listener._isRegistered)
            return false;
        var event = argsObj.event, selTouch = argsObj.selTouch;
        event._setCurrentTarget(listener._node);
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), eventCode = cc.EventTouch.EventCode;
        if (getCode == eventCode.BEGAN) {
            if (listener.onTouchBegan) {
                isClaimed = listener.onTouchBegan(selTouch, event);
                if (isClaimed && listener._registered)
                    listener._claimedTouches.push(selTouch);
            }
        } else if (listener._claimedTouches.length > 0
            && ((removedIdx = listener._claimedTouches.indexOf(selTouch)) != -1)) {
            isClaimed = true;
            if(getCode === eventCode.MOVED && listener.onTouchMoved){
                listener.onTouchMoved(selTouch, event);
            } else if(getCode === eventCode.ENDED){
                if (listener.onTouchEnded)
                    listener.onTouchEnded(selTouch, event);
                if (listener._registered)
                    listener._claimedTouches.splice(removedIdx, 1);
            } else if(getCode === eventCode.CANCELLED){
                if (listener.onTouchCancelled)
                    listener.onTouchCancelled(selTouch, event);
                if (listener._registered)
                    listener._claimedTouches.splice(removedIdx, 1);
            }
        }
        if (event.isStopped()) {
            cc.eventManager._updateListeners(event);
            return true;
        }
        if (isClaimed && listener._registered && listener.swallowTouches) {
            if (argsObj.needsMutableSet)
                argsObj.touches.splice(selTouch, 1);
            return true;
        }
        return false;
    },
    _dispatchTouchEvent: function (event) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var oneByOneListeners = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        var allAtOnceListeners = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null == oneByOneListeners && null == allAtOnceListeners)
            return;
        var originalTouches = event.getTouches(), mutableTouches = cc.copyArray(originalTouches);
        var oneByOneArgsObj = {event: event, needsMutableSet: (oneByOneListeners && allAtOnceListeners), touches: mutableTouches, selTouch: null};
        if (oneByOneListeners) {
            for (var i = 0; i < originalTouches.length; i++) {
                oneByOneArgsObj.selTouch = originalTouches[i];
                this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                if (event.isStopped())
                    return;
            }
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
            this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {event: event, touches: mutableTouches});
            if (event.isStopped())
                return;
        }
        this._updateListeners(event);
    },
    _onTouchesEventCallback: function (listener, callbackParams) {
        if (!listener._registered)
            return false;
        var eventCode = cc.EventTouch.EventCode, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event._setCurrentTarget(listener._node);
        if(getCode == eventCode.BEGAN && listener.onTouchesBegan)
            listener.onTouchesBegan(touches, event);
        else if(getCode == eventCode.MOVED && listener.onTouchesMoved)
            listener.onTouchesMoved(touches, event);
        else if(getCode == eventCode.ENDED && listener.onTouchesEnded)
            listener.onTouchesEnded(touches, event);
        else if(getCode == eventCode.CANCELLED && listener.onTouchesCancelled)
            listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
            cc.eventManager._updateListeners(event);
            return true;
        }
        return false;
    },
    _associateNodeAndEventListener: function (node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (!listeners) {
            listeners = [];
            this._nodeListenersMap[node.__instanceId] = listeners;
        }
        listeners.push(listener);
    },
    _dissociateNodeAndEventListener: function (node, listener) {
        var listeners = this._nodeListenersMap[node.__instanceId];
        if (listeners) {
            cc.arrayRemoveObject(listeners, listener);
            if (listeners.length === 0)
                delete this._nodeListenersMap[node.__instanceId];
        }
    },
    _dispatchEventToListeners: function (listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners) {
            if (fixedPriorityListeners.length !== 0) {
                for (; i < listeners.gt0Index; ++i) {
                    selListener = fixedPriorityListeners[i];
                    if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                        shouldStopPropagation = true;
                        break;
                    }
                }
            }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) {
            for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
                selListener = sceneGraphPriorityListeners[j];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = true;
                    break;
                }
            }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) {
            for (; i < fixedPriorityListeners.length; ++i) {
                selListener = fixedPriorityListeners[i];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = true;
                    break;
                }
            }
        }
    },
    _setDirty: function (listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        if (locDirtyFlagMap[listenerID] == null)
            locDirtyFlagMap[listenerID] = flag;
        else
            locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
    },
    _visitTarget: function (node, isRootNode) {
        var children = node.getChildren(), i = 0;
        var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
        if (childrenCount > 0) {
            var child;
            for (; i < childrenCount; i++) {
                child = children[i];
                if (child && child.getLocalZOrder() < 0)
                    this._visitTarget(child, false);
                else
                    break;
            }
            if (locNodeListenersMap[node.__instanceId] != null) {
                if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()])
                    locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
            }
            for (; i < childrenCount; i++) {
                child = children[i];
                if (child)
                    this._visitTarget(child, false);
            }
        } else {
            if (locNodeListenersMap[node.__instanceId] != null) {
                if (!locGlobalZOrderNodeMap[node.getGlobalZOrder()])
                    locGlobalZOrderNodeMap[node.getGlobalZOrder()] = [];
                locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
            }
        }
        if (isRootNode) {
            var globalZOrders = [];
            for (var selKey in locGlobalZOrderNodeMap)
                globalZOrders.push(selKey);
            globalZOrders.sort(this._sortNumberAsc);
            var zOrdersLen = globalZOrders.length, selZOrders, j, locNodePriorityMap = this._nodePriorityMap;
            for (i = 0; i < zOrdersLen; i++) {
                selZOrders = locGlobalZOrderNodeMap[globalZOrders[i]];
                for (j = 0; j < selZOrders.length; j++)
                    locNodePriorityMap[selZOrders[j]] = ++this._nodePriorityIndex;
            }
            this._globalZOrderNodeMap = {};
        }
    },
    _sortNumberAsc : function (a, b) {
        return a - b;
    },
    addListener: function (listener, nodeOrPriority) {
        cc.assert(listener && nodeOrPriority, cc._LogInfos.eventManager_addListener_2);
        if(!(listener instanceof cc.EventListener)){
            cc.assert(!cc.isNumber(nodeOrPriority), cc._LogInfos.eventManager_addListener_3);
            listener = cc.EventListener.create(listener);
        } else {
            if(listener._isRegistered()){
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return;
            }
        }
        if (!listener.checkAvailable())
            return;
        if (cc.isNumber(nodeOrPriority)) {
            if (nodeOrPriority == 0) {
                cc.log(cc._LogInfos.eventManager_addListener);
                return;
            }
            listener._setSceneGraphPriority(null);
            listener._setFixedPriority(nodeOrPriority);
            listener._setRegistered(true);
            listener._setPaused(false);
            this._addListener(listener);
        } else {
            listener._setSceneGraphPriority(nodeOrPriority);
            listener._setFixedPriority(0);
            listener._setRegistered(true);
            this._addListener(listener);
        }
        return listener;
    },
    addCustomListener: function (eventName, callback) {
        var listener = new cc._EventListenerCustom(eventName, callback);
        this.addListener(listener, 1);
        return listener;
    },
    removeListener: function (listener) {
        if (listener == null)
            return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
            var listeners = locListener[selKey];
            var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
            isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
            if (isFound){
               this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            }else{
                isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
                if (isFound)
                    this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
            }
            if (listeners.empty()) {
                delete this._priorityDirtyFlagMap[listener._getListenerID()];
                delete locListener[selKey];
            }
            if (isFound)
                break;
        }
        if (!isFound) {
            var locToAddedListeners = this._toAddedListeners;
            for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                var selListener = locToAddedListeners[i];
                if (selListener == listener) {
                    cc.arrayRemoveObject(locToAddedListeners, selListener);
                    break;
                }
            }
        }
    },
    _removeListenerInVector : function(listeners, listener){
        if (listeners == null)
            return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
            var selListener = listeners[i];
            if (selListener == listener) {
                selListener._setRegistered(false);
                if (selListener._getSceneGraphPriority() != null){
                    this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                    selListener._setSceneGraphPriority(null);
                }
                if (this._inDispatch == 0)
                    cc.arrayRemoveObject(listeners, selListener);
                return true;
            }
        }
        return false;
    },
    removeListeners: function (listenerType, recursive) {
        var _t = this;
        if (listenerType instanceof cc.Node) {
            delete _t._nodePriorityMap[listenerType.__instanceId];
            cc.arrayRemoveObject(_t._dirtyNodes, listenerType);
            var listeners = _t._nodeListenersMap[listenerType.__instanceId], i;
            if (listeners) {
                var listenersCopy = cc.copyArray(listeners);
                for (i = 0; i < listenersCopy.length; i++)
                    _t.removeListener(listenersCopy[i]);
                listenersCopy.length = 0;
            }
            var locToAddedListeners = _t._toAddedListeners;
            for (i = 0; i < locToAddedListeners.length; ) {
                var listener = locToAddedListeners[i];
                if (listener._getSceneGraphPriority() == listenerType) {
                    listener._setSceneGraphPriority(null);
                    listener._setRegistered(false);
                    locToAddedListeners.splice(i, 1);
                } else
                    ++i;
            }
            if (recursive === true) {
                var locChildren = listenerType.getChildren(), len;
                for (i = 0, len = locChildren.length; i< len; i++)
                    _t.removeListeners(locChildren[i], true);
            }
        } else {
            if (listenerType == cc.EventListener.TOUCH_ONE_BY_ONE)
                _t._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID);
            else if (listenerType == cc.EventListener.TOUCH_ALL_AT_ONCE)
                _t._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
            else if (listenerType == cc.EventListener.MOUSE)
                _t._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID);
            else if (listenerType == cc.EventListener.ACCELERATION)
                _t._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID);
            else if (listenerType == cc.EventListener.KEYBOARD)
                _t._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID);
            else
                cc.log(cc._LogInfos.eventManager_removeListeners);
        }
    },
    removeCustomListeners: function (customEventName) {
        this._removeListenersForListenerID(customEventName);
    },
    removeAllListeners: function () {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners){
            if(locInternalCustomEventIDs.indexOf(selKey) === -1)
                this._removeListenersForListenerID(selKey);
        }
    },
    setPriority: function (listener, fixedPriority) {
        if (listener == null)
            return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
            var selListeners = locListeners[selKey];
            var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
            if (fixedPriorityListeners) {
                var found = fixedPriorityListeners.indexOf(listener);
                if (found != -1) {
                    if(listener._getSceneGraphPriority() != null)
                        cc.log(cc._LogInfos.eventManager_setPriority);
                    if (listener._getFixedPriority() !== fixedPriority) {
                        listener._setFixedPriority(fixedPriority);
                        this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                    }
                    return;
                }
            }
        }
    },
    setEnabled: function (enabled) {
        this._isEnabled = enabled;
    },
    isEnabled: function () {
        return this._isEnabled;
    },
    dispatchEvent: function (event) {
        if (!this._isEnabled)
            return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if(!event || !event.getType)
            throw "event is undefined";
        if (event.getType() == cc.Event.TOUCH) {
            this._dispatchTouchEvent(event);
            this._inDispatch--;
            return;
        }
        var listenerID = cc.__getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (selListeners != null)
            this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
        this._updateListeners(event);
        this._inDispatch--;
    },
    _onListenerCallback: function(listener, event){
        event._setCurrentTarget(listener._getSceneGraphPriority());
        listener._onEvent(event);
        return event.isStopped();
    },
    dispatchCustomEvent: function (eventName, optionalUserData) {
        var ev = new cc.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
    }
};
cc.EventHelper = function(){};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function ( object ) {
        object.addEventListener = cc.EventHelper.prototype.addEventListener;
        object.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        object.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        object.dispatchEvent = cc.EventHelper.prototype.dispatchEvent;
    },
    addEventListener: function ( type, listener, target ) {
        if ( this._listeners === undefined )
            this._listeners = {};
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined )
            listeners[ type ] = [];
        if ( !this.hasEventListener(type, listener, target))
            listeners[ type ].push( {callback:listener, eventTarget: target} );
    },
    hasEventListener: function ( type, listener, target ) {
        if ( this._listeners === undefined )
            return false;
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined ) {
            for(var i = 0, len = listeners.length; i < len ; i++){
                var selListener = listeners[i];
                if(selListener.callback == listener && selListener.eventTarget == target)
                    return true;
            }
        }
        return false;
    },
    removeEventListener: function( type, target){
        if ( this._listeners === undefined )
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[ type ];
        if ( listenerArray !== undefined ) {
            for(var i = 0; i < listenerArray.length ; ){
                var selListener = listenerArray[i];
                if(selListener.eventTarget == target)
                    listenerArray.splice( i, 1 );
                else
                    i++
            }
        }
    },
    dispatchEvent: function ( event, clearAfterDispatch ) {
        if ( this._listeners === undefined )
            return;
        if(clearAfterDispatch == null)
            clearAfterDispatch = true;
        var listeners = this._listeners;
        var listenerArray = listeners[ event];
        if ( listenerArray !== undefined ) {
            var array = [];
            var length = listenerArray.length;
            for ( var i = 0; i < length; i ++ ) {
                array[ i ] = listenerArray[ i ];
            }
            for ( i = 0; i < length; i ++ ) {
                array[ i ].callback.call( array[i].eventTarget, this );
            }
            if(clearAfterDispatch)
                listenerArray.length = 0;
        }
    }
};
cc._tmp.PrototypeCCNode = function () {
    var _p = cc.Node.prototype;
    cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
    cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
    _p.width;
    cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
    _p.height;
    cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
    _p.anchorX;
    cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
    _p.anchorY;
    cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
    _p.skewX;
    cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
    _p.skewY;
    cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
    _p.zIndex;
    cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
    _p.vertexZ;
    cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
    _p.rotation;
    cc.defineGetterSetter(_p, "rotation", _p.getRotation, _p.setRotation);
    _p.rotationX;
    cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
    _p.rotationY;
    cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
    _p.scale;
    cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
    _p.scaleX;
    cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX);
    _p.scaleY;
    cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY);
    _p.children;
    cc.defineGetterSetter(_p, "children", _p.getChildren);
    _p.childrenCount;
    cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
    _p.parent;
    cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
    _p.visible;
    cc.defineGetterSetter(_p, "visible", _p.isVisible, _p.setVisible);
    _p.running;
    cc.defineGetterSetter(_p, "running", _p.isRunning);
    _p.ignoreAnchor;
    cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.ignoreAnchorPointForPosition);
    _p.tag;
    _p.userData;
    _p.userObject;
    _p.arrivalOrder;
    _p.actionManager;
    cc.defineGetterSetter(_p, "actionManager", _p.getActionManager, _p.setActionManager);
    _p.scheduler;
    cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
    _p.shaderProgram;
    cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
    _p.opacity;
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    _p.opacityModifyRGB;
    cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB);
    _p.cascadeOpacity;
    cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
    _p.color;
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    _p.cascadeColor;
    cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0.0,
    _rotationX: 0,
    _rotationY: 0.0,
    _scaleX: 1.0,
    _scaleY: 1.0,
    _position: null,
    _normalizedPosition:null,
    _usingNormalizedPosition: false,
    _normalizedPositionDirty: false,
    _skewX: 0.0,
    _skewY: 0.0,
    _children: null,
    _visible: true,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: false,
    _parent: null,
    _ignoreAnchorPointForPosition: false,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: true,
    _inverseDirty: true,
    _cacheDirty: false,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _transformWorld: null,
    _inverse: null,
    _reorderChildDirty: false,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: false,
    _additionalTransformDirty: false,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: false,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: false,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: false,
    _cascadeOpacityEnabled: false,
    _hashOfName: 0,
    _curLevel: -1,
    _rendererCmd:null,
    _renderCmdDirty: false,
    _initNode: function () {
        var _t = this;
        _t._anchorPoint = cc.p(0, 0);
        _t._anchorPointInPoints = cc.p(0, 0);
        _t._contentSize = cc.size(0, 0);
        _t._position = cc.p(0, 0);
        _t._normalizedPosition = cc.p(0,0);
        _t._children = [];
        _t._transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        _t._transformWorld = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        var director = cc.director;
        _t._actionManager = director.getActionManager();
        _t._scheduler = director.getScheduler();
        _t._initializedNode = true;
        _t._additionalTransform = cc.affineTransformMakeIdentity();
        if (cc.ComponentContainer) {
            _t._componentContainer = new cc.ComponentContainer(_t);
        }
        this._displayedOpacity = 255;
        this._realOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeColorEnabled = false;
        this._cascadeOpacityEnabled = false;
    },
    init: function () {
        if (this._initializedNode === false)
            this._initNode();
        return true;
    },
    _arrayMakeObjectsPerformSelector: function (array, callbackType) {
        if (!array || array.length === 0)
            return;
        var i, len = array.length, node;
        var nodeCallbackType = cc.Node._StateCallbackType;
        switch (callbackType) {
            case nodeCallbackType.onEnter:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onEnter();
                }
                break;
            case nodeCallbackType.onExit:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onExit();
                }
                break;
            case nodeCallbackType.onEnterTransitionDidFinish:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onEnterTransitionDidFinish();
                }
                break;
            case nodeCallbackType.cleanup:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.cleanup();
                }
                break;
            case nodeCallbackType.updateTransform:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.updateTransform();
                }
                break;
            case nodeCallbackType.onExitTransitionDidStart:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.onExitTransitionDidStart();
                }
                break;
            case nodeCallbackType.sortAllChildren:
                for (i = 0; i < len; i++) {
                    node = array[i];
                    if (node)
                        node.sortAllChildren();
                }
                break;
            default :
                cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector);
                break;
        }
    },
    setNodeDirty: null,
    attr: function (attrs) {
        for (var key in attrs) {
            this[key] = attrs[key];
        }
    },
    getSkewX: function () {
        return this._skewX;
    },
    setSkewX: function (newSkewX) {
        this._skewX = newSkewX;
        this.setNodeDirty();
    },
    getSkewY: function () {
        return this._skewY;
    },
    setSkewY: function (newSkewY) {
        this._skewY = newSkewY;
        this.setNodeDirty();
    },
    setLocalZOrder: function (localZOrder) {
        this._localZOrder = localZOrder;
        if (this._parent)
            this._parent.reorderChild(this, localZOrder);
        cc.eventManager._setDirtyForNode(this);
    },
    _setLocalZOrder: function (localZOrder) {
        this._localZOrder = localZOrder;
    },
    getLocalZOrder: function () {
        return this._localZOrder;
    },
    getZOrder: function () {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder();
    },
    setZOrder: function (z) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(z);
    },
    setGlobalZOrder: function (globalZOrder) {
        if (this._globalZOrder != globalZOrder) {
            this._globalZOrder = globalZOrder;
            cc.eventManager._setDirtyForNode(this);
        }
    },
    getGlobalZOrder: function () {
        return this._globalZOrder;
    },
    getVertexZ: function () {
        return this._vertexZ;
    },
    setVertexZ: function (Var) {
        this._vertexZ = Var;
    },
    getRotation: function () {
        if (this._rotationX !== this._rotationY)
            cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX;
    },
    setRotation: function (newRotation) {
        this._rotationX = this._rotationY = newRotation;
        this._rotationRadiansX = this._rotationX * 0.017453292519943295;
        this._rotationRadiansY = this._rotationY * 0.017453292519943295;
        this.setNodeDirty();
    },
    getRotationX: function () {
        return this._rotationX;
    },
    setRotationX: function (rotationX) {
        this._rotationX = rotationX;
        this._rotationRadiansX = this._rotationX * 0.017453292519943295;
        this.setNodeDirty();
    },
    getRotationY: function () {
        return this._rotationY;
    },
    setRotationY: function (rotationY) {
        this._rotationY = rotationY;
        this._rotationRadiansY = this._rotationY * 0.017453292519943295;
        this.setNodeDirty();
    },
    getScale: function () {
        if (this._scaleX !== this._scaleY)
            cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX;
    },
    setScale: function (scale, scaleY) {
        this._scaleX = scale;
        this._scaleY = (scaleY || scaleY === 0) ? scaleY : scale;
        this.setNodeDirty();
    },
    getScaleX: function () {
        return this._scaleX;
    },
    setScaleX: function (newScaleX) {
        this._scaleX = newScaleX;
        this.setNodeDirty();
    },
    getScaleY: function () {
        return this._scaleY;
    },
    setScaleY: function (newScaleY) {
        this._scaleY = newScaleY;
        this.setNodeDirty();
    },
    setPosition: function (newPosOrxValue, yValue) {
        var locPosition = this._position;
        if (yValue === undefined) {
            locPosition.x = newPosOrxValue.x;
            locPosition.y = newPosOrxValue.y;
        } else {
            locPosition.x = newPosOrxValue;
            locPosition.y = yValue;
        }
        this.setNodeDirty();
        this._usingNormalizedPosition = false;
    },
    setNormalizedPosition: function(posOrX, y){
        var locPosition = this._normalizedPosition;
        if (y === undefined) {
            locPosition.x = posOrX.x;
            locPosition.y = posOrX.y;
        } else {
            locPosition.x = posOrX;
            locPosition.y = y;
        }
        this.setNodeDirty();
        this._normalizedPositionDirty = this._usingNormalizedPosition = true;
    },
    getPosition: function () {
        return cc.p(this._position);
    },
    getNormalizedPosition: function(){
        return cc.p(this._normalizedPosition);
    },
    getPositionX: function () {
        return this._position.x;
    },
    setPositionX: function (x) {
        this._position.x = x;
        this.setNodeDirty();
    },
    getPositionY: function () {
        return  this._position.y;
    },
    setPositionY: function (y) {
        this._position.y = y;
        this.setNodeDirty();
    },
    getChildrenCount: function () {
        return this._children.length;
    },
    getChildren: function () {
        return this._children;
    },
    isVisible: function () {
        return this._visible;
    },
    setVisible: function (visible) {
        if(this._visible != visible){
            this._visible = visible;
            if(visible) this.setNodeDirty();
            cc.renderer.childrenOrderDirty = true;
        }
    },
    getAnchorPoint: function () {
        return cc.p(this._anchorPoint);
    },
    setAnchorPoint: function (point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (y === undefined) {
            if ((point.x === locAnchorPoint.x) && (point.y === locAnchorPoint.y))
                return;
            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
        } else {
            if ((point === locAnchorPoint.x) && (y === locAnchorPoint.y))
                return;
            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
        }
        var locAPP = this._anchorPointInPoints, locSize = this._contentSize;
        locAPP.x = locSize.width * locAnchorPoint.x;
        locAPP.y = locSize.height * locAnchorPoint.y;
        this.setNodeDirty();
    },
    _getAnchor: function () {
        return this._anchorPoint;
    },
    _setAnchor: function (p) {
        var x = p.x, y = p.y;
        if (this._anchorPoint.x !== x) {
            this._anchorPoint.x = x;
            this._anchorPointInPoints.x = this._contentSize.width * x;
        }
        if (this._anchorPoint.y !== y) {
            this._anchorPoint.y = y;
            this._anchorPointInPoints.y = this._contentSize.height * y;
        }
        this.setNodeDirty();
    },
    _getAnchorX: function () {
        return this._anchorPoint.x;
    },
    _setAnchorX: function (x) {
        if (this._anchorPoint.x === x) return;
        this._anchorPoint.x = x;
        this._anchorPointInPoints.x = this._contentSize.width * x;
        this.setNodeDirty();
    },
    _getAnchorY: function () {
        return this._anchorPoint.y;
    },
    _setAnchorY: function (y) {
        if (this._anchorPoint.y === y) return;
        this._anchorPoint.y = y;
        this._anchorPointInPoints.y = this._contentSize.height * y;
        this.setNodeDirty();
    },
    getAnchorPointInPoints: function () {
        return cc.p(this._anchorPointInPoints);
    },
    _getWidth: function () {
        return this._contentSize.width;
    },
    _setWidth: function (width) {
        this._contentSize.width = width;
        this._anchorPointInPoints.x = width * this._anchorPoint.x;
        this.setNodeDirty();
    },
    _getHeight: function () {
        return this._contentSize.height;
    },
    _setHeight: function (height) {
        this._contentSize.height = height;
        this._anchorPointInPoints.y = height * this._anchorPoint.y;
        this.setNodeDirty();
    },
    getContentSize: function () {
        return cc.size(this._contentSize);
    },
    setContentSize: function (size, height) {
        var locContentSize = this._contentSize;
        if (height === undefined) {
            if ((size.width === locContentSize.width) && (size.height === locContentSize.height))
                return;
            locContentSize.width = size.width;
            locContentSize.height = size.height;
        } else {
            if ((size === locContentSize.width) && (height === locContentSize.height))
                return;
            locContentSize.width = size;
            locContentSize.height = height;
        }
        var locAPP = this._anchorPointInPoints, locAnchorPoint = this._anchorPoint;
        locAPP.x = locContentSize.width * locAnchorPoint.x;
        locAPP.y = locContentSize.height * locAnchorPoint.y;
        this.setNodeDirty();
    },
    isRunning: function () {
        return this._running;
    },
    getParent: function () {
        return this._parent;
    },
    setParent: function (parent) {
        this._parent = parent;
    },
    isIgnoreAnchorPointForPosition: function () {
        return this._ignoreAnchorPointForPosition;
    },
    ignoreAnchorPointForPosition: function (newValue) {
        if (newValue != this._ignoreAnchorPointForPosition) {
            this._ignoreAnchorPointForPosition = newValue;
            this.setNodeDirty();
        }
    },
    getTag: function () {
        return this.tag;
    },
    setTag: function (tag) {
        this.tag = tag;
    },
    setName: function(name){
         this._name = name;
    },
    getName: function(){
        return this._name;
    },
    getUserData: function () {
        return this.userData;
    },
    setUserData: function (Var) {
        this.userData = Var;
    },
    getUserObject: function () {
        return this.userObject;
    },
    setUserObject: function (newValue) {
        if (this.userObject != newValue) {
            this.userObject = newValue;
        }
    },
    getOrderOfArrival: function () {
        return this.arrivalOrder;
    },
    setOrderOfArrival: function (Var) {
        this.arrivalOrder = Var;
    },
    getActionManager: function () {
        if (!this._actionManager) {
            this._actionManager = cc.director.getActionManager();
        }
        return this._actionManager;
    },
    setActionManager: function (actionManager) {
        if (this._actionManager != actionManager) {
            this.stopAllActions();
            this._actionManager = actionManager;
        }
    },
    getScheduler: function () {
        if (!this._scheduler) {
            this._scheduler = cc.director.getScheduler();
        }
        return this._scheduler;
    },
    setScheduler: function (scheduler) {
        if (this._scheduler != scheduler) {
            this.unscheduleAllCallbacks();
            this._scheduler = scheduler;
        }
    },
    boundingBox: function(){
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox();
    },
    getBoundingBox: function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
    },
    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup);
    },
    getChildByTag: function (aTag) {
        var __children = this._children;
        if (__children != null) {
            for (var i = 0; i < __children.length; i++) {
                var node = __children[i];
                if (node && node.tag == aTag)
                    return node;
            }
        }
        return null;
    },
    getChildByName: function(name){
        if(!name){
            cc.log("Invalid name");
            return null;
        }
        var locChildren = this._children;
        for(var i = 0, len = locChildren.length; i < len; i++){
           if(locChildren[i]._name == name)
            return locChildren[i];
        }
        return null;
    },
    addChild: function (child, localZOrder, tag) {
        localZOrder = localZOrder === undefined ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if(cc.isUndefined(tag)){
            tag = undefined;
            name = child._name;
        } else if(cc.isString(tag)){
            name = tag;
            tag = undefined;
        } else if(cc.isNumber(tag)){
            setTag = true;
            name = "";
        }
        cc.assert(child, cc._LogInfos.Node_addChild_3);
        cc.assert(child._parent === null, "child already added. It can't be added again");
        this._addChildHelper(child, localZOrder, tag, name, setTag);
    },
    _addChildHelper: function(child, localZOrder, tag, name, setTag){
        if(!this._children)
            this._children = [];
        this._insertChild(child, localZOrder);
        if(setTag)
            child.setTag(tag);
        else
            child.setName(name);
        child.setParent(this);
        child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if( this._running ){
            child.onEnter();
            if (this._isTransitionFinished)
                child.onEnterTransitionDidFinish();
        }
        if (this._cascadeColorEnabled)
            this._enableCascadeColor();
        if (this._cascadeOpacityEnabled)
            this._enableCascadeOpacity();
    },
    removeFromParent: function (cleanup) {
        if (this._parent) {
            if (cleanup == null)
                cleanup = true;
            this._parent.removeChild(this, cleanup);
        }
    },
    removeFromParentAndCleanup: function (cleanup) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(cleanup);
    },
    removeChild: function (child, cleanup) {
        if (this._children.length === 0)
            return;
        if (cleanup == null)
            cleanup = true;
        if (this._children.indexOf(child) > -1)
            this._detachChild(child, cleanup);
        this.setNodeDirty();
        cc.renderer.childrenOrderDirty = true;
    },
    removeChildByTag: function (tag, cleanup) {
        if (tag === cc.NODE_TAG_INVALID)
            cc.log(cc._LogInfos.Node_removeChildByTag);
        var child = this.getChildByTag(tag);
        if (child == null)
            cc.log(cc._LogInfos.Node_removeChildByTag_2, tag);
        else
            this.removeChild(child, cleanup);
    },
    removeAllChildrenWithCleanup: function (cleanup) {
        this.removeAllChildren(cleanup);
    },
    removeAllChildren: function (cleanup) {
        var __children = this._children;
        if (__children != null) {
            if (cleanup == null)
                cleanup = true;
            for (var i = 0; i < __children.length; i++) {
                var node = __children[i];
                if (node) {
                    if (this._running) {
                        node.onExitTransitionDidStart();
                        node.onExit();
                    }
                    if (cleanup)
                        node.cleanup();
                    node.parent = null;
                }
            }
            this._children.length = 0;
        }
    },
    _detachChild: function (child, doCleanup) {
        if (this._running) {
            child.onExitTransitionDidStart();
            child.onExit();
        }
        if (doCleanup)
            child.cleanup();
        child.parent = null;
        child._cachedParent = null;
        cc.arrayRemoveObject(this._children, child);
    },
    _insertChild: function (child, z) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        this._children.push(child);
        child._setLocalZOrder(z);
    },
    reorderChild: function (child, zOrder) {
        cc.assert(child, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        child.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        child._setLocalZOrder(zOrder);
        this.setNodeDirty();
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var _children = this._children;
            var len = _children.length, i, j, tmp;
            for(i=1; i<len; i++){
                tmp = _children[i];
                j = i - 1;
                while(j >= 0){
                    if(tmp._localZOrder < _children[j]._localZOrder){
                        _children[j+1] = _children[j];
                    }else if(tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder){
                        _children[j+1] = _children[j];
                    }else{
                        break;
                    }
                    j--;
                }
                _children[j+1] = tmp;
            }
            this._reorderChildDirty = false;
        }
    },
    draw: function (ctx) {
    },
    transformAncestors: function () {
        if (this._parent != null) {
            this._parent.transformAncestors();
            this._parent.transform();
        }
    },
    onEnter: function () {
        this._isTransitionFinished = false;
        this._running = true;//should be running before resumeSchedule
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnter);
        this.resume();
    },
    onEnterTransitionDidFinish: function () {
        this._isTransitionFinished = true;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnterTransitionDidFinish);
    },
    onExitTransitionDidStart: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExitTransitionDidStart);
    },
    onExit: function () {
        this._running = false;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExit);
        this.removeAllComponents();
    },
    runAction: function (action) {
        cc.assert(action, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(action, this, !this._running);
        return action;
    },
    stopAllActions: function () {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this);
    },
    stopAction: function (action) {
        this.actionManager.removeAction(action);
    },
    stopActionByTag: function (tag) {
        if (tag === cc.ACTION_TAG_INVALID) {
            cc.log(cc._LogInfos.Node_stopActionByTag);
            return;
        }
        this.actionManager.removeActionByTag(tag, this);
    },
    getActionByTag: function (tag) {
        if (tag === cc.ACTION_TAG_INVALID) {
            cc.log(cc._LogInfos.Node_getActionByTag);
            return null;
        }
        return this.actionManager.getActionByTag(tag, this);
    },
    getNumberOfRunningActions: function () {
        return this.actionManager.numberOfRunningActionsInTarget(this);
    },
    scheduleUpdate: function () {
        this.scheduleUpdateWithPriority(0);
    },
    scheduleUpdateWithPriority: function (priority) {
        this.scheduler.scheduleUpdateForTarget(this, priority, !this._running);
    },
    unscheduleUpdate: function () {
        this.scheduler.unscheduleUpdateForTarget(this);
    },
    schedule: function (callback_fn, interval, repeat, delay) {
        interval = interval || 0;
        cc.assert(callback_fn, cc._LogInfos.Node_schedule);
        cc.assert(interval >= 0, cc._LogInfos.Node_schedule_2);
        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        this.scheduler.scheduleCallbackForTarget(this, callback_fn, interval, repeat, delay, !this._running);
    },
    scheduleOnce: function (callback_fn, delay) {
        this.schedule(callback_fn, 0.0, 0, delay);
    },
    unschedule: function (callback_fn) {
        if (!callback_fn)
            return;
        this.scheduler.unscheduleCallbackForTarget(this, callback_fn);
    },
    unscheduleAllCallbacks: function () {
        this.scheduler.unscheduleAllCallbacksForTarget(this);
    },
    resumeSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume();
    },
    resume: function () {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause();
    },
    pause: function () {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this);
    },
    setAdditionalTransform: function (additionalTransform) {
        this._additionalTransform = additionalTransform;
        this._transformDirty = true;
        this._additionalTransformDirty = true;
    },
    getParentToNodeTransform: function () {
        if (this._inverseDirty) {
            this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform());
            this._inverseDirty = false;
        }
        return this._inverse;
    },
    parentToNodeTransform: function () {
        return this.getParentToNodeTransform();
    },
    getNodeToWorldTransform: function () {
        var t = this.getNodeToParentTransform();
        for (var p = this._parent; p != null; p = p.parent)
            t = cc.affineTransformConcat(t, p.getNodeToParentTransform());
        return t;
    },
    nodeToWorldTransform: function(){
        return this.getNodeToWorldTransform();
    },
    getWorldToNodeTransform: function () {
        return cc.affineTransformInvert(this.getNodeToWorldTransform());
    },
    worldToNodeTransform: function () {
        return this.getWorldToNodeTransform();
    },
    convertToNodeSpace: function (worldPoint) {
        return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
    },
    convertToWorldSpace: function (nodePoint) {
        nodePoint = nodePoint || cc.p(0,0);
        return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
    },
    convertToNodeSpaceAR: function (worldPoint) {
        return cc.pSub(this.convertToNodeSpace(worldPoint), this._anchorPointInPoints);
    },
    convertToWorldSpaceAR: function (nodePoint) {
        nodePoint = nodePoint || cc.p(0,0);
        var pt = cc.pAdd(nodePoint, this._anchorPointInPoints);
        return this.convertToWorldSpace(pt);
    },
    _convertToWindowSpace: function (nodePoint) {
        var worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.director.convertToUI(worldPoint);
    },
    convertTouchToNodeSpace: function (touch) {
        var point = touch.getLocation();
        return this.convertToNodeSpace(point);
    },
    convertTouchToNodeSpaceAR: function (touch) {
        var point = touch.getLocation();
        point = cc.director.convertToGL(point);
        return this.convertToNodeSpaceAR(point);
    },
    update: function (dt) {
        if (this._componentContainer && !this._componentContainer.isEmpty())
            this._componentContainer.visit(dt);
    },
    updateTransform: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform);
    },
    retain: function () {
    },
    release: function () {
    },
    getComponent: function (name) {
        if(this._componentContainer)
            return this._componentContainer.getComponent(name);
        return null;
    },
    addComponent: function (component) {
        if(this._componentContainer)
            this._componentContainer.add(component);
    },
    removeComponent: function (component) {
        if(this._componentContainer)
            return this._componentContainer.remove(component);
        return false;
    },
    removeAllComponents: function () {
        if(this._componentContainer)
            this._componentContainer.removeAll();
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function(){
        return this.getNodeToParentTransform();
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function () {
        if (this._cacheDirty === false) {
            this._cacheDirty = true;
            var cachedP = this._cachedParent;
            cachedP && cachedP != this && cachedP._setNodeDirtyForCache();
        }
    },
    _setCachedParent: function(cachedParent){
        if(this._cachedParent ==  cachedParent)
            return;
        this._cachedParent = cachedParent;
        var children = this._children;
        for(var i = 0, len = children.length; i < len; i++)
            children[i]._setCachedParent(cachedParent);
    },
    getCamera: function () {
        if (!this._camera) {
            this._camera = new cc.Camera();
        }
        return this._camera;
    },
    getGrid: function () {
        return this.grid;
    },
    setGrid: function (grid) {
        this.grid = grid;
    },
    getShaderProgram: function () {
        return this._shaderProgram;
    },
    setShaderProgram: function (newShaderProgram) {
        this._shaderProgram = newShaderProgram;
    },
    getGLServerState: function () {
        return this._glServerState;
    },
    setGLServerState: function (state) {
        this._glServerState = state;
    },
    getBoundingBoxToWorld: function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.getNodeToWorldTransform();
        rect = cc.rectApplyAffineTransform(rect, this.getNodeToWorldTransform());
        if (!this._children)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                if (childRect)
                    rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    },
    _getBoundingBoxToCurrentNode: function (parentTransform) {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = (parentTransform == null) ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
        rect = cc.rectApplyAffineTransform(rect, trans);
        if (!this._children)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                if (childRect)
                    rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    },
    _getNodeToParentTransformForWebGL: function () {
        var _t = this;
        if(_t._usingNormalizedPosition && _t._parent){
            var conSize = _t._parent._contentSize;
            _t._position.x = _t._normalizedPosition.x * conSize.width;
            _t._position.y = _t._normalizedPosition.y * conSize.height;
            _t._normalizedPositionDirty = false;
        }
        if (_t._transformDirty) {
            var x = _t._position.x;
            var y = _t._position.y;
            var apx = _t._anchorPointInPoints.x, napx = -apx;
            var apy = _t._anchorPointInPoints.y, napy = -apy;
            var scx = _t._scaleX, scy = _t._scaleY;
            if (_t._ignoreAnchorPointForPosition) {
                x += apx;
                y += apy;
            }
            var cx = 1, sx = 0, cy = 1, sy = 0;
            if (_t._rotationX !== 0 || _t._rotationY !== 0) {
                cx = Math.cos(-_t._rotationRadiansX);
                sx = Math.sin(-_t._rotationRadiansX);
                cy = Math.cos(-_t._rotationRadiansY);
                sy = Math.sin(-_t._rotationRadiansY);
            }
            var needsSkewMatrix = ( _t._skewX || _t._skewY );
            if (!needsSkewMatrix && (apx !== 0 || apy !== 0)) {
                x += cy * napx * scx + -sx * napy * scy;
                y += sy * napx * scx + cx * napy * scy;
            }
            var t = _t._transform;
            t.a = cy * scx;
            t.b = sy * scx;
            t.c = -sx * scy;
            t.d = cx * scy;
            t.tx = x;
            t.ty = y;
            if (needsSkewMatrix) {
                t = cc.affineTransformConcat({a: 1.0, b: Math.tan(cc.degreesToRadians(_t._skewY)),
                    c: Math.tan(cc.degreesToRadians(_t._skewX)), d: 1.0, tx: 0.0, ty: 0.0}, t);
                if (apx !== 0 || apy !== 0)
                    t = cc.affineTransformTranslate(t, napx, napy);
            }
            if (_t._additionalTransformDirty) {
                t = cc.affineTransformConcat(t, _t._additionalTransform);
                _t._additionalTransformDirty = false;
            }
            _t._transform = t;
            _t._transformDirty = false;
        }
        return _t._transform;
    },
    _updateColor: function(){
    },
    getOpacity: function () {
        return this._realOpacity;
    },
    getDisplayedOpacity: function () {
        return this._displayedOpacity;
    },
    setOpacity: function (opacity) {
        this._displayedOpacity = this._realOpacity = opacity;
        var parentOpacity = 255, locParent = this._parent;
        if (locParent && locParent.cascadeOpacity)
            parentOpacity = locParent.getDisplayedOpacity();
        this.updateDisplayedOpacity(parentOpacity);
        this._displayedColor.a = this._realColor.a = opacity;
    },
    updateDisplayedOpacity: function (parentOpacity) {
        this._displayedOpacity = this._realOpacity * parentOpacity / 255.0;
        if(this._rendererCmd && this._rendererCmd._opacity !== undefined)
            this._rendererCmd._opacity = this._displayedOpacity / 255;
        if (this._cascadeOpacityEnabled) {
            var selChildren = this._children;
            for (var i = 0; i < selChildren.length; i++) {
                var item = selChildren[i];
                if (item)
                    item.updateDisplayedOpacity(this._displayedOpacity);
            }
        }
    },
    isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled;
    },
    setCascadeOpacityEnabled: function (cascadeOpacityEnabled) {
        if (this._cascadeOpacityEnabled === cascadeOpacityEnabled)
            return;
        this._cascadeOpacityEnabled = cascadeOpacityEnabled;
        if (cascadeOpacityEnabled)
            this._enableCascadeOpacity();
        else
            this._disableCascadeOpacity();
    },
    _enableCascadeOpacity: function () {
        var parentOpacity = 255, locParent = this._parent;
        if (locParent && locParent.cascadeOpacity)
            parentOpacity = locParent.getDisplayedOpacity();
        this.updateDisplayedOpacity(parentOpacity);
    },
    _disableCascadeOpacity: function () {
        this._displayedOpacity = this._realOpacity;
        var selChildren = this._children;
        for (var i = 0; i < selChildren.length; i++) {
            var item = selChildren[i];
            if (item)
                item.updateDisplayedOpacity(255);
        }
    },
    getColor: function () {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
    },
    getDisplayedColor: function () {
        var tmpColor = this._displayedColor;
        return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
    },
    setColor: function (color) {
        var locDisplayedColor = this._displayedColor, locRealColor = this._realColor;
        locDisplayedColor.r = locRealColor.r = color.r;
        locDisplayedColor.g = locRealColor.g = color.g;
        locDisplayedColor.b = locRealColor.b = color.b;
        var parentColor, locParent = this._parent;
        if (locParent && locParent.cascadeColor)
            parentColor = locParent.getDisplayedColor();
        else
            parentColor = cc.color.WHITE;
        this.updateDisplayedColor(parentColor);
    },
    updateDisplayedColor: function (parentColor) {
        var locDispColor = this._displayedColor, locRealColor = this._realColor;
        locDispColor.r = 0 | (locRealColor.r * parentColor.r / 255.0);
        locDispColor.g = 0 | (locRealColor.g * parentColor.g / 255.0);
        locDispColor.b = 0 | (locRealColor.b * parentColor.b / 255.0);
        if (this._cascadeColorEnabled) {
            var selChildren = this._children;
            for (var i = 0; i < selChildren.length; i++) {
                var item = selChildren[i];
                if (item)
                    item.updateDisplayedColor(locDispColor);
            }
        }
    },
    isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled;
    },
    setCascadeColorEnabled: function (cascadeColorEnabled) {
        if (this._cascadeColorEnabled === cascadeColorEnabled)
            return;
        this._cascadeColorEnabled = cascadeColorEnabled;
        if (this._cascadeColorEnabled)
            this._enableCascadeColor();
        else
            this._disableCascadeColor();
    },
    _enableCascadeColor: function () {
        var parentColor , locParent = this._parent;
        if (locParent && locParent.cascadeColor)
            parentColor = locParent.getDisplayedColor();
        else
            parentColor = cc.color.WHITE;
        this.updateDisplayedColor(parentColor);
    },
    _disableCascadeColor: function () {
        var locDisplayedColor = this._displayedColor, locRealColor = this._realColor;
        locDisplayedColor.r = locRealColor.r;
        locDisplayedColor.g = locRealColor.g;
        locDisplayedColor.b = locRealColor.b;
        var selChildren = this._children, whiteColor = cc.color.WHITE;
        for (var i = 0; i < selChildren.length; i++) {
            var item = selChildren[i];
            if (item)
                item.updateDisplayedColor(whiteColor);
        }
    },
    setOpacityModifyRGB: function (opacityValue) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    _initRendererCmd: function(){
    },
    _transformForRenderer: null
});
cc.Node.create = function () {
    return new cc.Node();
};
cc.Node._StateCallbackType = {onEnter: 1, onExit: 2, cleanup: 3, onEnterTransitionDidFinish: 4, updateTransform: 5, onExitTransitionDidStart: 6, sortAllChildren: 7};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Node.prototype;
    _p.ctor = function () {
        this._initNode();
        this._initRendererCmd();
    };
    _p.setNodeDirty = function () {
        var _t = this;
        if(_t._transformDirty === false){
            _t._setNodeDirtyForCache();
            _t._renderCmdDiry = _t._transformDirty = _t._inverseDirty = true;
            cc.renderer.pushDirtyNode(this);
        }
    };
    _p.visit = function (ctx) {
        var _t = this;
        if (!_t._visible)
            return;
        if( _t._parent)
            _t._curLevel = _t._parent._curLevel + 1;
        var i, children = _t._children, child;
        _t.transform();
        var len = children.length;
        if (len > 0) {
            _t.sortAllChildren();
            for (i = 0; i < len; i++) {
                child = children[i];
                if (child._localZOrder < 0)
                    child.visit();
                else
                    break;
            }
            if(this._rendererCmd)
                cc.renderer.pushRenderCommand(this._rendererCmd);
            for (; i < len; i++) {
                children[i].visit();
            }
        } else{
            if(this._rendererCmd)
                cc.renderer.pushRenderCommand(this._rendererCmd);
        }
        this._cacheDirty = false;
    };
    _p._transformForRenderer = function () {
        var t = this.nodeToParentTransform(), worldT = this._transformWorld;
        if(this._parent){
            var pt = this._parent._transformWorld;
            worldT.a = t.a * pt.a + t.b * pt.c;
            worldT.b = t.a * pt.b + t.b * pt.d;
            worldT.c = t.c * pt.a + t.d * pt.c;
            worldT.d = t.c * pt.b + t.d * pt.d;
            if(!this._skewX || this._skewY){
                var plt = this._parent._transform;
                var xOffset = -(plt.b + plt.c) * t.ty ;
                var yOffset = -(plt.b + plt.c) * t.tx;
                worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx + xOffset);
                worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty + yOffset);
            }else{
                worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx);
                worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty);
            }
        } else {
            worldT.a = t.a;
            worldT.b = t.b;
            worldT.c = t.c;
            worldT.d = t.d;
            worldT.tx = t.tx;
            worldT.ty = t.ty;
        }
        this._renderCmdDiry = false;
        if(!this._children || this._children.length === 0)
            return;
        var i, len, locChildren = this._children;
        for(i = 0, len = locChildren.length; i< len; i++){
            locChildren[i]._transformForRenderer();
        }
    };
    _p.transform = function (ctx) {
        var t = this.getNodeToParentTransform(),
            worldT = this._transformWorld;
        if(this._parent){
            var pt = this._parent._transformWorld;
            worldT.a = t.a * pt.a + t.b * pt.c;
            worldT.b = t.a * pt.b + t.b * pt.d;
            worldT.c = t.c * pt.a + t.d * pt.c;
            worldT.d = t.c * pt.b + t.d * pt.d;
            var plt = this._parent._transform;
            var xOffset = -(plt.b + plt.c) * t.ty;
            var yOffset = -(plt.b + plt.c) * t.tx;
            worldT.tx = (t.tx * pt.a + t.ty * pt.c + pt.tx + xOffset);
            worldT.ty = (t.tx * pt.b + t.ty * pt.d + pt.ty + yOffset);
        } else {
            worldT.a = t.a;
            worldT.b = t.b;
            worldT.c = t.c;
            worldT.d = t.d;
            worldT.tx = t.tx;
            worldT.ty = t.ty;
        }
    };
    _p.getNodeToParentTransform = function () {
        var _t = this;
        if(_t._usingNormalizedPosition && _t._parent){
            var conSize = _t._parent._contentSize;
            _t._position.x = _t._normalizedPosition.x * conSize.width;
            _t._position.y = _t._normalizedPosition.y * conSize.height;
            _t._normalizedPositionDirty = false;
        }
        if (_t._transformDirty) {
            var t = _t._transform;// quick reference
            t.tx = _t._position.x;
            t.ty = _t._position.y;
            var Cos = 1, Sin = 0;
            if (_t._rotationX) {
                Cos = Math.cos(_t._rotationRadiansX);
                Sin = Math.sin(_t._rotationRadiansX);
            }
            t.a = t.d = Cos;
            t.b = -Sin;
            t.c = Sin;
            var lScaleX = _t._scaleX, lScaleY = _t._scaleY;
            var appX = _t._anchorPointInPoints.x, appY = _t._anchorPointInPoints.y;
            var sx = (lScaleX < 0.000001 && lScaleX > -0.000001) ? 0.000001 : lScaleX,
                sy = (lScaleY < 0.000001 && lScaleY > -0.000001) ? 0.000001 : lScaleY;
            if (_t._skewX || _t._skewY) {
                var skx = Math.tan(-_t._skewX * Math.PI / 180);
                var sky = Math.tan(-_t._skewY * Math.PI / 180);
                if(skx === Infinity){
                    skx = 99999999;
                }
                if(sky === Infinity){
                    sky = 99999999;
                }
                var xx = appY * skx * sx;
                var yy = appX * sky * sy;
                t.a = Cos + -Sin * sky;
                t.b = Cos * skx + -Sin;
                t.c = Sin + Cos * sky;
                t.d = Sin * skx + Cos;
                t.tx += Cos * xx + -Sin * yy;
                t.ty += Sin * xx + Cos * yy;
            }
            if (lScaleX !== 1 || lScaleY !== 1) {
                t.a *= sx;
                t.c *= sx;
                t.b *= sy;
                t.d *= sy;
            }
            t.tx += Cos * -appX * sx + -Sin * appY * sy;
            t.ty -= Sin * -appX * sx + Cos * appY * sy;
            if (_t._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
            }
            if (_t._additionalTransformDirty) {
                _t._transform = cc.affineTransformConcat(t, _t._additionalTransform);
                _t._additionalTransformDirty = false;
            }
            _t._transformDirty = false;
        }
        return _t._transform;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLCCNode), cc._LogInfos.MissingFile, "BaseNodesWebGL.js");
    cc._tmp.WebGLCCNode();
    delete cc._tmp.WebGLCCNode;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc._tmp.PrototypeTexture2D = function () {
    var _c = cc.Texture2D;
    _c.PVRImagesHavePremultipliedAlpha = function (haveAlphaPremultiplied) {
        cc.PVRHaveAlphaPremultiplied_ = haveAlphaPremultiplied;
    };
    _c.PIXEL_FORMAT_RGBA8888 = 2;
    _c.PIXEL_FORMAT_RGB888 = 3;
    _c.PIXEL_FORMAT_RGB565 = 4;
    _c.PIXEL_FORMAT_A8 = 5;
    _c.PIXEL_FORMAT_I8 = 6;
    _c.PIXEL_FORMAT_AI88 = 7;
    _c.PIXEL_FORMAT_RGBA4444 = 8;
    _c.PIXEL_FORMAT_RGB5A1 = 7;
    _c.PIXEL_FORMAT_PVRTC4 = 9;
    _c.PIXEL_FORMAT_PVRTC2 = 10;
    _c.PIXEL_FORMAT_DEFAULT = _c.PIXEL_FORMAT_RGBA8888;
    var _M = cc.Texture2D._M = {};
    _M[_c.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
    _M[_c.PIXEL_FORMAT_RGB888] = "RGB888";
    _M[_c.PIXEL_FORMAT_RGB565] = "RGB565";
    _M[_c.PIXEL_FORMAT_A8] = "A8";
    _M[_c.PIXEL_FORMAT_I8] = "I8";
    _M[_c.PIXEL_FORMAT_AI88] = "AI88";
    _M[_c.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    _M[_c.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    _M[_c.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    _M[_c.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    var _B = cc.Texture2D._B = {};
    _B[_c.PIXEL_FORMAT_RGBA8888] = 32;
    _B[_c.PIXEL_FORMAT_RGB888] = 24;
    _B[_c.PIXEL_FORMAT_RGB565] = 16;
    _B[_c.PIXEL_FORMAT_A8] = 8;
    _B[_c.PIXEL_FORMAT_I8] = 8;
    _B[_c.PIXEL_FORMAT_AI88] = 16;
    _B[_c.PIXEL_FORMAT_RGBA4444] = 16;
    _B[_c.PIXEL_FORMAT_RGB5A1] = 16;
    _B[_c.PIXEL_FORMAT_PVRTC4] = 4;
    _B[_c.PIXEL_FORMAT_PVRTC2] = 3;
    var _p = cc.Texture2D.prototype;
    _p.name;
    cc.defineGetterSetter(_p, "name", _p.getName);
    _p.pixelFormat;
    cc.defineGetterSetter(_p, "pixelFormat", _p.getPixelFormat);
    _p.pixelsWidth;
    cc.defineGetterSetter(_p, "pixelsWidth", _p.getPixelsWide);
    _p.pixelsHeight;
    cc.defineGetterSetter(_p, "pixelsHeight", _p.getPixelsHigh);
    _p.width;
    cc.defineGetterSetter(_p, "width", _p._getWidth);
    _p.height;
    cc.defineGetterSetter(_p, "height", _p._getHeight);
    _c.defaultPixelFormat = _c.PIXEL_FORMAT_DEFAULT;
};
cc._tmp.PrototypeTextureAtlas = function () {
    var _p = cc.TextureAtlas.prototype;
    _p.totalQuads;
    cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
    _p.capacity;
    cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
    _p.quads;
    cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
};
cc.ALIGN_CENTER = 0x33;
cc.ALIGN_TOP = 0x13;
cc.ALIGN_TOP_RIGHT = 0x12;
cc.ALIGN_RIGHT = 0x32;
cc.ALIGN_BOTTOM_RIGHT = 0x22;
cc.ALIGN_BOTTOM = 0x23;
cc.ALIGN_BOTTOM_LEFT = 0x21;
cc.ALIGN_LEFT = 0x31;
cc.ALIGN_TOP_LEFT = 0x11;
cc.PVRHaveAlphaPremultiplied_ = false;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    cc.Texture2D = cc.Class.extend({
        _contentSize: null,
        _isLoaded: false,
        _htmlElementObj: null,
        url: null,
        ctor: function () {
            this._contentSize = cc.size(0, 0);
            this._isLoaded = false;
            this._htmlElementObj = null;
        },
        getPixelsWide: function () {
            return this._contentSize.width;
        },
        getPixelsHigh: function () {
            return this._contentSize.height;
        },
        getContentSize: function () {
            var locScaleFactor = cc.contentScaleFactor();
            return cc.size(this._contentSize.width / locScaleFactor, this._contentSize.height / locScaleFactor);
        },
        _getWidth: function () {
            return this._contentSize.width / cc.contentScaleFactor();
        },
        _getHeight: function () {
            return this._contentSize.height / cc.contentScaleFactor();
        },
        getContentSizeInPixels: function () {
            return this._contentSize;
        },
        initWithElement: function (element) {
            if (!element)
                return;
            this._htmlElementObj = element;
        },
        getHtmlElementObj: function () {
            return this._htmlElementObj;
        },
        isLoaded: function () {
            return this._isLoaded;
        },
        handleLoadedTexture: function () {
            var self = this;
            if (self._isLoaded) return;
            if (!self._htmlElementObj) {
                var img = cc.loader.getRes(self.url);
                if (!img) return;
                self.initWithElement(img);
            }
            self._isLoaded = true;
            var locElement = self._htmlElementObj;
            self._contentSize.width = locElement.width;
            self._contentSize.height = locElement.height;
            self.dispatchEvent("load");
        },
        description: function () {
            return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">";
        },
        initWithData: function (data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
            return false;
        },
        initWithImage: function (uiImage) {
            return false;
        },
        initWithString: function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
            return false;
        },
        releaseTexture: function () {
        },
        getName: function () {
            return null;
        },
        getMaxS: function () {
            return 1;
        },
        setMaxS: function (maxS) {
        },
        getMaxT: function () {
            return 1;
        },
        setMaxT: function (maxT) {
        },
        getPixelFormat: function () {
            return null;
        },
        getShaderProgram: function () {
            return null;
        },
        setShaderProgram: function (shaderProgram) {
        },
        hasPremultipliedAlpha: function () {
            return false;
        },
        hasMipmaps: function () {
            return false;
        },
        releaseData: function (data) {
            data = null;
        },
        keepData: function (data, length) {
            return data;
        },
        drawAtPoint: function (point) {
        },
        drawInRect: function (rect) {
        },
        initWithETCFile: function (file) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile);
            return false;
        },
        initWithPVRFile: function (file) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
            return false;
        },
        initWithPVRTCData: function (data, level, bpp, hasAlpha, length, pixelFormat) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
            return false;
        },
        setTexParameters: function (texParams) {
        },
        setAntiAliasTexParameters: function () {
        },
        setAliasTexParameters: function () {
        },
        generateMipmap: function () {
        },
        stringForFormat: function () {
            return "";
        },
        bitsPerPixelForFormat: function (format) {
            return -1;
        },
        addLoadedEventListener: function (callback, target) {
            this.addEventListener("load", callback, target);
        },
        removeLoadedEventListener: function (target) {
            this.removeEventListener("load", target);
        }
    });
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js");
    cc._tmp.WebGLTexture2D();
    delete cc._tmp.WebGLTexture2D;
}
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: (0 | Math.random() * 1000),
    _loadedTexturesBefore: {},
    _initializingRenderer: function () {
        var selPath;
        var locLoadedTexturesBefore = this._loadedTexturesBefore, locTextures = this._textures;
        for (selPath in locLoadedTexturesBefore) {
            var tex2d = locLoadedTexturesBefore[selPath];
            tex2d.handleLoadedTexture();
            locTextures[selPath] = tex2d;
        }
        this._loadedTexturesBefore = {};
    },
    addPVRTCImage: function (filename) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage);
    },
    addETCImage: function (filename) {
        cc.log(cc._LogInfos.textureCache_addETCImage);
    },
    description: function () {
        return "<TextureCache | Number of textures = " + this._textures.length + ">";
    },
    textureForKey: function (textureKeyName) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(textureKeyName);
    },
    getTextureForKey: function(textureKeyName){
        return this._textures[textureKeyName] || this._textures[cc.loader._aliases[textureKeyName]];
    },
    getKeyByTexture: function (texture) {
        for (var key in this._textures) {
            if (this._textures[key] == texture) {
                return key;
            }
        }
        return null;
    },
    _generalTextureKey: function () {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq;
    },
    getTextureColors: function (texture) {
        var key = this.getKeyByTexture(texture);
        if (!key) {
            if (texture instanceof HTMLImageElement)
                key = texture.src;
            else
                key = this._generalTextureKey();
        }
        if (!this._textureColorsCache[key])
            this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture);
        return this._textureColorsCache[key];
    },
    addPVRImage: function (path) {
        cc.log(cc._LogInfos.textureCache_addPVRImage);
    },
    removeAllTextures: function () {
        var locTextures = this._textures;
        for (var selKey in locTextures) {
            if (locTextures[selKey])
                locTextures[selKey].releaseTexture();
        }
        this._textures = {};
    },
    removeTexture: function (texture) {
        if (!texture)
            return;
        var locTextures = this._textures;
        for (var selKey in locTextures) {
            if (locTextures[selKey] == texture) {
                locTextures[selKey].releaseTexture();
                delete(locTextures[selKey]);
            }
        }
    },
    removeTextureForKey: function (textureKeyName) {
        if (textureKeyName == null)
            return;
        if (this._textures[textureKeyName])
            delete(this._textures[textureKeyName]);
    },
    cacheImage: function (path, texture) {
        if (texture instanceof  cc.Texture2D) {
            this._textures[path] = texture;
            return;
        }
        var texture2d = new cc.Texture2D();
        texture2d.initWithElement(texture);
        texture2d.handleLoadedTexture();
        this._textures[path] = texture2d;
    },
    addUIImage: function (image, key) {
        cc.assert(image, cc._LogInfos.textureCache_addUIImage_2);
        if (key) {
            if (this._textures[key])
                return this._textures[key];
        }
        var texture = new cc.Texture2D();
        texture.initWithImage(image);
        if ((key != null) && (texture != null))
            this._textures[key] = texture;
        else
            cc.log(cc._LogInfos.textureCache_addUIImage);
        return texture;
    },
    dumpCachedTextureInfo: function () {
        var count = 0;
        var totalBytes = 0, locTextures = this._textures;
        for (var key in locTextures) {
            var selTexture = locTextures[key];
            count++;
            if (selTexture.getHtmlElementObj() instanceof  HTMLImageElement)
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, key, selTexture.getHtmlElementObj().src, selTexture.pixelsWidth, selTexture.pixelsHeight);
            else {
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, key, selTexture.pixelsWidth, selTexture.pixelsHeight);
            }
            totalBytes += selTexture.pixelsWidth * selTexture.pixelsHeight * 4;
        }
        var locTextureColorsCache = this._textureColorsCache;
        for (key in locTextureColorsCache) {
            var selCanvasColorsArr = locTextureColorsCache[key];
            for (var selCanvasKey in selCanvasColorsArr) {
                var selCanvas = selCanvasColorsArr[selCanvasKey];
                count++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, key, selCanvas.width, selCanvas.height);
                totalBytes += selCanvas.width * selCanvas.height * 4;
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, count, totalBytes / 1024, (totalBytes / (1024.0 * 1024.0)).toFixed(2));
    },
    _clear: function () {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = (0 | Math.random() * 1000);
        this._loadedTexturesBefore = {};
    }
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.textureCache;
    _p.handleLoadedTexture = function (url) {
        var locTexs = this._textures;
        var tex = locTexs[url];
        if (!tex) {
            tex = locTexs[url] = new cc.Texture2D();
            tex.url = url;
        }
        tex.handleLoadedTexture();
    };
    _p.addImage = function (url, cb, target) {
        cc.assert(url, cc._LogInfos.Texture2D_addImage);
        var locTexs = this._textures;
        var tex = locTexs[url] || locTexs[cc.loader._aliases[url]];
        if (tex) {
            cb && cb.call(target, tex);
            return tex;
        }
        tex = locTexs[url] = new cc.Texture2D();
        tex.url = url;
        if (!cc.loader.getRes(url)) {
            if (cc.loader._checkIsImageURL(url)) {
                cc.loader.load(url, function (err) {
                    cb && cb.call(target);
                });
            } else {
                cc.loader.loadImg(url, function (err, img) {
                    if (err)
                        return cb ? cb(err) : err;
                    cc.loader.cache[url] = img;
                    cc.textureCache.handleLoadedTexture(url);
                    cb && cb.call(target, tex);
                });
            }
        }
        else {
            tex.handleLoadedTexture();
        }
        return tex;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js");
    cc._tmp.WebGLTextureCache();
    delete cc._tmp.WebGLTextureCache;
}
cc.Scene = cc.Node.extend({
    _className:"Scene",
    ctor:function () {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = true;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize());
    }
});
cc.Scene.create = function () {
    return new cc.Scene();
};
cc.LoaderScene = cc.Scene.extend({
    _interval : null,
    _label : null,
    _className:"LoaderScene",
    init : function(){
        var self = this;
        var logoWidth = 160;
        var logoHeight = 200;
        var bgLayer = self._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        bgLayer.setPosition(cc.visibleRect.bottomLeft);
        self.addChild(bgLayer, 0);
        var fontSize = 24, lblHeight =  -logoHeight / 2 + 100;
        if(cc._loaderImage){
            cc.loader.loadImg(cc._loaderImage, {isCrossOrigin : false }, function(err, img){
                logoWidth = img.width;
                logoHeight = img.height;
                self._initStage(img, cc.visibleRect.center);
            });
            fontSize = 14;
            lblHeight = -logoHeight / 2 - 10;
        }
        var label = self._label = new cc.LabelTTF("Loading... 0%", "Arial", fontSize);
        label.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, lblHeight)));
        label.setColor(cc.color(180, 180, 180));
        bgLayer.addChild(this._label, 10);
        return true;
    },
    _initStage: function (img, centerPos) {
        var self = this;
        var texture2d = self._texture2d = new cc.Texture2D();
        texture2d.initWithElement(img);
        texture2d.handleLoadedTexture();
        var logo = self._logo = new cc.Sprite(texture2d);
        logo.setScale(cc.contentScaleFactor());
        logo.x = centerPos.x;
        logo.y = centerPos.y;
        self._bgLayer.addChild(logo, 10);
    },
    onEnter: function () {
        var self = this;
        cc.Node.prototype.onEnter.call(self);
        self.schedule(self._startLoading, 0.3);
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        var tmpStr = "Loading... 0%";
        this._label.setString(tmpStr);
    },
    initWithResources: function (resources, cb) {
        if(cc.isString(resources))
            resources = [resources];
        this.resources = resources || [];
        this.cb = cb;
    },
    _startLoading: function () {
        var self = this;
        self.unschedule(self._startLoading);
        var res = self.resources;
        cc.loader.load(res,
            function (result, count, loadedCount) {
                var percent = (loadedCount / count * 100) | 0;
                percent = Math.min(percent, 100);
                self._label.setString("Loading... " + percent + "%");
            }, function () {
                if (self.cb)
                    self.cb();
            });
    }
});
cc.LoaderScene.preload = function(resources, cb){
    var _cc = cc;
    if(!_cc.loaderScene) {
        _cc.loaderScene = new cc.LoaderScene();
        _cc.loaderScene.init();
    }
    _cc.loaderScene.initWithResources(resources, cb);
    cc.director.runScene(_cc.loaderScene);
    return _cc.loaderScene;
};
cc._tmp.PrototypeLayerColor = function () {
    var _p = cc.LayerColor.prototype;
    cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
    cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
};
cc._tmp.PrototypeLayerGradient = function () {
    var _p = cc.LayerGradient.prototype;
    _p.startColor;
    cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
    _p.endColor;
    cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
    _p.startOpacity;
    cc.defineGetterSetter(_p, "startOpacity", _p.getStartOpacity, _p.setStartOpacity);
    _p.endOpacity;
    cc.defineGetterSetter(_p, "endOpacity", _p.getEndOpacity, _p.setEndOpacity);
    _p.vector;
    cc.defineGetterSetter(_p, "vector", _p.getVector, _p.setVector);
};
cc.Layer = cc.Node.extend({
    _isBaked: false,
    _bakeSprite: null,
    _bakeRenderCmd: null,
    _className: "Layer",
    ctor: function () {
        var nodep = cc.Node.prototype;
        nodep.ctor.call(this);
        this._ignoreAnchorPointForPosition = true;
        nodep.setAnchorPoint.call(this, 0.5, 0.5);
        nodep.setContentSize.call(this, cc.winSize);
    },
    init: function(){
        var _t = this;
        _t._ignoreAnchorPointForPosition = true;
        _t.setAnchorPoint(0.5, 0.5);
        _t.setContentSize(cc.winSize);
        _t.cascadeOpacity = false;
        _t.cascadeColor = false;
        return true;
    },
    bake: null,
    unbake: null,
    _bakeRendering: null,
    isBaked: function(){
        return this._isBaked;
    },
    visit: null
});
cc.Layer.create = function () {
    return new cc.Layer();
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function(){
        if (!this._isBaked) {
            cc.renderer.childrenOrderDirty = true;
            this._isBaked = this._cacheDirty = true;
            if(!this._bakeRenderCmd && this._bakeRendering)
                this._bakeRenderCmd = new cc.CustomRenderCmdCanvas(this, this._bakeRendering);
            this._cachedParent = this;
            var children = this._children;
            for(var i = 0, len = children.length; i < len; i++)
                children[i]._setCachedParent(this);
            if (!this._bakeSprite){
                this._bakeSprite = new cc.BakeSprite();
                this._bakeSprite._parent = this;
            }
        }
    };
    p.unbake = function(){
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = true;
            this._isBaked = false;
            this._cacheDirty = true;
            this._cachedParent = null;
            var children = this._children;
            for(var i = 0, len = children.length; i < len; i++)
                children[i]._setCachedParent(null);
        }
    };
    p.addChild = function(child, localZOrder, tag){
        cc.Node.prototype.addChild.call(this, child, localZOrder, tag);
        if(child._parent == this && this._isBaked)
            child._setCachedParent(this);
    };
    p._bakeRendering = function(){
        if(this._cacheDirty){
            var _t = this;
            var children = _t._children, locBakeSprite = this._bakeSprite;
            var boundingBox = this._getBoundingBoxForBake();
            boundingBox.width = 0 | boundingBox.width;
            boundingBox.height = 0 | boundingBox.height;
            var bakeContext = locBakeSprite.getCacheContext();
            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
            bakeContext.translate(0 - boundingBox.x, boundingBox.height + boundingBox.y);
            var t = cc.affineTransformInvert(this._transformWorld);
            var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
            bakeContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var anchor = locBakeSprite.getAnchorPointInPoints();
            locBakeSprite.setPosition(anchor.x + boundingBox.x, anchor.y + boundingBox.y);
            _t.sortAllChildren();
            cc.renderer._turnToCacheMode(this.__instanceId);
            for (var i = 0, len = children.length; i < len; i++) {
                children[i].visit(bakeContext);
            }
            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
            this._cacheDirty = false;
        }
    };
    p.visit = function(ctx){
        if(!this._isBaked){
            cc.Node.prototype.visit.call(this, ctx);
            return;
        }
        var context = ctx || cc._renderContext;
        var _t = this;
        var children = _t._children;
        var len = children.length;
        if (!_t._visible || len === 0)
            return;
        _t.transform(context);
        if(_t._bakeRenderCmd)
            cc.renderer.pushRenderCommand(_t._bakeRenderCmd);
        this._bakeSprite.visit(context);
    };
    p._getBoundingBoxForBake = function () {
        var rect = null;
        if (!this._children || this._children.length === 0)
            return cc.rect(0, 0, 10, 10);
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                if(rect){
                    var childRect = child._getBoundingBoxToCurrentNode();
                    if (childRect)
                        rect = cc.rectUnion(rect, childRect);
                }else{
                    rect = child._getBoundingBoxToCurrentNode();
                }
            }
        }
        return rect;
    };
    p = null;
}else{
    cc.assert(cc.isFunction(cc._tmp.LayerDefineForWebGL), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.LayerDefineForWebGL();
    delete cc._tmp.LayerDefineForWebGL;
}
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function () {
        return this._blendFunc;
    },
    changeWidthAndHeight: function (w, h) {
        this.width = w;
        this.height = h;
    },
    changeWidth: function (w) {
        this.width = w;
    },
    changeHeight: function (h) {
        this.height = h;
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    setColor: function (color) {
        cc.Layer.prototype.setColor.call(this, color);
        this._updateColor();
    },
    setOpacity: function (opacity) {
        cc.Layer.prototype.setOpacity.call(this, opacity);
        this._updateColor();
    },
    _blendFuncStr: "source",
    ctor: null,
    init: function (color, width, height) {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS)
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR);
        var winSize = cc.director.getWinSize();
        color = color || cc.color(0, 0, 0, 255);
        width = width === undefined ? winSize.width : width;
        height = height === undefined ? winSize.height : height;
        var locDisplayedColor = this._displayedColor;
        locDisplayedColor.r = color.r;
        locDisplayedColor.g = color.g;
        locDisplayedColor.b = color.b;
        var locRealColor = this._realColor;
        locRealColor.r = color.r;
        locRealColor.g = color.g;
        locRealColor.b = color.b;
        this._displayedOpacity = color.a;
        this._realOpacity = color.a;
        var proto = cc.LayerColor.prototype;
        proto.setContentSize.call(this, width, height);
        proto._updateColor.call(this);
        return true;
    },
    setBlendFunc: function (src, dst) {
        var _t = this, locBlendFunc = this._blendFunc;
        if (dst === undefined) {
            locBlendFunc.src = src.src;
            locBlendFunc.dst = src.dst;
        } else {
            locBlendFunc.src = src;
            locBlendFunc.dst = dst;
        }
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)
            _t._blendFuncStr = cc._getCompositeOperationByBlendFunc(locBlendFunc);
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function (parentColor) {
        cc.Layer.prototype.updateDisplayedColor.call(this, parentColor);
        this._updateColor();
    },
    updateDisplayedOpacity: function (parentOpacity) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._updateColor();
    },
    draw: null
});
cc.LayerColor.create = function (color, width, height) {
    return new cc.LayerColor(color, width, height);
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerColor.prototype;
    _p.ctor = function (color, width, height) {
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, color, width, height);
    };
    _p._initRendererCmd = function(){
        this._rendererCmd = new cc.RectRenderCmdCanvas(this);
    };
    _p._setWidth = function(width){
        cc.Node.prototype._setWidth.call(this, width);
    };
    _p._setHeight = function(height){
        cc.Node.prototype._setHeight.call(this, height);
    };
    _p._updateColor = function () {
        var locCmd = this._rendererCmd;
        if(!locCmd || !locCmd._color)
            return;
        var locColor = this._displayedColor;
        locCmd._color.r = locColor.r;
        locCmd._color.g = locColor.g;
        locCmd._color.b = locColor.b;
        locCmd._color.a = this._displayedOpacity / 255;
    };
    _p.draw = function (ctx) {
        var context = ctx || cc._renderContext, _t = this;
        var locEGLViewer = cc.view, locDisplayedColor = _t._displayedColor;
        context.fillStyle = "rgba(" + (0 | locDisplayedColor.r) + "," + (0 | locDisplayedColor.g) + ","
            + (0 | locDisplayedColor.b) + "," + _t._displayedOpacity / 255 + ")";
        context.fillRect(0, 0, _t.width * locEGLViewer.getScaleX(), -_t.height * locEGLViewer.getScaleY());
        cc.g_NumberOfDraws++;
    };
    _p._bakeRendering = function(){
        if(this._cacheDirty){
            var _t = this;
            var locBakeSprite = _t._bakeSprite, children = this._children;
            var len = children.length, i;
            var boundingBox = this._getBoundingBoxForBake();
            boundingBox.width = 0 | boundingBox.width;
            boundingBox.height = 0 | boundingBox.height;
            var bakeContext = locBakeSprite.getCacheContext();
            locBakeSprite.resetCanvasSize(boundingBox.width, boundingBox.height);
            var anchor = locBakeSprite.getAnchorPointInPoints(), locPos = this._position;
            if(this._ignoreAnchorPointForPosition){
                bakeContext.translate(0 - boundingBox.x + locPos.x, boundingBox.height + boundingBox.y - locPos.y);
                locBakeSprite.setPosition(anchor.x + boundingBox.x - locPos.x, anchor.y + boundingBox.y - locPos.y);
            } else {
                var selfAnchor = this.getAnchorPointInPoints();
                var selfPos = {x: locPos.x - selfAnchor.x, y: locPos.y - selfAnchor.y};
                bakeContext.translate(0 - boundingBox.x + selfPos.x, boundingBox.height + boundingBox.y - selfPos.y);
                locBakeSprite.setPosition(anchor.x + boundingBox.x - selfPos.x, anchor.y + boundingBox.y - selfPos.y);
            }
            var t = cc.affineTransformInvert(this._transformWorld);
            var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
            bakeContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var child;
            cc.renderer._turnToCacheMode(this.__instanceId);
            if (len > 0) {
                _t.sortAllChildren();
                for (i = 0; i < len; i++) {
                    child = children[i];
                    if (child._localZOrder < 0)
                        child.visit(bakeContext);
                    else
                        break;
                }
                if(_t._rendererCmd)
                    cc.renderer.pushRenderCommand(_t._rendererCmd);
                for (; i < len; i++) {
                    children[i].visit(bakeContext);
                }
            } else
            if(_t._rendererCmd)
                cc.renderer.pushRenderCommand(_t._rendererCmd);
            cc.renderer._renderingToCacheCanvas(bakeContext, this.__instanceId);
            this._cacheDirty = false;
        }
    };
    _p.visit = function(ctx){
        if(!this._isBaked){
            cc.Node.prototype.visit.call(this, ctx);
            return;
        }
        var context = ctx || cc._renderContext;
        var _t = this;
        if (!_t._visible)
            return;
        _t.transform(context);
        if(_t._bakeRenderCmd)
            cc.renderer.pushRenderCommand(_t._bakeRenderCmd);
        this._bakeSprite.visit(context);
    };
    _p._getBoundingBoxForBake = function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.nodeToWorldTransform();
        rect = cc.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        if (!this._children || this._children.length === 0)
            return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
            var child = locChildren[i];
            if (child && child._visible) {
                var childRect = child._getBoundingBoxToCurrentNode(trans);
                rect = cc.rectUnion(rect, childRect);
            }
        }
        return rect;
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerColor), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.WebGLLayerColor();
    delete cc._tmp.WebGLLayerColor;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerColor), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerColor();
delete cc._tmp.PrototypeLayerColor;
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: false,
    _className: "LayerGradient",
    ctor: function (start, end, v) {
        var _t = this;
        cc.LayerColor.prototype.ctor.call(_t);
        _t._endColor = cc.color(0, 0, 0, 255);
        _t._alongVector = cc.p(0, -1);
        _t._startOpacity = 255;
        _t._endOpacity = 255;
        cc.LayerGradient.prototype.init.call(_t, start, end, v);
    },
    _initRendererCmd: function(){
        this._rendererCmd = new cc.GradientRectRenderCmdCanvas(this);
    },
    init: function (start, end, v) {
        start = start || cc.color(0, 0, 0, 255);
        end = end || cc.color(0, 0, 0, 255);
        v = v || cc.p(0, -1);
        var _t = this;
        var locEndColor = _t._endColor;
        _t._startOpacity = start.a;
        locEndColor.r = end.r;
        locEndColor.g = end.g;
        locEndColor.b = end.b;
        _t._endOpacity = end.a;
        _t._alongVector = v;
        _t._compressedInterpolation = true;
        cc.LayerColor.prototype.init.call(_t, cc.color(start.r, start.g, start.b, 255));
        cc.LayerGradient.prototype._updateColor.call(_t);
        return true;
    },
    setContentSize: function (size, height) {
        cc.LayerColor.prototype.setContentSize.call(this, size, height);
        this._updateColor();
    },
    _setWidth: function (width) {
        cc.LayerColor.prototype._setWidth.call(this, width);
        this._updateColor();
    },
    _setHeight: function (height) {
        cc.LayerColor.prototype._setHeight.call(this, height);
        this._updateColor();
    },
    getStartColor: function () {
        return this._realColor;
    },
    setStartColor: function (color) {
        this.color = color;
    },
    setEndColor: function (color) {
        this._endColor = color;
        this._updateColor();
    },
    getEndColor: function () {
        return this._endColor;
    },
    setStartOpacity: function (o) {
        this._startOpacity = o;
        this._updateColor();
    },
    getStartOpacity: function () {
        return this._startOpacity;
    },
    setEndOpacity: function (o) {
        this._endOpacity = o;
        this._updateColor();
    },
    getEndOpacity: function () {
        return this._endOpacity;
    },
    setVector: function (Var) {
        this._alongVector.x = Var.x;
        this._alongVector.y = Var.y;
        this._updateColor();
    },
    getVector: function () {
        return cc.p(this._alongVector.x, this._alongVector.y);
    },
    isCompressedInterpolation: function () {
        return this._compressedInterpolation;
    },
    setCompressedInterpolation: function (compress) {
        this._compressedInterpolation = compress;
        this._updateColor();
    },
    _draw: null,
    _updateColor: null
});
cc.LayerGradient.create = function (start, end, v) {
    return new cc.LayerGradient(start, end, v);
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerGradient.prototype;
    _p._updateColor = function () {
        var _t = this;
        var locAlongVector = _t._alongVector, tWidth = _t.width * 0.5, tHeight = _t.height * 0.5;
        var locCmd = this._rendererCmd;
        locCmd._startPoint.x = tWidth * (-locAlongVector.x) + tWidth;
        locCmd._startPoint.y = tHeight * locAlongVector.y - tHeight;
        locCmd._endPoint.x = tWidth * locAlongVector.x + tWidth;
        locCmd._endPoint.y = tHeight * (-locAlongVector.y) - tHeight;
        var locStartColor = this._displayedColor, locEndColor = this._endColor, opacity = this._displayedOpacity / 255;
        var startOpacity = this._startOpacity, endOpacity = this._endOpacity;
        locCmd._startStopStr = "rgba(" + Math.round(locStartColor.r) + "," + Math.round(locStartColor.g) + ","
            + Math.round(locStartColor.b) + "," + startOpacity.toFixed(4) + ")";
        locCmd._endStopStr = "rgba(" + Math.round(locEndColor.r) + "," + Math.round(locEndColor.g) + ","
            + Math.round(locEndColor.b) + "," + endOpacity.toFixed(4) + ")";
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerGradient), cc._LogInfos.MissingFile, "CCLayerWebGL.js");
    cc._tmp.WebGLLayerGradient();
    delete cc._tmp.WebGLLayerGradient;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerGradient), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerGradient();
delete cc._tmp.PrototypeLayerGradient;
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function (layers) {
        cc.Layer.prototype.ctor.call(this);
        if (layers instanceof Array)
            cc.LayerMultiplex.prototype.initWithLayers.call(this, layers);
        else
            cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments));
    },
    initWithLayers: function (layers) {
        if ((layers.length > 0) && (layers[layers.length - 1] == null))
            cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = layers;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return true;
    },
    switchTo: function (n) {
        if (n >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchTo);
            return;
        }
        this.removeChild(this._layers[this._enabledLayer], true);
        this._enabledLayer = n;
        this.addChild(this._layers[n]);
    },
    switchToAndReleaseMe: function (n) {
        if (n >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe);
            return;
        }
        this.removeChild(this._layers[this._enabledLayer], true);
        this._layers[this._enabledLayer] = null;
        this._enabledLayer = n;
        this.addChild(this._layers[n]);
    },
    addLayer: function (layer) {
        if (!layer) {
            cc.log(cc._LogInfos.LayerMultiplex_addLayer);
            return;
        }
        this._layers.push(layer);
    }
});
cc.LayerMultiplex.create = function () {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments));
};
cc._tmp.PrototypeSprite = function () {
    var _p = cc.Sprite.prototype;
    cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    _p.dirty;
    _p.flippedX;
    cc.defineGetterSetter(_p, "flippedX", _p.isFlippedX, _p.setFlippedX);
    _p.flippedY;
    cc.defineGetterSetter(_p, "flippedY", _p.isFlippedY, _p.setFlippedY);
    _p.offsetX;
    cc.defineGetterSetter(_p, "offsetX", _p._getOffsetX);
    _p.offsetY;
    cc.defineGetterSetter(_p, "offsetY", _p._getOffsetY);
    _p.atlasIndex;
    _p.texture;
    cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
    _p.textureRectRotated;
    cc.defineGetterSetter(_p, "textureRectRotated", _p.isTextureRectRotated);
    _p.textureAtlas;
    _p.batchNode;
    cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
    _p.quad;
    cc.defineGetterSetter(_p, "quad", _p.getQuad);
};
cc.generateTintImageWithMultiply = function(image, color, rect, renderCanvas){
    renderCanvas = renderCanvas || cc.newElement("canvas");
    rect = rect || cc.rect(0,0, image.width, image.height);
    var context = renderCanvas.getContext( "2d" );
    if(renderCanvas.width != rect.width || renderCanvas.height != rect.height){
        renderCanvas.width = rect.width;
        renderCanvas.height = rect.height;
    }else{
        context.globalCompositeOperation = "source-over";
    }
    context.fillStyle = "rgb(" + (0|color.r) + "," + (0|color.g) + "," + (0|color.b) + ")";
    context.fillRect(0, 0, rect.width, rect.height);
    context.globalCompositeOperation = "multiply";
    context.drawImage(image,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(image,
        rect.x,
        rect.y,
        rect.width,
        rect.height,
        0,
        0,
        rect.width,
        rect.height);
    return renderCanvas;
};
cc.generateTintImage = function (texture, tintedImgCache, color, rect, renderCanvas) {
    if (!rect)
        rect = cc.rect(0, 0, texture.width, texture.height);
    var r = color.r / 255;
    var g = color.g / 255;
    var b = color.b / 255;
    var w = Math.min(rect.width, tintedImgCache[0].width);
    var h = Math.min(rect.height, tintedImgCache[0].height);
    var buff = renderCanvas;
    var ctx;
    if (!buff) {
        buff = cc.newElement("canvas");
        buff.width = w;
        buff.height = h;
        ctx = buff.getContext("2d");
    } else {
        ctx = buff.getContext("2d");
        ctx.clearRect(0, 0, w, h);
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    var a = ctx.globalAlpha;
    if (r > 0) {
        ctx.globalAlpha = r * a;
        ctx.drawImage(tintedImgCache[0], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (g > 0) {
        ctx.globalAlpha = g * a;
        ctx.drawImage(tintedImgCache[1], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (b > 0) {
        ctx.globalAlpha = b * a;
        ctx.drawImage(tintedImgCache[2], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    if (r + g + b < 1) {
        ctx.globalAlpha = a;
        ctx.drawImage(tintedImgCache[3], rect.x, rect.y, w, h, 0, 0, w, h);
    }
    ctx.restore();
    return buff;
};
cc.generateTextureCacheForColor = function (texture) {
    if (texture.channelCache) {
        return texture.channelCache;
    }
    var textureCache = [
        cc.newElement("canvas"),
        cc.newElement("canvas"),
        cc.newElement("canvas"),
        cc.newElement("canvas")
    ];
    function renderToCache() {
        var ref = cc.generateTextureCacheForColor;
        var w = texture.width;
        var h = texture.height;
        textureCache[0].width = w;
        textureCache[0].height = h;
        textureCache[1].width = w;
        textureCache[1].height = h;
        textureCache[2].width = w;
        textureCache[2].height = h;
        textureCache[3].width = w;
        textureCache[3].height = h;
        ref.canvas.width = w;
        ref.canvas.height = h;
        var ctx = ref.canvas.getContext("2d");
        ctx.drawImage(texture, 0, 0);
        ref.tempCanvas.width = w;
        ref.tempCanvas.height = h;
        var pixels = ctx.getImageData(0, 0, w, h).data;
        for (var rgbI = 0; rgbI < 4; rgbI++) {
            var cacheCtx = textureCache[rgbI].getContext('2d');
            cacheCtx.getImageData(0, 0, w, h).data;
            ref.tempCtx.drawImage(texture, 0, 0);
            var to = ref.tempCtx.getImageData(0, 0, w, h);
            var toData = to.data;
            for (var i = 0; i < pixels.length; i += 4) {
                toData[i  ] = (rgbI === 0) ? pixels[i  ] : 0;
                toData[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
                toData[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
                toData[i + 3] = pixels[i + 3];
            }
            cacheCtx.putImageData(to, 0, 0);
        }
        texture.onload = null;
    }
    try {
        renderToCache();
    } catch (e) {
        texture.onload = renderToCache;
    }
    texture.channelCache = textureCache;
    return textureCache;
};
cc.generateTextureCacheForColor.canvas = cc.newElement('canvas');
cc.generateTextureCacheForColor.tempCanvas = cc.newElement('canvas');
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext('2d');
cc.cutRotateImageToCanvas = function (texture, rect) {
    if (!texture)
        return null;
    if (!rect)
        return texture;
    var nCanvas = cc.newElement("canvas");
    nCanvas.width = rect.width;
    nCanvas.height = rect.height;
    var ctx = nCanvas.getContext("2d");
    ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
    ctx.rotate(-1.5707963267948966);
    ctx.drawImage(texture, rect.x, rect.y, rect.height, rect.width, -rect.height / 2, -rect.width / 2, rect.height, rect.width);
    return nCanvas;
};
cc._getCompositeOperationByBlendFunc = function(blendFunc){
    if(!blendFunc)
        return "source";
    else{
        if(( blendFunc.src == cc.SRC_ALPHA && blendFunc.dst == cc.ONE) || (blendFunc.src == cc.ONE && blendFunc.dst == cc.ONE))
            return "lighter";
        else if(blendFunc.src == cc.ZERO && blendFunc.dst == cc.SRC_ALPHA)
            return "destination-in";
        else if(blendFunc.src == cc.ZERO && blendFunc.dst == cc.ONE_MINUS_SRC_ALPHA)
            return "destination-out";
        else
            return "source";
    }
};
cc.Sprite = cc.Node.extend({
	dirty:false,
	atlasIndex:0,
    textureAtlas:null,
    _batchNode:null,
    _recursiveDirty:null,
    _hasChildren:null,
    _shouldBeHidden:false,
    _transformToBatch:null,
    _blendFunc:null,
    _texture:null,
    _rect:null,
    _rectRotated:false,
    _offsetPosition:null,
    _unflippedOffsetPositionFromCenter:null,
    _opacityModifyRGB:false,
    _flippedX:false,
    _flippedY:false,
    _textureLoaded:false,
    _newTextureWhenChangeColor: null,
    _className:"Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded:function(){
        return this._textureLoaded;
    },
    addLoadedEventListener:function(callback, target){
        this.addEventListener("load", callback, target);
    },
    isDirty:function () {
        return this.dirty;
    },
    setDirty:function (bDirty) {
        this.dirty = bDirty;
    },
    isTextureRectRotated:function () {
        return this._rectRotated;
    },
    getAtlasIndex:function () {
        return this.atlasIndex;
    },
    setAtlasIndex:function (atlasIndex) {
        this.atlasIndex = atlasIndex;
    },
    getTextureRect:function () {
        return cc.rect(this._rect);
    },
    getTextureAtlas:function () {
        return this.textureAtlas;
    },
    setTextureAtlas:function (textureAtlas) {
        this.textureAtlas = textureAtlas;
    },
    getOffsetPosition:function () {
        return cc.p(this._offsetPosition);
    },
	_getOffsetX: function () {
		return this._offsetPosition.x;
	},
	_getOffsetY: function () {
		return this._offsetPosition.y;
	},
    getBlendFunc:function () {
        return this._blendFunc;
    },
    initWithSpriteFrame:function (spriteFrame) {
        cc.assert(spriteFrame, cc._LogInfos.Sprite_initWithSpriteFrame);
        if(!spriteFrame.textureLoaded()){
            this._textureLoaded = false;
            spriteFrame.addEventListener("load", this._spriteFrameLoadedCallback, this);
        }
        var rotated = cc._renderType === cc._RENDER_TYPE_CANVAS ? false : spriteFrame._rotated;
        var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect(), rotated);
        this.setSpriteFrame(spriteFrame);
        return ret;
    },
    _spriteFrameLoadedCallback:null,
    initWithSpriteFrameName:function (spriteFrameName) {
        cc.assert(spriteFrameName, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var frame = cc.spriteFrameCache.getSpriteFrame(spriteFrameName);
        cc.assert(frame, spriteFrameName + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(frame);
    },
    useBatchNode:function (batchNode) {
        this.textureAtlas = batchNode.textureAtlas;
        this._batchNode = batchNode;
    },
    setVertexRect:function (rect) {
        var locRect = this._rect;
        locRect.x = rect.x;
        locRect.y = rect.y;
        locRect.width = rect.width;
        locRect.height = rect.height;
    },
    sortAllChildren:function () {
        if (this._reorderChildDirty) {
            var _children = this._children;
            var len = _children.length, i, j, tmp;
            for(i=1; i<len; i++){
                tmp = _children[i];
                j = i - 1;
                while(j >= 0){
                    if(tmp._localZOrder < _children[j]._localZOrder){
                        _children[j+1] = _children[j];
                    }else if(tmp._localZOrder === _children[j]._localZOrder && tmp.arrivalOrder < _children[j].arrivalOrder){
                        _children[j+1] = _children[j];
                    }else{
                        break;
                    }
                    j--;
                }
                _children[j+1] = tmp;
            }
            if (this._batchNode) {
                this._arrayMakeObjectsPerformSelector(_children, cc.Node._StateCallbackType.sortAllChildren);
            }
            this._reorderChildDirty = false;
        }
    },
    reorderChild:function (child, zOrder) {
        cc.assert(child, cc._LogInfos.Sprite_reorderChild_2);
        if(this._children.indexOf(child) === -1){
            cc.log(cc._LogInfos.Sprite_reorderChild);
            return;
        }
        if (zOrder === child.zIndex)
            return;
        if (this._batchNode && !this._reorderChildDirty) {
            this._setReorderChildDirtyRecursively();
            this._batchNode.reorderBatch(true);
        }
        cc.Node.prototype.reorderChild.call(this, child, zOrder);
    },
    removeChild:function (child, cleanup) {
        if (this._batchNode)
            this._batchNode.removeSpriteFromAtlas(child);
        cc.Node.prototype.removeChild.call(this, child, cleanup);
    },
    setVisible:function (visible) {
        cc.Node.prototype.setVisible.call(this, visible);
        this.setDirtyRecursively(true);
    },
    removeAllChildren:function (cleanup) {
        var locChildren = this._children, locBatchNode = this._batchNode;
        if (locBatchNode && locChildren != null) {
            for (var i = 0, len = locChildren.length; i < len; i++)
                locBatchNode.removeSpriteFromAtlas(locChildren[i]);
        }
        cc.Node.prototype.removeAllChildren.call(this, cleanup);
        this._hasChildren = false;
    },
	setDirtyRecursively:function (value) {
		this._recursiveDirty = value;
		this.dirty = value;
		var locChildren = this._children, child, l = locChildren ? locChildren.length : 0;
		for (var i = 0; i < l; i++) {
			child = locChildren[i];
			(child instanceof cc.Sprite) && child.setDirtyRecursively(true);
		}
	},
	setNodeDirty: function(norecursive) {
		cc.Node.prototype.setNodeDirty.call(this);
		if (!norecursive && this._batchNode && !this._recursiveDirty) {
			if (this._hasChildren)
				this.setDirtyRecursively(true);
			else {
				this._recursiveDirty = true;
				this.dirty = true;
			}
		}
	},
    ignoreAnchorPointForPosition:function (relative) {
        if(this._batchNode){
            cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition);
            return;
        }
        cc.Node.prototype.ignoreAnchorPointForPosition.call(this, relative);
    },
    setFlippedX:function (flippedX) {
        if (this._flippedX != flippedX) {
            this._flippedX = flippedX;
            this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
            this.setNodeDirty(true);
        }
    },
    setFlippedY:function (flippedY) {
        if (this._flippedY != flippedY) {
            this._flippedY = flippedY;
            this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
            this.setNodeDirty(true);
        }
    },
    isFlippedX:function () {
        return this._flippedX;
    },
    isFlippedY:function () {
        return this._flippedY;
    },
    setOpacityModifyRGB:null,
    isOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName:function (animationName, frameIndex) {
        cc.assert(animationName, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var cache = cc.animationCache.getAnimation(animationName);
        if(!cache){
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName);
            return;
        }
        var animFrame = cache.getFrames()[frameIndex];
        if(!animFrame){
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2);
            return;
        }
        this.setSpriteFrame(animFrame.getSpriteFrame());
    },
    getBatchNode:function () {
        return this._batchNode;
    },
    _setReorderChildDirtyRecursively:function () {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = true;
            var pNode = this._parent;
            while (pNode && pNode != this._batchNode) {
                pNode._setReorderChildDirtyRecursively();
                pNode = pNode.parent;
            }
        }
    },
    getTexture:function () {
        return this._texture;
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: false,
    _colorized: false,
    _blendFuncStr: "source",
    _originalTexture: null,
    _drawSize_Canvas: null,
    ctor: null,
	_softInit: function (fileName, rect, rotated) {
		if (fileName === undefined)
			cc.Sprite.prototype.init.call(this);
		else if (cc.isString(fileName)) {
			if (fileName[0] === "#") {
				var frameName = fileName.substr(1, fileName.length - 1);
				var spriteFrame = cc.spriteFrameCache.getSpriteFrame(frameName);
				this.initWithSpriteFrame(spriteFrame);
			} else {
				cc.Sprite.prototype.init.call(this, fileName, rect);
			}
		} else if (cc.isObject(fileName)) {
			if (fileName instanceof cc.Texture2D) {
				this.initWithTexture(fileName, rect, rotated);
			} else if (fileName instanceof cc.SpriteFrame) {
				this.initWithSpriteFrame(fileName);
			} else if ((fileName instanceof HTMLImageElement) || (fileName instanceof HTMLCanvasElement)) {
				var texture2d = new cc.Texture2D();
				texture2d.initWithElement(fileName);
				texture2d.handleLoadedTexture();
				this.initWithTexture(texture2d);
			}
		}
	},
    getQuad:function () {
        return this._quad;
    },
    setBlendFunc: null,
    init:null,
    initWithFile:function (filename, rect) {
        cc.assert(filename, cc._LogInfos.Sprite_initWithFile);
        var tex = cc.textureCache.getTextureForKey(filename);
        if (!tex) {
            tex = cc.textureCache.addImage(filename);
            return this.initWithTexture(tex, rect || cc.rect(0, 0, tex._contentSize.width, tex._contentSize.height));
        } else {
            if (!rect) {
                var size = tex.getContentSize();
                rect = cc.rect(0, 0, size.width, size.height);
            }
            return this.initWithTexture(tex, rect);
        }
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect:null,
    updateTransform: null,
    addChild: null,
    updateColor:function () {
        var locDisplayedColor = this._displayedColor, locDisplayedOpacity = this._displayedOpacity;
        var color4 = {r: locDisplayedColor.r, g: locDisplayedColor.g, b: locDisplayedColor.b, a: locDisplayedOpacity};
        if (this._opacityModifyRGB) {
            color4.r *= locDisplayedOpacity / 255.0;
            color4.g *= locDisplayedOpacity / 255.0;
            color4.b *= locDisplayedOpacity / 255.0;
        }
        var locQuad = this._quad;
        locQuad.bl.colors = color4;
        locQuad.br.colors = color4;
        locQuad.tl.colors = color4;
        locQuad.tr.colors = color4;
        if (this._batchNode) {
            if (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED) {
                this.textureAtlas.updateQuad(locQuad, this.atlasIndex)
            } else {
                this.dirty = true;
            }
        }
        this._quadDirty = true;
    },
    setOpacity:null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(newFrame){
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(newFrame);
    },
    isFrameDisplayed: null,
    displayFrame: function () {
        return new cc.SpriteFrame(this._texture,
                                  cc.rectPointsToPixels(this._rect),
                                  this._rectRotated,
                                  cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter),
                                  cc.sizePointsToPixels(this._contentSize));
    },
    setBatchNode:null,
    setTexture: null,
    _updateBlendFunc:function () {
        if(this._batchNode){
            cc.log(cc._LogInfos.Sprite__updateBlendFunc);
            return;
        }
        if (!this._texture || !this._texture.hasPremultipliedAlpha()) {
            this._blendFunc.src = cc.SRC_ALPHA;
            this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA;
            this.opacityModifyRGB = false;
        } else {
            this._blendFunc.src = cc.BLEND_SRC;
            this._blendFunc.dst = cc.BLEND_DST;
            this.opacityModifyRGB = true;
        }
    },
    _changeTextureColor: function () {
        var locElement, locTexture = this._texture, locRect = this._rendererCmd._textureCoord;
        if (locTexture && locRect.validRect && this._originalTexture) {
            locElement = locTexture.getHtmlElementObj();
            if (!locElement)
                return;
            this._colorized = true;
            if (locElement instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor
                && this._originalTexture._htmlElementObj != locElement)
                cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, locRect, locElement);
            else {
                locElement = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, locRect);
                locTexture = new cc.Texture2D();
                locTexture.initWithElement(locElement);
                locTexture.handleLoadedTexture();
                this.texture = locTexture;
            }
        }
    },
    _setTextureCoords:function (rect) {
        rect = cc.rectPointsToPixels(rect);
        var tex = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!tex)
            return;
        var atlasWidth = tex.pixelsWidth;
        var atlasHeight = tex.pixelsHeight;
        var left, right, top, bottom, tempSwap, locQuad = this._quad;
        if (this._rectRotated) {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.height * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.width * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.height) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.width) / atlasHeight;
            }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
            if (this._flippedX) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = top;
            locQuad.br.texCoords.u = left;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = right;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = bottom;
        } else {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.width * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.height * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.width) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.height) / atlasHeight;
            }
            if (this._flippedX) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = bottom;
            locQuad.br.texCoords.u = right;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = left;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = top;
        }
        this._quadDirty = true;
    }
});
cc.Sprite.create = function (fileName, rect, rotated) {
    return new cc.Sprite(fileName, rect, rotated);
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Sprite.prototype;
    _p._spriteFrameLoadedCallback = function(spriteFrame){
        var _t = this;
        _t.setNodeDirty(true);
        _t.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
        var curColor = _t.color;
        if (curColor.r !== 255 || curColor.g !== 255 || curColor.b !== 255)
            _t._changeTextureColor();
        _t.dispatchEvent("load");
    };
    _p.setOpacityModifyRGB = function (modify) {
        if (this._opacityModifyRGB !== modify) {
            this._opacityModifyRGB = modify;
            this.setNodeDirty(true);
        }
    };
    _p.updateDisplayedOpacity = function (parentOpacity) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._setNodeDirtyForCache();
    };
    _p.ctor = function (fileName, rect, rotated) {
        var self = this;
        cc.Node.prototype.ctor.call(self);
        self._shouldBeHidden = false;
        self._offsetPosition = cc.p(0, 0);
        self._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        self._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        self._rect = cc.rect(0, 0, 0, 0);
        self._newTextureWhenChangeColor = false;
        self._textureLoaded = true;
        self._drawSize_Canvas = cc.size(0, 0);
        self._softInit(fileName, rect, rotated);
    };
    _p._initRendererCmd = function(){
        this._rendererCmd = new cc.TextureRenderCmdCanvas(this);
    };
    _p.setBlendFunc = function (src, dst) {
        var _t = this, locBlendFunc = this._blendFunc;
        if (dst === undefined) {
            locBlendFunc.src = src.src;
            locBlendFunc.dst = src.dst;
        } else {
            locBlendFunc.src = src;
            locBlendFunc.dst = dst;
        }
        if (cc._renderType === cc._RENDER_TYPE_CANVAS)
            _t._blendFuncStr = cc._getCompositeOperationByBlendFunc(locBlendFunc);
    };
    _p.init = function () {
        var _t = this;
        if (arguments.length > 0)
            return _t.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(_t);
        _t.dirty = _t._recursiveDirty = false;
        _t._blendFunc.src = cc.BLEND_SRC;
        _t._blendFunc.dst = cc.BLEND_DST;
        _t.texture = null;
        _t._textureLoaded = true;
        _t._flippedX = _t._flippedY = false;
        _t.anchorX = 0.5;
        _t.anchorY = 0.5;
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        _t._hasChildren = false;
        _t.setTextureRect(cc.rect(0, 0, 0, 0), false, cc.size(0, 0));
        return true;
    };
    _p.initWithTexture = function (texture, rect, rotated) {
        var _t = this;
        cc.assert(arguments.length != 0, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        rotated = rotated || false;
        if (rotated && texture.isLoaded()) {
            var tempElement = texture.getHtmlElementObj();
            tempElement = cc.cutRotateImageToCanvas(tempElement, rect);
            var tempTexture = new cc.Texture2D();
            tempTexture.initWithElement(tempElement);
            tempTexture.handleLoadedTexture();
            texture = tempTexture;
            _t._rect = cc.rect(0, 0, rect.width, rect.height);
        }
        if (!cc.Node.prototype.init.call(_t))
            return false;
        _t._batchNode = null;
        _t._recursiveDirty = false;
        _t.dirty = false;
        _t._opacityModifyRGB = true;
        _t._blendFunc.src = cc.BLEND_SRC;
        _t._blendFunc.dst = cc.BLEND_DST;
        _t._flippedX = _t._flippedY = false;
        _t.anchorX = 0.5;
        _t.anchorY = 0.5;
        _t._offsetPosition.x = 0;
        _t._offsetPosition.y = 0;
        _t._hasChildren = false;
        var locTextureLoaded = texture.isLoaded();
        _t._textureLoaded = locTextureLoaded;
        if (!locTextureLoaded) {
            _t._rectRotated = rotated;
            if (rect) {
                _t._rect.x = rect.x;
                _t._rect.y = rect.y;
                _t._rect.width = rect.width;
                _t._rect.height = rect.height;
            }
            if(_t.texture)
                _t.texture.removeEventListener("load", _t);
            texture.addEventListener("load", _t._textureLoadedCallback, _t);
            _t.texture = texture;
            return true;
        }
        if (!rect) {
            rect = cc.rect(0, 0, texture.width, texture.height);
        }
        if(texture && texture.url) {
            var _x = rect.x + rect.width, _y = rect.y + rect.height;
            if(_x > texture.width){
                cc.error(cc._LogInfos.RectWidth, texture.url);
            }
            if(_y > texture.height){
                cc.error(cc._LogInfos.RectHeight, texture.url);
            }
        }
        _t._originalTexture = texture;
        _t.texture = texture;
        _t.setTextureRect(rect, rotated);
        _t.batchNode = null;
        return true;
    };
    _p._textureLoadedCallback = function (sender) {
        var _t = this;
        if(_t._textureLoaded)
            return;
        _t._textureLoaded = true;
        var locRect = _t._rect;
        if (!locRect) {
            locRect = cc.rect(0, 0, sender.width, sender.height);
        } else if (cc._rectEqualToZero(locRect)) {
            locRect.width = sender.width;
            locRect.height = sender.height;
        }
        _t._originalTexture = sender;
        _t.texture = sender;
        _t.setTextureRect(locRect, _t._rectRotated);
        var locColor = this._displayedColor;
        if(locColor.r != 255 || locColor.g != 255 || locColor.b != 255)
            _t._changeTextureColor();
        _t.batchNode = _t._batchNode;
        _t.dispatchEvent("load");
    };
    _p.setTextureRect = function (rect, rotated, untrimmedSize) {
        var _t = this;
        _t._rectRotated = rotated || false;
        _t.setContentSize(untrimmedSize || rect);
        _t.setVertexRect(rect);
        var locTextureRect = _t._rendererCmd._textureCoord,
            scaleFactor = cc.contentScaleFactor();
        locTextureRect.renderX = locTextureRect.x = 0 | (rect.x * scaleFactor);
        locTextureRect.renderY = locTextureRect.y = 0 | (rect.y * scaleFactor);
        locTextureRect.width = 0 | (rect.width * scaleFactor);
        locTextureRect.height = 0 | (rect.height * scaleFactor);
        locTextureRect.validRect = !(locTextureRect.width === 0 || locTextureRect.height === 0 || locTextureRect.x < 0 || locTextureRect.y < 0);
        var relativeOffset = _t._unflippedOffsetPositionFromCenter;
        if (_t._flippedX)
            relativeOffset.x = -relativeOffset.x;
        if (_t._flippedY)
            relativeOffset.y = -relativeOffset.y;
        _t._offsetPosition.x = relativeOffset.x + (_t._contentSize.width - _t._rect.width) / 2;
        _t._offsetPosition.y = relativeOffset.y + (_t._contentSize.height - _t._rect.height) / 2;
        if (_t._batchNode) {
            _t.dirty = true;
        }
    };
    _p.updateTransform = function () {
        var _t = this;
        if (_t.dirty) {
            var locParent = _t._parent;
            if (!_t._visible || ( locParent && locParent != _t._batchNode && locParent._shouldBeHidden)) {
                _t._shouldBeHidden = true;
            } else {
                _t._shouldBeHidden = false;
                if (!locParent || locParent == _t._batchNode) {
                    _t._transformToBatch = _t.nodeToParentTransform();
                } else {
                    _t._transformToBatch = cc.affineTransformConcat(_t.nodeToParentTransform(), locParent._transformToBatch);
                }
            }
            _t._recursiveDirty = false;
            _t.dirty = false;
        }
        if (_t._hasChildren)
            _t._arrayMakeObjectsPerformSelector(_t._children, cc.Node._StateCallbackType.updateTransform);
    };
    _p.addChild = function (child, localZOrder, tag) {
        cc.assert(child, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        if (localZOrder == null)
            localZOrder = child._localZOrder;
        if (tag == null)
            tag = child.tag;
        cc.Node.prototype.addChild.call(this, child, localZOrder, tag);
        this._hasChildren = true;
    };
    _p.setOpacity = function (opacity) {
        cc.Node.prototype.setOpacity.call(this, opacity);
        this._setNodeDirtyForCache();
    };
    _p.setColor = function (color3) {
        var _t = this;
        var curColor = _t.color;
        this._oldDisplayColor = curColor;
        if ((curColor.r === color3.r) && (curColor.g === color3.g) && (curColor.b === color3.b))
            return;
        cc.Node.prototype.setColor.call(_t, color3);
    };
    _p.updateDisplayedColor = function (parentColor) {
        var _t = this;
        cc.Node.prototype.updateDisplayedColor.call(_t, parentColor);
        var oColor = _t._oldDisplayColor;
        var nColor = _t._displayedColor;
        if (oColor.r === nColor.r && oColor.g === nColor.g && oColor.b === nColor.b)
            return;
        _t._changeTextureColor();
        _t._setNodeDirtyForCache();
    };
    _p.setSpriteFrame = function (newFrame) {
        var _t = this;
        if(cc.isString(newFrame)){
            newFrame = cc.spriteFrameCache.getSpriteFrame(newFrame);
            cc.assert(newFrame, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame)
        }
        _t.setNodeDirty(true);
        var frameOffset = newFrame.getOffset();
        _t._unflippedOffsetPositionFromCenter.x = frameOffset.x;
        _t._unflippedOffsetPositionFromCenter.y = frameOffset.y;
        _t._rectRotated = newFrame.isRotated();
        var pNewTexture = newFrame.getTexture();
        var locTextureLoaded = newFrame.textureLoaded();
        if (!locTextureLoaded) {
            _t._textureLoaded = false;
            newFrame.addEventListener("load", function (sender) {
                _t._textureLoaded = true;
                var locNewTexture = sender.getTexture();
                if (locNewTexture != _t._texture)
                    _t.texture = locNewTexture;
                _t.setTextureRect(sender.getRect(), sender.isRotated(), sender.getOriginalSize());
                _t.dispatchEvent("load");
            }, _t);
        }
        if (pNewTexture != _t._texture)
            _t.texture = pNewTexture;
        if (_t._rectRotated)
            _t._originalTexture = pNewTexture;
        _t.setTextureRect(newFrame.getRect(), _t._rectRotated, newFrame.getOriginalSize());
        _t._colorized = false;
        _t._rendererCmd._textureCoord.renderX = _t._rendererCmd._textureCoord.x;
        _t._rendererCmd._textureCoord.renderY = _t._rendererCmd._textureCoord.y;
        if (locTextureLoaded) {
            var curColor = _t.color;
            if (curColor.r !== 255 || curColor.g !== 255 || curColor.b !== 255)
                _t._changeTextureColor();
        }
    };
    _p.isFrameDisplayed = function (frame) {
        if (frame.getTexture() != this._texture)
            return false;
        return cc.rectEqualToRect(frame.getRect(), this._rect);
    };
    _p.setBatchNode = function (spriteBatchNode) {
        var _t = this;
        _t._batchNode = spriteBatchNode;
        if (!_t._batchNode) {
            _t.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED;
            _t.textureAtlas = null;
            _t._recursiveDirty = false;
            _t.dirty = false;
        } else {
            _t._transformToBatch = cc.affineTransformIdentity();
            _t.textureAtlas = _t._batchNode.textureAtlas;
        }
    };
    _p.setTexture = function (texture) {
        var _t = this;
        if(texture && (cc.isString(texture))){
            texture = cc.textureCache.addImage(texture);
            _t.setTexture(texture);
            var size = texture.getContentSize();
            _t.setTextureRect(cc.rect(0,0, size.width, size.height));
            if(!texture._isLoaded){
                texture.addEventListener("load", function(){
                    var size = texture.getContentSize();
                    _t.setTextureRect(cc.rect(0,0, size.width, size.height));
                }, this);
            }
            return;
        }
        cc.assert(!texture || texture instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture);
        if (_t._texture != texture) {
            if (texture && texture.getHtmlElementObj() instanceof  HTMLImageElement) {
                _t._originalTexture = texture;
            }
            _t._texture = texture;
        }
    };
    if(!cc.sys._supportCanvasNewBlendModes)
        _p._changeTextureColor =  function () {
            var locElement, locTexture = this._texture, locRect = this._rendererCmd._textureCoord;
            if (locTexture && locRect.validRect && this._originalTexture) {
                locElement = locTexture.getHtmlElementObj();
                if (!locElement)
                    return;
                var cacheTextureForColor = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
                if (cacheTextureForColor) {
                    this._colorized = true;
                    if (locElement instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor)
                        cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor, locRect, locElement);
                    else {
                        locElement = cc.generateTintImage(locElement, cacheTextureForColor, this._displayedColor, locRect);
                        locTexture = new cc.Texture2D();
                        locTexture.initWithElement(locElement);
                        locTexture.handleLoadedTexture();
                        this.texture = locTexture;
                    }
                }
            }
        };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLSprite), cc._LogInfos.MissingFile, "SpritesWebGL.js");
    cc._tmp.WebGLSprite();
    delete cc._tmp.WebGLSprite;
}
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function(){
        cc.Sprite.prototype.ctor.call(this);
        var canvasElement = document.createElement("canvas");
        canvasElement.width = canvasElement.height = 10;
        this._cacheCanvas = canvasElement;
        this._cacheContext = canvasElement.getContext("2d");
        var texture = new cc.Texture2D();
        texture.initWithElement(canvasElement);
        texture.handleLoadedTexture();
        this.setTexture(texture);
    },
    getCacheContext: function(){
        return this._cacheContext;
    },
    getCacheCanvas: function(){
        return this._cacheCanvas;
    },
    resetCanvasSize: function(sizeOrWidth, height){
        if(height === undefined){
            height = sizeOrWidth.height;
            sizeOrWidth = sizeOrWidth.width;
        }
        var locCanvas = this._cacheCanvas;
        locCanvas.width = sizeOrWidth;
        locCanvas.height = height;
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0,0, sizeOrWidth, height), false);
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame:null,
    _delayPerUnit:0,
    _userInfo:null,
    ctor:function (spriteFrame, delayUnits, userInfo) {
        this._spriteFrame = spriteFrame || null;
        this._delayPerUnit = delayUnits || 0;
        this._userInfo = userInfo || null;
    },
    clone: function(){
        var frame = new cc.AnimationFrame();
        frame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return frame;
    },
    copyWithZone:function (pZone) {
        return cc.clone(this);
    },
    copy:function (pZone) {
        var newFrame = new cc.AnimationFrame();
        newFrame.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return newFrame;
    },
    initWithSpriteFrame:function (spriteFrame, delayUnits, userInfo) {
        this._spriteFrame = spriteFrame;
        this._delayPerUnit = delayUnits;
        this._userInfo = userInfo;
        return true;
    },
    getSpriteFrame:function () {
        return this._spriteFrame;
    },
    setSpriteFrame:function (spriteFrame) {
        this._spriteFrame = spriteFrame;
    },
    getDelayUnits:function () {
        return this._delayPerUnit;
    },
    setDelayUnits:function (delayUnits) {
        this._delayPerUnit = delayUnits;
    },
    getUserInfo:function () {
        return this._userInfo;
    },
    setUserInfo:function (userInfo) {
        this._userInfo = userInfo;
    }
});
cc.AnimationFrame.create = function(spriteFrame,delayUnits,userInfo){
    return new cc.AnimationFrame(spriteFrame,delayUnits,userInfo);
};
cc.Animation = cc.Class.extend({
    _frames:null,
    _loops:0,
    _restoreOriginalFrame:false,
    _duration:0,
    _delayPerUnit:0,
    _totalDelayUnits:0,
    ctor:function (frames, delay, loops) {
        this._frames = [];
		if (frames === undefined) {
			this.initWithSpriteFrames(null, 0);
		} else {
			var frame0 = frames[0];
			if(frame0){
				if (frame0 instanceof cc.SpriteFrame) {
					this.initWithSpriteFrames(frames, delay, loops);
				}else if(frame0 instanceof cc.AnimationFrame) {
					this.initWithAnimationFrames(frames, delay, loops);
				}
			}
		}
    },
    getFrames:function () {
        return this._frames;
    },
    setFrames:function (frames) {
        this._frames = frames;
    },
    addSpriteFrame:function (frame) {
        var animFrame = new cc.AnimationFrame();
        animFrame.initWithSpriteFrame(frame, 1, null);
        this._frames.push(animFrame);
        this._totalDelayUnits++;
    },
    addSpriteFrameWithFile:function (fileName) {
        var texture = cc.textureCache.addImage(fileName);
        var rect = cc.rect(0, 0, 0, 0);
        rect.width = texture.width;
        rect.height = texture.height;
        var frame = new cc.SpriteFrame(texture, rect);
        this.addSpriteFrame(frame);
    },
    addSpriteFrameWithTexture:function (texture, rect) {
        var pFrame = new cc.SpriteFrame(texture, rect);
        this.addSpriteFrame(pFrame);
    },
    initWithAnimationFrames:function (arrayOfAnimationFrames, delayPerUnit, loops) {
        cc.arrayVerifyType(arrayOfAnimationFrames, cc.AnimationFrame);
        this._delayPerUnit = delayPerUnit;
        this._loops = loops === undefined ? 1 : loops;
        this._totalDelayUnits = 0;
        var locFrames = this._frames;
        locFrames.length = 0;
        for (var i = 0; i < arrayOfAnimationFrames.length; i++) {
            var animFrame = arrayOfAnimationFrames[i];
            locFrames.push(animFrame);
            this._totalDelayUnits += animFrame.getDelayUnits();
        }
        return true;
    },
    clone: function(){
        var animation = new cc.Animation();
        animation.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        animation.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return animation;
    },
    copyWithZone:function (pZone) {
        var pCopy = new cc.Animation();
        pCopy.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        pCopy.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return pCopy;
    },
    _copyFrames:function(){
       var copyFrames = [];
        for(var i = 0; i< this._frames.length;i++)
            copyFrames.push(this._frames[i].clone());
        return copyFrames;
    },
    copy:function (pZone) {
        return this.copyWithZone(null);
    },
    getLoops:function () {
        return this._loops;
    },
    setLoops:function (value) {
        this._loops = value;
    },
    setRestoreOriginalFrame:function (restOrigFrame) {
        this._restoreOriginalFrame = restOrigFrame;
    },
    getRestoreOriginalFrame:function () {
        return this._restoreOriginalFrame;
    },
    getDuration:function () {
        return this._totalDelayUnits * this._delayPerUnit;
    },
    getDelayPerUnit:function () {
        return this._delayPerUnit;
    },
    setDelayPerUnit:function (delayPerUnit) {
        this._delayPerUnit = delayPerUnit;
    },
    getTotalDelayUnits:function () {
        return this._totalDelayUnits;
    },
    initWithSpriteFrames:function (frames, delay, loops) {
        cc.arrayVerifyType(frames, cc.SpriteFrame);
        this._loops = loops === undefined ? 1 : loops;
        this._delayPerUnit = delay || 0;
        this._totalDelayUnits = 0;
        var locFrames = this._frames;
        locFrames.length = 0;
        if (frames) {
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(frame, 1, null);
                locFrames.push(animFrame);
            }
            this._totalDelayUnits += frames.length;
        }
        return true;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.Animation.create = function (frames, delay, loops) {
    return new cc.Animation(frames, delay, loops);
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
	_animations: {},
    addAnimation:function (animation, name) {
        this._animations[name] = animation;
    },
    removeAnimation:function (name) {
        if (!name) {
            return;
        }
        if (this._animations[name]) {
            delete this._animations[name];
        }
    },
    getAnimation:function (name) {
        if (this._animations[name])
            return this._animations[name];
        return null;
    },
    _addAnimationsWithDictionary:function (dictionary,plist) {
        var animations = dictionary["animations"];
        if (!animations) {
            cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary);
            return;
        }
        var version = 1;
        var properties = dictionary["properties"];
        if (properties) {
            version = (properties["format"] != null) ? parseInt(properties["format"]) : version;
            var spritesheets = properties["spritesheets"];
            var spriteFrameCache = cc.spriteFrameCache;
            var path = cc.path;
            for (var i = 0; i < spritesheets.length; i++) {
                spriteFrameCache.addSpriteFrames(path.changeBasename(plist, spritesheets[i]));
            }
        }
        switch (version) {
            case 1:
                this._parseVersion1(animations);
                break;
            case 2:
                this._parseVersion2(animations);
                break;
            default :
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2);
                break;
        }
    },
    addAnimations:function (plist) {
        cc.assert(plist, cc._LogInfos.animationCache_addAnimations_2);
        var dict = cc.loader.getRes(plist);
        if(!dict){
            cc.log(cc._LogInfos.animationCache_addAnimations);
            return;
        }
        this._addAnimationsWithDictionary(dict,plist);
    },
    _parseVersion1:function (animations) {
        var frameCache = cc.spriteFrameCache;
        for (var key in animations) {
            var animationDict = animations[key];
            var frameNames = animationDict["frames"];
            var delay = parseFloat(animationDict["delay"]) || 0;
            var animation = null;
            if (!frameNames) {
                cc.log(cc._LogInfos.animationCache__parseVersion1, key);
                continue;
            }
            var frames = [];
            for (var i = 0; i < frameNames.length; i++) {
                var spriteFrame = frameCache.getSpriteFrame(frameNames[i]);
                if (!spriteFrame) {
                    cc.log(cc._LogInfos.animationCache__parseVersion1_2, key, frameNames[i]);
                    continue;
                }
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, 1, null);
                frames.push(animFrame);
            }
            if (frames.length === 0) {
                cc.log(cc._LogInfos.animationCache__parseVersion1_3, key);
                continue;
            } else if (frames.length != frameNames.length) {
                cc.log(cc._LogInfos.animationCache__parseVersion1_4, key);
            }
            animation = new cc.Animation(frames, delay, 1);
            cc.animationCache.addAnimation(animation, key);
        }
    },
    _parseVersion2:function (animations) {
        var frameCache = cc.spriteFrameCache;
        for (var key in animations) {
            var animationDict = animations[key];
            var isLoop = animationDict["loop"];
            var loopsTemp = parseInt(animationDict["loops"]);
            var loops = isLoop ? cc.REPEAT_FOREVER : ((isNaN(loopsTemp)) ? 1 : loopsTemp);
            var restoreOriginalFrame = (animationDict["restoreOriginalFrame"] && animationDict["restoreOriginalFrame"] == true) ? true : false;
            var frameArray = animationDict["frames"];
            if (!frameArray) {
                cc.log(cc._LogInfos.animationCache__parseVersion2, key);
                continue;
            }
            var arr = [];
            for (var i = 0; i < frameArray.length; i++) {
                var entry = frameArray[i];
                var spriteFrameName = entry["spriteframe"];
                var spriteFrame = frameCache.getSpriteFrame(spriteFrameName);
                if (!spriteFrame) {
                    cc.log(cc._LogInfos.animationCache__parseVersion2_2, key, spriteFrameName);
                    continue;
                }
                var delayUnits = parseFloat(entry["delayUnits"]) || 0;
                var userInfo = entry["notification"];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, delayUnits, userInfo);
                arr.push(animFrame);
            }
            var delayPerUnit = parseFloat(animationDict["delayPerUnit"]) || 0;
            var animation = new cc.Animation();
            animation.initWithAnimationFrames(arr, delayPerUnit, loops);
            animation.setRestoreOriginalFrame(restoreOriginalFrame);
            cc.animationCache.addAnimation(animation, key);
        }
    },
	_clear: function () {
		this._animations = {};
	}
};
cc.SpriteFrame = cc.Class.extend({
    _offset:null,
    _originalSize:null,
    _rectInPixels:null,
    _rotated:false,
    _rect:null,
    _offsetInPixels:null,
    _originalSizeInPixels:null,
    _texture:null,
    _textureFilename:"",
    _textureLoaded:false,
    ctor:function (filename, rect, rotated, offset, originalSize) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = false;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = false;
        if(filename !== undefined && rect !== undefined ){
            if(rotated === undefined || offset === undefined || originalSize === undefined)
                this.initWithTexture(filename, rect);
            else
                this.initWithTexture(filename, rect, rotated, offset, originalSize)
        }
    },
    textureLoaded:function(){
        return this._textureLoaded;
    },
    addLoadedEventListener:function(callback, target){
        this.addEventListener("load", callback, target);
    },
    getRectInPixels:function () {
        var locRectInPixels = this._rectInPixels;
        return cc.rect(locRectInPixels.x, locRectInPixels.y, locRectInPixels.width, locRectInPixels.height);
    },
    setRectInPixels:function (rectInPixels) {
        if (!this._rectInPixels){
            this._rectInPixels = cc.rect(0,0,0,0);
        }
        this._rectInPixels.x = rectInPixels.x;
        this._rectInPixels.y = rectInPixels.y;
        this._rectInPixels.width = rectInPixels.width;
        this._rectInPixels.height = rectInPixels.height;
        this._rect = cc.rectPixelsToPoints(rectInPixels);
    },
    isRotated:function () {
        return this._rotated;
    },
    setRotated:function (bRotated) {
        this._rotated = bRotated;
    },
    getRect:function () {
        var locRect = this._rect;
        return cc.rect(locRect.x, locRect.y, locRect.width, locRect.height);
    },
    setRect:function (rect) {
        if (!this._rect){
            this._rect = cc.rect(0,0,0,0);
        }
        this._rect.x = rect.x;
        this._rect.y = rect.y;
        this._rect.width = rect.width;
        this._rect.height = rect.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect);
    },
    getOffsetInPixels:function () {
        return cc.p(this._offsetInPixels);
    },
    setOffsetInPixels:function (offsetInPixels) {
        this._offsetInPixels.x = offsetInPixels.x;
        this._offsetInPixels.y = offsetInPixels.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset);
    },
    getOriginalSizeInPixels:function () {
        return cc.size(this._originalSizeInPixels);
    },
    setOriginalSizeInPixels:function (sizeInPixels) {
        this._originalSizeInPixels.width = sizeInPixels.width;
        this._originalSizeInPixels.height = sizeInPixels.height;
    },
    getOriginalSize:function () {
        return cc.size(this._originalSize);
    },
    setOriginalSize:function (sizeInPixels) {
        this._originalSize.width = sizeInPixels.width;
        this._originalSize.height = sizeInPixels.height;
    },
    getTexture:function () {
        if (this._texture)
            return this._texture;
        if (this._textureFilename !== "") {
            var locTexture = cc.textureCache.addImage(this._textureFilename);
            if (locTexture)
                this._textureLoaded = locTexture.isLoaded();
            return locTexture;
        }
        return null;
    },
    setTexture:function (texture) {
        if (this._texture != texture) {
            var locLoaded = texture.isLoaded();
            this._textureLoaded = locLoaded;
            this._texture = texture;
            if(!locLoaded){
                texture.addEventListener("load", function(sender){
                    this._textureLoaded = true;
                    if(this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS){
                        var tempElement = sender.getHtmlElementObj();
                        tempElement = cc.cutRotateImageToCanvas(tempElement, this.getRect());
                        var tempTexture = new cc.Texture2D();
                        tempTexture.initWithElement(tempElement);
                        tempTexture.handleLoadedTexture();
                        this.setTexture(tempTexture);
                        var rect = this.getRect();
                        this.setRect(cc.rect(0, 0, rect.width, rect.height));
                    }
                    var locRect = this._rect;
                    if(locRect.width === 0 && locRect.height === 0){
                        var w = sender.width, h = sender.height;
                        this._rect.width = w;
                        this._rect.height = h;
                        this._rectInPixels = cc.rectPointsToPixels(this._rect);
                        this._originalSizeInPixels.width = this._rectInPixels.width;
                        this._originalSizeInPixels.height = this._rectInPixels.height;
                        this._originalSize.width =  w;
                        this._originalSize.height =  h;
                    }
                    this.dispatchEvent("load");
                }, this);
            }
        }
    },
    getOffset:function () {
        return cc.p(this._offset);
    },
    setOffset:function (offsets) {
        this._offset.x = offsets.x;
        this._offset.y = offsets.y;
    },
    clone: function(){
        var frame = new cc.SpriteFrame();
        frame.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        frame.setTexture(this._texture);
        return frame;
    },
    copyWithZone:function () {
        var copy = new cc.SpriteFrame();
        copy.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        copy.setTexture(this._texture);
        return copy;
    },
    copy:function () {
        return this.copyWithZone();
    },
    initWithTexture:function (texture, rect, rotated, offset, originalSize) {
        if(arguments.length === 2)
            rect = cc.rectPointsToPixels(rect);
        offset = offset || cc.p(0, 0);
        originalSize = originalSize || rect;
        rotated = rotated || false;
        if (cc.isString(texture)){
            this._texture = null;
            this._textureFilename = texture;
        } else if (texture instanceof cc.Texture2D){
            this.setTexture(texture);
        }
        texture = this.getTexture();
        this._rectInPixels = rect;
        rect = this._rect = cc.rectPixelsToPoints(rect);
        if(texture && texture.url && texture.isLoaded()) {
            var _x, _y;
            if(rotated){
                _x = rect.x + rect.height;
                _y = rect.y + rect.width;
            }else{
                _x = rect.x + rect.width;
                _y = rect.y + rect.height;
            }
            if(_x > texture.getPixelsWide()){
                cc.error(cc._LogInfos.RectWidth, texture.url);
            }
            if(_y > texture.getPixelsHigh()){
                cc.error(cc._LogInfos.RectHeight, texture.url);
            }
        }
        this._offsetInPixels.x = offset.x;
        this._offsetInPixels.y = offset.y;
        cc._pointPixelsToPointsOut(offset, this._offset);
        this._originalSizeInPixels.width = originalSize.width;
        this._originalSizeInPixels.height = originalSize.height;
        cc._sizePixelsToPointsOut(originalSize, this._originalSize);
        this._rotated = rotated;
        return true;
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function (filename, rect, rotated, offset, originalSize) {
    return new cc.SpriteFrame(filename,rect,rotated,offset,originalSize);
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function (texture, rect, rotated, offset, originalSize) {
    var spriteFrame = new cc.SpriteFrame();
    spriteFrame._texture = texture;
    spriteFrame._rectInPixels = rect;
    spriteFrame._rect = cc.rectPixelsToPoints(rect);
    spriteFrame._offsetInPixels.x = offset.x;
    spriteFrame._offsetInPixels.y = offset.y;
    cc._pointPixelsToPointsOut(spriteFrame._offsetInPixels, spriteFrame._offset);
    spriteFrame._originalSizeInPixels.width = originalSize.width;
    spriteFrame._originalSizeInPixels.height = originalSize.height;
    cc._sizePixelsToPointsOut(spriteFrame._originalSizeInPixels, spriteFrame._originalSize);
    spriteFrame._rotated = rotated;
    return spriteFrame;
};
cc.spriteFrameCache = {
    _CCNS_REG1 : /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2 : /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache : {},
    _rectFromString :  function (content) {
        var result = this._CCNS_REG2.exec(content);
        if(!result) return cc.rect(0, 0, 0, 0);
        return cc.rect(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]), parseFloat(result[4]));
    },
    _pointFromString : function (content) {
        var result = this._CCNS_REG1.exec(content);
        if(!result) return cc.p(0,0);
        return cc.p(parseFloat(result[1]), parseFloat(result[2]));
    },
    _sizeFromString : function (content) {
        var result = this._CCNS_REG1.exec(content);
        if(!result) return cc.size(0, 0);
        return cc.size(parseFloat(result[1]), parseFloat(result[2]));
    },
    _getFrameConfig : function(url){
        var dict = cc.loader.getRes(url);
        cc.assert(dict, cc._LogInfos.spriteFrameCache__getFrameConfig_2, url);
        cc.loader.release(url);//release it in loader
        if(dict._inited){
            this._frameConfigCache[url] = dict;
            return dict;
        }
        var tempFrames = dict["frames"], tempMeta = dict["metadata"] || dict["meta"];
        var frames = {}, meta = {};
        var format = 0;
        if(tempMeta){//init meta
            var tmpFormat = tempMeta["format"];
            format = (tmpFormat.length <= 1) ? parseInt(tmpFormat) : tmpFormat;
            meta.image = tempMeta["textureFileName"] || tempMeta["textureFileName"] || tempMeta["image"];
        }
        for (var key in tempFrames) {
            var frameDict = tempFrames[key];
            if(!frameDict) continue;
            var tempFrame = {};
            if (format == 0) {
                tempFrame.rect = cc.rect(frameDict["x"], frameDict["y"], frameDict["width"], frameDict["height"]);
                tempFrame.rotated = false;
                tempFrame.offset = cc.p(frameDict["offsetX"], frameDict["offsetY"]);
                var ow = frameDict["originalWidth"];
                var oh = frameDict["originalHeight"];
                if (!ow || !oh) {
                    cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                }
                ow = Math.abs(ow);
                oh = Math.abs(oh);
                tempFrame.size = cc.size(ow, oh);
            } else if (format == 1 || format == 2) {
                tempFrame.rect = this._rectFromString(frameDict["frame"]);
                tempFrame.rotated = frameDict["rotated"] || false;
                tempFrame.offset = this._pointFromString(frameDict["offset"]);
                tempFrame.size = this._sizeFromString(frameDict["sourceSize"]);
            } else if (format == 3) {
                var spriteSize = this._sizeFromString(frameDict["spriteSize"]);
                var textureRect = this._rectFromString(frameDict["textureRect"]);
                if (spriteSize) {
                    textureRect = cc.rect(textureRect.x, textureRect.y, spriteSize.width, spriteSize.height);
                }
                tempFrame.rect = textureRect;
                tempFrame.rotated = frameDict["textureRotated"] || false;
                tempFrame.offset = this._pointFromString(frameDict["spriteOffset"]);
                tempFrame.size = this._sizeFromString(frameDict["spriteSourceSize"]);
                tempFrame.aliases = frameDict["aliases"];
            } else {
                var tmpFrame = frameDict["frame"], tmpSourceSize = frameDict["sourceSize"];
                key = frameDict["filename"] || key;
                tempFrame.rect = cc.rect(tmpFrame["x"], tmpFrame["y"], tmpFrame["w"], tmpFrame["h"]);
                tempFrame.rotated = frameDict["rotated"] || false;
                tempFrame.offset = cc.p(0, 0);
                tempFrame.size = cc.size(tmpSourceSize["w"], tmpSourceSize["h"]);
            }
            frames[key] = tempFrame;
        }
        var cfg = this._frameConfigCache[url] = {
            _inited : true,
            frames : frames,
            meta : meta
        };
        return cfg;
    },
    addSpriteFrames: function (url, texture) {
        cc.assert(url, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var dict = this._frameConfigCache[url] || cc.loader.getRes(url);
        if(!dict || !dict["frames"])
            return;
        var self = this;
        var frameConfig = self._frameConfigCache[url] || self._getFrameConfig(url);
        var frames = frameConfig.frames, meta = frameConfig.meta;
        if(!texture){
            var texturePath = cc.path.changeBasename(url, meta.image || ".png");
            texture = cc.textureCache.addImage(texturePath);
        }else if(texture instanceof cc.Texture2D){
        }else if(cc.isString(texture)){//string
            texture = cc.textureCache.addImage(texture);
        }else{
            cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3);
        }
        var spAliases = self._spriteFramesAliases, spriteFrames = self._spriteFrames;
        for (var key in frames) {
            var frame = frames[key];
            var spriteFrame = spriteFrames[key];
            if (!spriteFrame) {
                spriteFrame = new cc.SpriteFrame(texture, frame.rect, frame.rotated, frame.offset, frame.size);
                var aliases = frame.aliases;
                if(aliases){//set aliases
                    for(var i = 0, li = aliases.length; i < li; i++){
                        var alias = aliases[i];
                        if (spAliases[alias]) {
                            cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, alias);
                        }
                        spAliases[alias] = key;
                    }
                }
                if (cc._renderType === cc._RENDER_TYPE_CANVAS && spriteFrame.isRotated()) {
                    var locTexture = spriteFrame.getTexture();
                    if (locTexture.isLoaded()) {
                        var tempElement = spriteFrame.getTexture().getHtmlElementObj();
                        tempElement = cc.cutRotateImageToCanvas(tempElement, spriteFrame.getRectInPixels());
                        var tempTexture = new cc.Texture2D();
                        tempTexture.initWithElement(tempElement);
                        tempTexture.handleLoadedTexture();
                        spriteFrame.setTexture(tempTexture);
                        var rect = spriteFrame._rect;
                        spriteFrame.setRect(cc.rect(0, 0, rect.width, rect.height));
                    }
                }
                spriteFrames[key] = spriteFrame;
            }
        }
    },
    _checkConflict: function (dictionary) {
        var framesDict = dictionary["frames"];
        for (var key in framesDict) {
            if (this._spriteFrames[key]) {
                cc.log(cc._LogInfos.spriteFrameCache__checkConflict, key);
            }
        }
    },
    addSpriteFrame: function (frame, frameName) {
        this._spriteFrames[frameName] = frame;
    },
    removeSpriteFrames: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
    },
    removeSpriteFrameByName: function (name) {
        if (!name) {
            return;
        }
        if (this._spriteFramesAliases[name]) {
            delete(this._spriteFramesAliases[name]);
        }
        if (this._spriteFrames[name]) {
            delete(this._spriteFrames[name]);
        }
    },
    removeSpriteFramesFromFile: function (url) {
        var self = this, spriteFrames = self._spriteFrames,
            aliases = self._spriteFramesAliases, cfg = self._frameConfigCache[url];
        if(!cfg) return;
        var frames = cfg.frames;
        for (var key in frames) {
            if (spriteFrames[key]) {
                delete(spriteFrames[key]);
                for (var alias in aliases) {//remove alias
                    if(aliases[alias] == key) delete aliases[alias];
                }
            }
        }
    },
    removeSpriteFramesFromTexture: function (texture) {
        var self = this, spriteFrames = self._spriteFrames, aliases = self._spriteFramesAliases;
        for (var key in spriteFrames) {
            var frame = spriteFrames[key];
            if (frame && (frame.getTexture() == texture)) {
                delete(spriteFrames[key]);
                for (var alias in aliases) {//remove alias
                    if(aliases[alias] == key) delete aliases[alias];
                }
            }
        }
    },
    getSpriteFrame: function (name) {
        var self = this, frame = self._spriteFrames[name];
        if (!frame) {
            var key = self._spriteFramesAliases[name];
            if (key) {
                frame = self._spriteFrames[key.toString()];
                if(!frame) delete self._spriteFramesAliases[name];
            }
        }
        if (!frame) cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, name);
        return frame;
    },
	_clear: function () {
		this._spriteFrames = {};
		this._spriteFramesAliases = {};
		this._frameConfigCache = {};
	}
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function (transformOut) {
    var projection = new cc.kmMat4();
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, projection);
    var modelview = new cc.kmMat4();
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, modelview);
    cc.kmMat4Multiply(transformOut, projection, modelview);
};
cc.Director = cc.Class.extend({
    _landscape: false,
    _nextDeltaTimeZero: false,
    _paused: false,
    _purgeDirectorInNextLoop: false,
    _sendCleanupToScene: false,
    _animationInterval: 0.0,
    _oldAnimationInterval: 0.0,
    _projection: 0,
    _accumDt: 0.0,
    _contentScaleFactor: 1.0,
    _displayStats: false,
    _deltaTime: 0.0,
    _frameRate: 0.0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function () {
        var self = this;
        self._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            self._lastUpdate = Date.now();
        });
    },
    init: function () {
        this._oldAnimationInterval = this._animationInterval = 1.0 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._accumDt = 0;
        this._frameRate = 0;
        this._displayStats = false;//can remove
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1.0;
        this._scheduler = new cc.Scheduler();
        this._actionManager = cc.ActionManager ? new cc.ActionManager() : null;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return true;
    },
    calculateDeltaTime: function () {
        var now = Date.now();
        if (this._nextDeltaTimeZero) {
            this._deltaTime = 0;
            this._nextDeltaTimeZero = false;
        } else {
            this._deltaTime = (now - this._lastUpdate) / 1000;
        }
        if ((cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0) && (this._deltaTime > 0.2))
            this._deltaTime = 1 / 60.0;
        this._lastUpdate = now;
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function () {
        var renderer = cc.renderer;
        this.calculateDeltaTime();
        if (!this._paused) {
            this._scheduler.update(this._deltaTime);
            cc.eventManager.dispatchEvent(this._eventAfterUpdate);
        }
        this._clear();
        if (this._nextScene) {
            this.setNextScene();
        }
        if (this._beforeVisitScene)
            this._beforeVisitScene();
        if (this._runningScene) {
            if (renderer.childrenOrderDirty === true) {
                cc.renderer.clearRenderCommands();
                this._runningScene._curLevel = 0;
                this._runningScene.visit();
                renderer.resetFlag();
            } else if (renderer.transformDirty() === true)
                renderer.transform();
            cc.eventManager.dispatchEvent(this._eventAfterVisit);
        }
        if (this._notificationNode)
            this._notificationNode.visit();
        if (this._displayStats)
            this._showStats();
        if (this._afterVisitScene)
            this._afterVisitScene();
        renderer.rendering(cc._renderContext);
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        if (this._displayStats)
            this._calculateMPF();
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function () {
        this._purgeDirectorInNextLoop = true;
    },
    getContentScaleFactor: function () {
        return this._contentScaleFactor;
    },
    getNotificationNode: function () {
        return this._notificationNode;
    },
    getWinSize: function () {
        return cc.size(this._winSizeInPoints);
    },
    getWinSizeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function () {
        if (this._paused)
            return;
        this._oldAnimationInterval = this._animationInterval;
        this.setAnimationInterval(1 / 4.0);
        this._paused = true;
    },
    popScene: function () {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var c = this._scenesStack.length;
        if (c == 0)
            this.end();
        else {
            this._sendCleanupToScene = true;
            this._nextScene = this._scenesStack[c - 1];
        }
    },
    purgeCachedData: function () {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear();
    },
    purgeDirector: function () {
        this.getScheduler().unscheduleAllCallbacks();
        if (cc.eventManager)
            cc.eventManager.setEnabled(false);
        if (this._runningScene) {
            this._runningScene.onExitTransitionDidStart();
            this._runningScene.onExit();
            this._runningScene.cleanup();
        }
        this._runningScene = null;
        this._nextScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug();
    },
    pushScene: function (scene) {
        cc.assert(scene, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = false;
        this._scenesStack.push(scene);
        this._nextScene = scene;
    },
    runScene: function (scene) {
        cc.assert(scene, cc._LogInfos.Director_pushScene);
        if (!this._runningScene) {
            this.pushScene(scene);
            this.startAnimation();
        } else {
            var i = this._scenesStack.length;
            if (i === 0) {
                this._sendCleanupToScene = true;
                this._scenesStack[i] = scene;
                this._nextScene = scene;
            } else {
                this._sendCleanupToScene = true;
                this._scenesStack[i - 1] = scene;
                this._nextScene = scene;
            }
        }
    },
    resume: function () {
        if (!this._paused) {
            return;
        }
        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = Date.now();
        if (!this._lastUpdate) {
            cc.log(cc._LogInfos.Director_resume);
        }
        this._paused = false;
        this._deltaTime = 0;
    },
    setContentScaleFactor: function (scaleFactor) {
        if (scaleFactor != this._contentScaleFactor) {
            this._contentScaleFactor = scaleFactor;
            this._createStatsLabel();
        }
    },
    setDepthTest: null,
    setDefaultValues: function () {
    },
    setNextDeltaTimeZero: function (nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
    },
    setNextScene: function () {
        var runningIsTransition = false, newIsTransition = false;
        if (cc.TransitionScene) {
            runningIsTransition = this._runningScene ? this._runningScene instanceof cc.TransitionScene : false;
            newIsTransition = this._nextScene ? this._nextScene instanceof cc.TransitionScene : false;
        }
        if (!newIsTransition) {
            var locRunningScene = this._runningScene;
            if (locRunningScene) {
                locRunningScene.onExitTransitionDidStart();
                locRunningScene.onExit();
            }
            if (this._sendCleanupToScene && locRunningScene)
                locRunningScene.cleanup();
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = true;
        this._nextScene = null;
        if ((!runningIsTransition) && (this._runningScene != null)) {
            this._runningScene.onEnter();
            this._runningScene.onEnterTransitionDidFinish();
        }
    },
    setNotificationNode: function (node) {
        this._notificationNode = node;
    },
    getDelegate: function () {
        return this._projectionDelegate;
    },
    setDelegate: function (delegate) {
        this._projectionDelegate = delegate;
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function () {
        this._frames++;
        this._accumDt += this._deltaTime;
        if (this._FPSLabel && this._SPFLabel && this._drawsLabel) {
            if (this._accumDt > cc.DIRECTOR_FPS_INTERVAL) {
                this._SPFLabel.string = this._secondsPerFrame.toFixed(3);
                this._frameRate = this._frames / this._accumDt;
                this._frames = 0;
                this._accumDt = 0;
                this._FPSLabel.string = this._frameRate.toFixed(1);
                this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString();
            }
            this._FPSLabel.visit();
            this._SPFLabel.visit();
            this._drawsLabel.visit();
        } else
            this._createStatsLabel();
        cc.g_NumberOfDraws = 0;
    },
    isSendCleanupToScene: function () {
        return this._sendCleanupToScene;
    },
    getRunningScene: function () {
        return this._runningScene;
    },
    getAnimationInterval: function () {
        return this._animationInterval;
    },
    isDisplayStats: function () {
        return this._displayStats;
    },
    setDisplayStats: function (displayStats) {
        this._displayStats = displayStats;
    },
    getSecondsPerFrame: function () {
        return this._secondsPerFrame;
    },
    isNextDeltaTimeZero: function () {
        return this._nextDeltaTimeZero;
    },
    isPaused: function () {
        return this._paused;
    },
    getTotalFrames: function () {
        return this._totalFrames;
    },
    popToRootScene: function () {
        this.popToSceneStackLevel(1);
    },
    popToSceneStackLevel: function (level) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var locScenesStack = this._scenesStack;
        var c = locScenesStack.length;
        if (c == 0) {
            this.end();
            return;
        }
        if (level > c)
            return;
        while (c > level) {
            var current = locScenesStack.pop();
            if (current.running) {
                current.onExitTransitionDidStart();
                current.onExit();
            }
            current.cleanup();
            c--;
        }
        this._nextScene = locScenesStack[locScenesStack.length - 1];
        this._sendCleanupToScene = false;
    },
    getScheduler: function () {
        return this._scheduler;
    },
    setScheduler: function (scheduler) {
        if (this._scheduler != scheduler) {
            this._scheduler = scheduler;
        }
    },
    getActionManager: function () {
        return this._actionManager;
    },
    setActionManager: function (actionManager) {
        if (this._actionManager != actionManager) {
            this._actionManager = actionManager;
        }
    },
    getDeltaTime: function () {
        return this._deltaTime;
    },
    _createStatsLabel: null,
    _calculateMPF: function () {
        var now = Date.now();
        this._secondsPerFrame = (now - this._lastUpdate) / 1000;
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: false,
    startAnimation: function () {
        this._nextDeltaTimeZero = true;
        this.invalid = false;
    },
    mainLoop: function () {
        if (this._purgeDirectorInNextLoop) {
            this._purgeDirectorInNextLoop = false;
            this.purgeDirector();
        }
        else if (!this.invalid) {
            this.drawScene();
        }
    },
    stopAnimation: function () {
        this.invalid = true;
    },
    setAnimationInterval: function (value) {
        this._animationInterval = value;
        if (!this.invalid) {
            this.stopAnimation();
            this.startAnimation();
        }
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = true;
cc.Director._getInstance = function () {
    if (cc.Director.firstUseDirector) {
        cc.Director.firstUseDirector = false;
        cc.Director.sharedDirector = new cc.DisplayLinkDirector();
        cc.Director.sharedDirector.init();
    }
    return cc.Director.sharedDirector;
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Director.prototype;
    _p.setProjection = function (projection) {
        this._projection = projection;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
    };
    _p.setDepthTest = function () {
    };
    _p.setOpenGLView = function (openGLView) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = openGLView || cc.view;
        if (cc.eventManager)
            cc.eventManager.setEnabled(true);
    };
    _p._clear = function () {
        var viewport = this._openGLView.getViewPortRect();
        cc._renderContext.clearRect(-viewport.x, viewport.y, viewport.width, -viewport.height);
    };
    _p._createStatsLabel = function () {
        var _t = this;
        var fontSize = 0;
        if (_t._winSizeInPoints.width > _t._winSizeInPoints.height)
            fontSize = 0 | (_t._winSizeInPoints.height / 320 * 24);
        else
            fontSize = 0 | (_t._winSizeInPoints.width / 320 * 24);
        _t._FPSLabel = new cc.LabelTTF("000.0", "Arial", fontSize);
        _t._SPFLabel = new cc.LabelTTF("0.000", "Arial", fontSize);
        _t._drawsLabel = new cc.LabelTTF("0000", "Arial", fontSize);
        var locStatsPosition = cc.DIRECTOR_STATS_POSITION;
        _t._drawsLabel.setPosition(_t._drawsLabel.width / 2 + locStatsPosition.x, _t._drawsLabel.height * 5 / 2 + locStatsPosition.y);
        _t._SPFLabel.setPosition(_t._SPFLabel.width / 2 + locStatsPosition.x, _t._SPFLabel.height * 3 / 2 + locStatsPosition.y);
        _t._FPSLabel.setPosition(_t._FPSLabel.width / 2 + locStatsPosition.x, _t._FPSLabel.height / 2 + locStatsPosition.y);
    };
    _p.getVisibleSize = function () {
        return this.getWinSize();
    };
    _p.getVisibleOrigin = function () {
        return cc.p(0, 0);
    };
} else {
    cc.Director._fpsImage = new Image();
    cc._addEventListener(cc.Director._fpsImage, "load", function () {
        cc.Director._fpsImageLoaded = true;
    });
    if (cc._fpsImage) {
        cc.Director._fpsImage.src = cc._fpsImage;
    }
    cc.assert(cc.isFunction(cc._tmp.DirectorWebGL), cc._LogInfos.MissingFile, "CCDirectorWebGL.js");
    cc._tmp.DirectorWebGL();
    delete cc._tmp.DirectorWebGL;
}
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function (prev, next, target, priority, paused, markedForDeletion) {
    this.prev = prev;
    this.next = next;
    this.target = target;
    this.priority = priority;
    this.paused = paused;
    this.markedForDeletion = markedForDeletion;
};
cc.HashUpdateEntry = function (list, entry, target, hh) {
    this.list = list;
    this.entry = entry;
    this.target = target;
    this.hh = hh;
};
cc.HashTimerEntry = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
    var _t = this;
    _t.timers = timers;
    _t.target = target;
    _t.timerIndex = timerIndex;
    _t.currentTimer = currentTimer;
    _t.currentTimerSalvaged = currentTimerSalvaged;
    _t.paused = paused;
    _t.hh = hh;
};
cc.Timer = cc.Class.extend({
    _interval:0.0,
    _callback:null,//is called _callback before
    _target:null,//target of _callback
    _elapsed:0.0,
    _runForever:false,
    _useDelay:false,
    _timesExecuted:0,
    _repeat:0,
    _delay:0,
    getInterval : function(){return this._interval;},
    setInterval : function(interval){this._interval = interval;},
    getCallback : function(){return this._callback},
    ctor:function (target, callback, interval, repeat, delay) {
        var self = this;
        self._target = target;
        self._callback = callback;
        self._elapsed = -1;
        self._interval = interval || 0;
        self._delay = delay || 0;
        self._useDelay = self._delay > 0;
        self._repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        self._runForever = (self._repeat == cc.REPEAT_FOREVER);
    },
    _doCallback:function(){
        var self = this;
        if (cc.isString(self._callback))
            self._target[self._callback](self._elapsed);
        else
            self._callback.call(self._target, self._elapsed);
    },
    update:function (dt) {
        var self = this;
        if (self._elapsed == -1) {
            self._elapsed = 0;
            self._timesExecuted = 0;
        } else {
            var locTarget = self._target, locCallback = self._callback;
            self._elapsed += dt;//standard timer usage
            if (self._runForever && !self._useDelay) {
                if (self._elapsed >= self._interval) {
                    if (locTarget && locCallback)
                        self._doCallback();
                    self._elapsed = 0;
                }
            } else {
                if (self._useDelay) {
                    if (self._elapsed >= self._delay) {
                        if (locTarget && locCallback)
                            self._doCallback();
                        self._elapsed = self._elapsed - self._delay;
                        self._timesExecuted += 1;
                        self._useDelay = false;
                    }
                } else {
                    if (self._elapsed >= self._interval) {
                        if (locTarget && locCallback)
                            self._doCallback();
                        self._elapsed = 0;
                        self._timesExecuted += 1;
                    }
                }
                if (self._timesExecuted > self._repeat)
                    cc.director.getScheduler().unscheduleCallbackForTarget(locTarget, locCallback);
            }
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale:1.0,
    _updates : null,
    _hashForUpdates:null,
    _arrayForUpdates:null,
    _hashForTimers:null,
    _arrayForTimes:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,
    _updateHashLocked:false,
    ctor:function () {
        var self = this;
        self._timeScale = 1.0;
        self._updates = [[], [], []];
        self._hashForUpdates = {};
        self._arrayForUpdates = [];
        self._hashForTimers = {};
        self._arrayForTimers = [];
        self._currentTarget = null;
        self._currentTargetSalvaged = false;
        self._updateHashLocked = false;
    },
    _removeHashElement:function (element) {
        delete this._hashForTimers[element.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, element);
        element.Timer = null;
        element.target = null;
        element = null;
    },
    _removeUpdateFromHash:function (entry) {
        var self = this, element = self._hashForUpdates[entry.target.__instanceId];
        if (element) {
            cc.arrayRemoveObject(element.list, element.entry);
            delete self._hashForUpdates[element.target.__instanceId];
            cc.arrayRemoveObject(self._arrayForUpdates, element);
            element.entry = null;
            element.target = null;
        }
    },
    _priorityIn:function (ppList, target, priority, paused) {
        var self = this, listElement = new cc.ListEntry(null, null, target, priority, paused, false);
        if (!ppList) {
            ppList = [];
            ppList.push(listElement);
        } else {
            var index2Insert = ppList.length - 1;
            for(var i = 0; i <= index2Insert; i++){
                if (priority < ppList[i].priority) {
                    index2Insert = i;
                    break;
                }
            }
            ppList.splice(i, 0, listElement);
        }
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        self._arrayForUpdates.push(hashElement);
        self._hashForUpdates[target.__instanceId] = hashElement;
        return ppList;
    },
    _appendIn:function (ppList, target, paused) {
        var self = this, listElement = new cc.ListEntry(null, null, target, 0, paused, false);
        ppList.push(listElement);
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        self._arrayForUpdates.push(hashElement);
        self._hashForUpdates[target.__instanceId] = hashElement;
    },
    setTimeScale:function (timeScale) {
        this._timeScale = timeScale;
    },
    getTimeScale:function () {
        return this._timeScale;
    },
    update:function (dt) {
        var self = this;
        var locUpdates = self._updates, locArrayForTimers = self._arrayForTimers;
        var tmpEntry, elt, i, li;
        self._updateHashLocked = true;
        if (this._timeScale != 1.0) {
            dt *= this._timeScale;
        }
        for(i = 0, li = locUpdates.length; i < li && i >= 0; i++){
            var update = self._updates[i];
            for(var j = 0, lj = update.length; j < lj; j++){
                tmpEntry = update[j];
                if ((!tmpEntry.paused) && (!tmpEntry.markedForDeletion)) tmpEntry.target.update(dt);
            }
        }
        for(i = 0, li = locArrayForTimers.length; i < li; i++){
            elt = locArrayForTimers[i];
            if(!elt) break;
            self._currentTarget = elt;
            self._currentTargetSalvaged = false;
            if (!elt.paused) {
                for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; elt.timerIndex++) {
                    elt.currentTimer = elt.timers[elt.timerIndex];
                    elt.currentTimerSalvaged = false;
                    elt.currentTimer.update(dt);
                    elt.currentTimer = null;
                }
            }
            if ((self._currentTargetSalvaged) && (elt.timers.length == 0)){
                self._removeHashElement(elt);
                i--;
            }
        }
        for(i = 0, li = locUpdates.length; i < li; i++){
            var update = self._updates[i];
            for(var j = 0, lj = update.length; j < lj; ){
                tmpEntry = update[j];
                if(!tmpEntry) break;
                if (tmpEntry.markedForDeletion) self._removeUpdateFromHash(tmpEntry);
                else j++;
            }
        }
        self._updateHashLocked = false;
        self._currentTarget = null;
    },
    scheduleCallbackForTarget:function (target, callback_fn, interval, repeat, delay, paused) {
        cc.assert(callback_fn, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
        cc.assert(target, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        interval = interval || 0;
        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        paused = paused || false;
        var self = this, timer;
        var element = self._hashForTimers[target.__instanceId];
        if (!element) {
            element = new cc.HashTimerEntry(null, target, 0, null, null, paused, null);
            self._arrayForTimers.push(element);
            self._hashForTimers[target.__instanceId] = element;
        }
        if (element.timers == null) {
            element.timers = [];
        } else {
            for (var i = 0; i < element.timers.length; i++) {
                timer = element.timers[i];
                if (callback_fn == timer._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, timer.getInterval().toFixed(4), interval.toFixed(4));
                    timer._interval = interval;
                    return;
                }
            }
        }
        timer = new cc.Timer(target, callback_fn, interval, repeat, delay);
        element.timers.push(timer);
    },
    scheduleUpdateForTarget:function (target, priority, paused) {
        if(target === null)
            return;
        var self = this, locUpdates = self._updates;
        var hashElement = self._hashForUpdates[target.__instanceId];
        if (hashElement) {
            hashElement.entry.markedForDeletion = false;
            return;
        }
        if (priority == 0) {
            self._appendIn(locUpdates[1], target, paused);
        } else if (priority < 0) {
            locUpdates[0] = self._priorityIn(locUpdates[0], target, priority, paused);
        } else {
            locUpdates[2] = self._priorityIn(locUpdates[2], target, priority, paused);
        }
    },
    unscheduleCallbackForTarget:function (target, callback_fn) {
        if ((target == null) || (callback_fn == null)) {
            return;
        }
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            var timers = element.timers;
            for(var i = 0, li = timers.length; i < li; i++){
                var timer = timers[i];
                if (callback_fn == timer._callback) {
                    if ((timer == element.currentTimer) && (!element.currentTimerSalvaged)) {
                        element.currentTimerSalvaged = true;
                    }
                    timers.splice(i, 1)
                    if (element.timerIndex >= i) {
                        element.timerIndex--;
                    }
                    if (timers.length == 0) {
                        if (self._currentTarget == element) {
                            self._currentTargetSalvaged = true;
                        } else {
                            self._removeHashElement(element);
                        }
                    }
                    return;
                }
            }
        }
    },
    unscheduleUpdateForTarget:function (target) {
        if (target == null) {
            return;
        }
        var self = this, element = self._hashForUpdates[target.__instanceId];
        if (element != null) {
            if (self._updateHashLocked) {
                element.entry.markedForDeletion = true;
            } else {
                self._removeUpdateFromHash(element.entry);
            }
        }
    },
    unscheduleAllCallbacksForTarget:function (target) {
        if (target == null) {
            return;
        }
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            var timers = element.timers;
            if ((!element.currentTimerSalvaged) && (timers.indexOf(element.currentTimer) >= 0)) {
                element.currentTimerSalvaged = true;
            }
            timers.length = 0;
            if (self._currentTarget == element) {
                self._currentTargetSalvaged = true;
            } else {
                self._removeHashElement(element);
            }
        }
        self.unscheduleUpdateForTarget(target);
    },
    unscheduleAllCallbacks:function () {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    unscheduleAllCallbacksWithMinPriority:function (minPriority) {
        var self = this, locArrayForTimers = self._arrayForTimers, locUpdates = self._updates;
        for(var i = 0, li = locArrayForTimers.length; i < li; i++){
            self.unscheduleAllCallbacksForTarget(locArrayForTimers[i].target);
        }
        for(var i = 2; i >= 0; i--){
            if((i == 1 && minPriority > 0) || (i == 0 && minPriority >= 0)) continue;
            var updates = locUpdates[i];
            for(var j = 0, lj = updates.length; j < lj; j++){
                self.unscheduleUpdateForTarget(updates[j].target);
            }
        }
    },
    pauseAllTargets:function () {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
    },
    pauseAllTargetsWithMinPriority:function (minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers, locUpdates = self._updates;
        for(var i = 0, li = locArrayForTimers.length; i < li; i++){
            element = locArrayForTimers[i];
            if (element) {
                element.paused = true;
                idsWithSelectors.push(element.target);
            }
        }
        for(var i = 0, li = locUpdates.length; i < li; i++){
            var updates = locUpdates[i];
            for(var j = 0, lj = updates.length; j < lj; j++){
                element = updates[j];
                if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                }
            }
        }
        return idsWithSelectors;
    },
    resumeTargets:function (targetsToResume) {
        if (!targetsToResume)
            return;
        for (var i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
        }
    },
    pauseTarget:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_pauseTarget);
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            element.paused = true;
        }
        var elementUpdate = self._hashForUpdates[target.__instanceId];
        if (elementUpdate) {
            elementUpdate.entry.paused = true;
        }
    },
    resumeTarget:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_resumeTarget);
        var self = this, element = self._hashForTimers[target.__instanceId];
        if (element) {
            element.paused = false;
        }
        var elementUpdate = self._hashForUpdates[target.__instanceId];
        if (elementUpdate) {
            elementUpdate.entry.paused = false;
        }
    },
    isTargetPaused:function (target) {
        cc.assert(target, cc._LogInfos.Scheduler_isTargetPaused);
        var element = this._hashForTimers[target.__instanceId];
        if (element) {
            return element.paused;
        }
        return false;
    }
});
cc.Scheduler.PRIORITY_SYSTEM = (-2147483647 - 1);
cc._tmp.PrototypeLabelTTF = function () {
    var _p = cc.LabelTTF.prototype;
    cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
    cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
    _p.string;
    cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
    _p.textAlign;
    cc.defineGetterSetter(_p, "textAlign", _p.getHorizontalAlignment, _p.setHorizontalAlignment);
    _p.verticalAlign;
    cc.defineGetterSetter(_p, "verticalAlign", _p.getVerticalAlignment, _p.setVerticalAlignment);
    _p.fontSize;
    cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
    _p.fontName;
    cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
    _p.font;
    cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
    _p.boundingSize;
    _p.boundingWidth;
    cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
    _p.boundingHeight;
    cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
    _p.fillStyle;
    cc.defineGetterSetter(_p, "fillStyle", _p._getFillStyle, _p.setFontFillColor);
    _p.strokeStyle;
    cc.defineGetterSetter(_p, "strokeStyle", _p._getStrokeStyle, _p._setStrokeStyle);
    _p.lineWidth;
    cc.defineGetterSetter(_p, "lineWidth", _p._getLineWidth, _p._setLineWidth);
    _p.shadowOffset;
    _p.shadowOffsetX;
    cc.defineGetterSetter(_p, "shadowOffsetX", _p._getShadowOffsetX, _p._setShadowOffsetX);
    _p.shadowOffsetY;
    cc.defineGetterSetter(_p, "shadowOffsetY", _p._getShadowOffsetY, _p._setShadowOffsetY);
    _p.shadowOpacity;
    cc.defineGetterSetter(_p, "shadowOpacity", _p._getShadowOpacity, _p._setShadowOpacity);
    _p.shadowBlur;
    cc.defineGetterSetter(_p, "shadowBlur", _p._getShadowBlur, _p._setShadowBlur);
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0.0,
    _string: "",
    _originalText: null,
    _isMultiLine: false,
    _fontStyleStr: null,
    _shadowEnabled: false,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _shadowColor: null,
    _strokeEnabled: false,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: false,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    initWithString: function (label, fontName, fontSize, dimensions, hAlignment, vAlignment) {
        var strInfo;
        if (label)
            strInfo = label + "";
        else
            strInfo = "";
        fontSize = fontSize || 16;
        dimensions = dimensions || cc.size(0, 0);
        hAlignment = hAlignment || cc.TEXT_ALIGNMENT_LEFT;
        vAlignment = vAlignment || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = false;
        this._dimensions = cc.size(dimensions.width, dimensions.height);
        this._fontName = fontName || "Arial";
        this._hAlignment = hAlignment;
        this._vAlignment = vAlignment;
        this._fontSize = fontSize;
        this._fontStyleStr = this._fontSize + "px '" + fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(fontName, this._fontSize);
        this.string = strInfo;
        this._setColorsString();
        this._updateTexture();
        this._setUpdateTextureDirty();
        return true;
    },
    _setUpdateTextureDirty: function(){
        this._renderCmdDiry = this._needUpdateTexture = true;
        cc.renderer.pushDirtyNode(this);
    },
    ctor: function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = false;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._isMultiLine = false;
        this._shadowEnabled = false;
        this._shadowOffset = cc.p(0, 0);
        this._shadowOpacity = 0;
        this._shadowBlur = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = false;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetX = 0;
        this._strokeShadowOffsetY = 0;
        this._needUpdateTexture = false;
        this._lineWidths = [];
        this._setColorsString();
        if (fontName && fontName instanceof cc.FontDefinition) {
            this.initWithStringAndTextDefinition(text, fontName);
        } else {
            cc.LabelTTF.prototype.initWithString.call(this, text, fontName, fontSize, dimensions, hAlignment, vAlignment);
        }
    },
    init: function () {
        return this.initWithString(" ", this._fontName, this._fontSize);
    },
    _measureConfig: function () {
        this._getLabelContext().font = this._fontStyleStr;
    },
    _measure: function (text) {
        return this._getLabelContext().measureText(text).width;
    },
    description: function () {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">";
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function (parentOpacity) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, parentOpacity);
        this._setColorsString();
    },
    getString: function () {
        return this._string;
    },
    getHorizontalAlignment: function () {
        return this._hAlignment;
    },
    getVerticalAlignment: function () {
        return this._vAlignment;
    },
    getDimensions: function () {
        return cc.size(this._dimensions);
    },
    getFontSize: function () {
        return this._fontSize;
    },
    getFontName: function () {
        return this._fontName;
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function (theDefinition) {
        if (theDefinition)
            this._updateWithTextDefinition(theDefinition, true);
    },
    getTextDefinition: function () {
        return this._prepareTextDefinition(false);
    },
    enableShadow: function (a, b, c, d) {
        if(a.r != null && a.g != null && a.b != null && a.a != null){
            this._enableShadow(a, b, c);
        }else{
            this._enableShadowNoneColor(a, b, c, d)
        }
    },
    _enableShadowNoneColor: function(shadowOffsetX, shadowOffsetY, shadowOpacity, shadowBlur){
        shadowOpacity = shadowOpacity || 0.5;
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        var locShadowOffset = this._shadowOffset;
        if (locShadowOffset && (locShadowOffset.x != shadowOffsetX) || (locShadowOffset._y != shadowOffsetY)) {
            locShadowOffset.x = shadowOffsetX;
            locShadowOffset.y = shadowOffsetY;
        }
        if (this._shadowOpacity != shadowOpacity) {
            this._shadowOpacity = shadowOpacity;
        }
        this._setColorsString();
        if (this._shadowBlur != shadowBlur)
            this._shadowBlur = shadowBlur;
        this._setUpdateTextureDirty();
    },
    _enableShadow: function(shadowColor, offset, blurRadius){
        if(!this._shadowColor){
            this._shadowColor = cc.color(255, 255, 255, 128);
        }
        this._shadowColor.r = shadowColor.r;
        this._shadowColor.g = shadowColor.g;
        this._shadowColor.b = shadowColor.b;
        var x, y, a, b;
        x = offset.width || offset.x || 0;
        y = offset.height || offset.y || 0;
        a = (shadowColor.a != null) ? (shadowColor.a / 255) : 0.5;
        b = blurRadius;
        this._enableShadowNoneColor(x, y, a, b);
    },
    _getShadowOffsetX: function () {
        return this._shadowOffset.x;
    },
    _setShadowOffsetX: function (x) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset.x != x) {
            this._shadowOffset.x = x;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOffsetY: function () {
        return this._shadowOffset._y;
    },
    _setShadowOffsetY: function (y) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset._y != y) {
            this._shadowOffset._y = y;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOffset: function () {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y);
    },
    _setShadowOffset: function (offset) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOffset.x != offset.x || this._shadowOffset.y != offset.y) {
            this._shadowOffset.x = offset.x;
            this._shadowOffset.y = offset.y;
            this._setUpdateTextureDirty();
        }
    },
    _getShadowOpacity: function () {
        return this._shadowOpacity;
    },
    _setShadowOpacity: function (shadowOpacity) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowOpacity != shadowOpacity) {
            this._shadowOpacity = shadowOpacity;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    },
    _getShadowBlur: function () {
        return this._shadowBlur;
    },
    _setShadowBlur: function (shadowBlur) {
        if (false === this._shadowEnabled)
            this._shadowEnabled = true;
        if (this._shadowBlur != shadowBlur) {
            this._shadowBlur = shadowBlur;
            this._setUpdateTextureDirty();
        }
    },
    disableShadow: function () {
        if (this._shadowEnabled) {
            this._shadowEnabled = false;
            this._setUpdateTextureDirty();
        }
    },
    enableStroke: function (strokeColor, strokeSize) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        var locStrokeColor = this._strokeColor;
        if ((locStrokeColor.r !== strokeColor.r) || (locStrokeColor.g !== strokeColor.g) || (locStrokeColor.b !== strokeColor.b)) {
            locStrokeColor.r = strokeColor.r;
            locStrokeColor.g = strokeColor.g;
            locStrokeColor.b = strokeColor.b;
            this._setColorsString();
        }
        if (this._strokeSize !== strokeSize)
            this._strokeSize = strokeSize || 0;
        this._setUpdateTextureDirty();
    },
    _getStrokeStyle: function () {
        return this._strokeColor;
    },
    _setStrokeStyle: function (strokeStyle) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        var locStrokeColor = this._strokeColor;
        if ((locStrokeColor.r !== strokeStyle.r) || (locStrokeColor.g !== strokeStyle.g) || (locStrokeColor.b !== strokeStyle.b)) {
            locStrokeColor.r = strokeStyle.r;
            locStrokeColor.g = strokeStyle.g;
            locStrokeColor.b = strokeStyle.b;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    },
    _getLineWidth: function () {
        return this._strokeSize;
    },
    _setLineWidth: function (lineWidth) {
        if (this._strokeEnabled === false)
            this._strokeEnabled = true;
        if (this._strokeSize !== lineWidth) {
            this._strokeSize = lineWidth || 0;
            this._setUpdateTextureDirty();
        }
    },
    disableStroke: function () {
        if (this._strokeEnabled) {
            this._strokeEnabled = false;
            this._setUpdateTextureDirty();
        }
    },
    setFontFillColor: null,
    _getFillStyle: function () {
        return this._textFillColor;
    },
    _updateWithTextDefinition: function (textDefinition, mustUpdateTexture) {
        if (textDefinition.fontDimensions) {
            this._dimensions.width = textDefinition.boundingWidth;
            this._dimensions.height = textDefinition.boundingHeight;
        } else {
            this._dimensions.width = 0;
            this._dimensions.height = 0;
        }
        this._hAlignment = textDefinition.textAlign;
        this._vAlignment = textDefinition.verticalAlign;
        this._fontName = textDefinition.fontName;
        this._fontSize = textDefinition.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        if (textDefinition.shadowEnabled)
            this.enableShadow(textDefinition.shadowOffsetX,
                textDefinition.shadowOffsetY,
                textDefinition.shadowOpacity,
                textDefinition.shadowBlur);
        if (textDefinition.strokeEnabled)
            this.enableStroke(textDefinition.strokeStyle, textDefinition.lineWidth);
        this.setFontFillColor(textDefinition.fillStyle);
        if (mustUpdateTexture)
            this._updateTexture();
    },
    _prepareTextDefinition: function (adjustForResolution) {
        var texDef = new cc.FontDefinition();
        if (adjustForResolution) {
            texDef.fontSize = this._fontSize;
            texDef.boundingWidth = cc.contentScaleFactor() * this._dimensions.width;
            texDef.boundingHeight = cc.contentScaleFactor() * this._dimensions.height;
        } else {
            texDef.fontSize = this._fontSize;
            texDef.boundingWidth = this._dimensions.width;
            texDef.boundingHeight = this._dimensions.height;
        }
        texDef.fontName = this._fontName;
        texDef.textAlign = this._hAlignment;
        texDef.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            texDef.strokeEnabled = true;
            var locStrokeColor = this._strokeColor;
            texDef.strokeStyle = cc.color(locStrokeColor.r, locStrokeColor.g, locStrokeColor.b);
            texDef.lineWidth = this._strokeSize;
        } else
            texDef.strokeEnabled = false;
        if (this._shadowEnabled) {
            texDef.shadowEnabled = true;
            texDef.shadowBlur = this._shadowBlur;
            texDef.shadowOpacity = this._shadowOpacity;
            texDef.shadowOffsetX = (adjustForResolution ? cc.contentScaleFactor() : 1) * this._shadowOffset.x;
            texDef.shadowOffsetY = (adjustForResolution ? cc.contentScaleFactor() : 1) * this._shadowOffset.y;
        } else
            texDef._shadowEnabled = false;
        var locTextFillColor = this._textFillColor;
        texDef.fillStyle = cc.color(locTextFillColor.r, locTextFillColor.g, locTextFillColor.b);
        return texDef;
    },
    _fontClientHeight: 18,
    setString: function (text) {
        text = String(text);
        if (this._originalText != text) {
            this._originalText = text + "";
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _updateString: function () {
        this._string = this._originalText;
    },
    setHorizontalAlignment: function (alignment) {
        if (alignment !== this._hAlignment) {
            this._hAlignment = alignment;
            this._setUpdateTextureDirty();
        }
    },
    setVerticalAlignment: function (verticalAlignment) {
        if (verticalAlignment != this._vAlignment) {
            this._vAlignment = verticalAlignment;
            this._setUpdateTextureDirty();
        }
    },
    setDimensions: function (dim, height) {
        var width;
        if(height === undefined){
            width = dim.width;
            height = dim.height;
        }else
            width = dim;
        if (width != this._dimensions.width || height != this._dimensions.height) {
            this._dimensions.width = width;
            this._dimensions.height = height;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _getBoundingWidth: function () {
        return this._dimensions.width;
    },
    _setBoundingWidth: function (width) {
        if (width != this._dimensions.width) {
            this._dimensions.width = width;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    _getBoundingHeight: function () {
        return this._dimensions.height;
    },
    _setBoundingHeight: function (height) {
        if (height != this._dimensions.height) {
            this._dimensions.height = height;
            this._updateString();
            this._setUpdateTextureDirty();
        }
    },
    setFontSize: function (fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this._fontStyleStr = fontSize + "px '" + this._fontName + "'";
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, fontSize);
            this._setUpdateTextureDirty();
        }
    },
    setFontName: function (fontName) {
        if (this._fontName && this._fontName != fontName) {
            this._fontName = fontName;
            this._fontStyleStr = this._fontSize + "px '" + fontName + "'";
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(fontName, this._fontSize);
            this._setUpdateTextureDirty();
        }
    },
    _getFont: function () {
        return this._fontStyleStr;
    },
    _setFont: function (fontStyle) {
        var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
        if (res) {
            this._fontSize = parseInt(res[1]);
            this._fontName = res[2];
            this._fontStyleStr = fontStyle;
            this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
            this._setUpdateTextureDirty();
        }
    },
    _drawTTFInCanvas: function (context) {
        if (!context)
            return;
        var locStrokeShadowOffsetX = this._strokeShadowOffsetX, locStrokeShadowOffsetY = this._strokeShadowOffsetY;
        var locContentSizeHeight = this._contentSize.height - locStrokeShadowOffsetY, locVAlignment = this._vAlignment, locHAlignment = this._hAlignment,
            locFontHeight = this._fontClientHeight, locStrokeSize = this._strokeSize;
        context.setTransform(1, 0, 0, 1, 0 + locStrokeShadowOffsetX * 0.5, locContentSizeHeight + locStrokeShadowOffsetY * 0.5);
        if (context.font != this._fontStyleStr)
            context.font = this._fontStyleStr;
        context.fillStyle = this._fillColorStr;
        var xOffset = 0, yOffset = 0;
        var locStrokeEnabled = this._strokeEnabled;
        if (locStrokeEnabled) {
            context.lineWidth = locStrokeSize * 2;
            context.strokeStyle = this._strokeColorStr;
        }
        if (this._shadowEnabled) {
            var locShadowOffset = this._shadowOffset;
            context.shadowColor = this._shadowColorStr;
            context.shadowOffsetX = locShadowOffset.x;
            context.shadowOffsetY = -locShadowOffset.y;
            context.shadowBlur = this._shadowBlur;
        }
        context.textBaseline = cc.LabelTTF._textBaseline[locVAlignment];
        context.textAlign = cc.LabelTTF._textAlign[locHAlignment];
        var locContentWidth = this._contentSize.width - locStrokeShadowOffsetX;
        if (locHAlignment === cc.TEXT_ALIGNMENT_RIGHT)
            xOffset += locContentWidth;
        else if (locHAlignment === cc.TEXT_ALIGNMENT_CENTER)
            xOffset += locContentWidth / 2;
        else
            xOffset += 0;
        if (this._isMultiLine) {
            var locStrLen = this._strings.length;
            if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM)
                yOffset = locFontHeight + locContentSizeHeight - locFontHeight * locStrLen;
            else if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER)
                yOffset = locFontHeight / 2 + (locContentSizeHeight - locFontHeight * locStrLen) / 2;
            for (var i = 0; i < locStrLen; i++) {
                var line = this._strings[i];
                var tmpOffsetY = -locContentSizeHeight + (locFontHeight * i) + yOffset;
                if (locStrokeEnabled)
                    context.strokeText(line, xOffset, tmpOffsetY);
                context.fillText(line, xOffset, tmpOffsetY);
            }
        } else {
            if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            } else if (locVAlignment === cc.VERTICAL_TEXT_ALIGNMENT_TOP) {
                yOffset -= locContentSizeHeight;
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            } else {
                yOffset -= locContentSizeHeight * 0.5;
                if (locStrokeEnabled)
                    context.strokeText(this._string, xOffset, yOffset);
                context.fillText(this._string, xOffset, yOffset);
            }
        }
    },
    _getLabelContext: function () {
        if (this._labelContext)
            return this._labelContext;
        if (!this._labelCanvas) {
            var locCanvas = cc.newElement("canvas");
            var labelTexture = new cc.Texture2D();
            labelTexture.initWithElement(locCanvas);
            this.texture = labelTexture;
            this._labelCanvas = locCanvas;
        }
        this._labelContext = this._labelCanvas.getContext("2d");
        return this._labelContext;
    },
    _checkWarp: function(strArr, i, maxWidth){
        var text = strArr[i];
        var allWidth = this._measure(text);
        if(allWidth > maxWidth && text.length > 1){
            var fuzzyLen = text.length * ( maxWidth / allWidth ) | 0;
            var tmpText = text.substr(fuzzyLen);
            var width = allWidth - this._measure(tmpText);
            var sLine;
            var pushNum = 0;
            var checkWhile = 0;
            while(width > maxWidth && checkWhile++ < 100){
                fuzzyLen *= maxWidth / width;
                fuzzyLen = fuzzyLen | 0;
                tmpText = text.substr(fuzzyLen);
                width = allWidth - this._measure(tmpText);
            }
            checkWhile = 0;
            while(width < maxWidth && checkWhile++ < 100){
                if(tmpText){
                    var exec = cc.LabelTTF._wordRex.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1;
                    sLine = tmpText;
                }
                fuzzyLen = fuzzyLen + pushNum;
                tmpText = text.substr(fuzzyLen);
                width = allWidth - this._measure(tmpText);
            }
            fuzzyLen -= pushNum;
            var sText = text.substr(0, fuzzyLen);
            if(cc.LabelTTF.wrapInspection){
                if(cc.LabelTTF._symbolRex.test(sLine || tmpText)){
                    var result = cc.LabelTTF._lastWordRex.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;
                    sLine = text.substr(fuzzyLen);
                    sText = text.substr(0, fuzzyLen);
                }
            }
            if(cc.LabelTTF._firsrEnglish.test(sLine)){
                var result = cc.LabelTTF._lastEnglish.exec(sText);
                if(result && sText !== result[0]){
                    fuzzyLen -= result[0].length;
                    sLine = text.substr(fuzzyLen);
                    sText = text.substr(0, fuzzyLen);
                }
            }
            strArr[i] = sLine || tmpText;
            strArr.splice(i, 0, sText);
        }
    },
    _updateTTF: function () {
        var locDimensionsWidth = this._dimensions.width, i, strLength;
        var locLineWidth = this._lineWidths;
        locLineWidth.length = 0;
        this._isMultiLine = false;
        this._measureConfig();
        if (locDimensionsWidth !== 0) {
            this._strings = this._string.split('\n');
            for(i = 0; i < this._strings.length; i++){
                this._checkWarp(this._strings, i, locDimensionsWidth);
            }
        } else {
            this._strings = this._string.split('\n');
            for (i = 0, strLength = this._strings.length; i < strLength; i++) {
                locLineWidth.push(this._measure(this._strings[i]));
            }
        }
        if (this._strings.length > 0)
            this._isMultiLine = true;
        var locSize, locStrokeShadowOffsetX = 0, locStrokeShadowOffsetY = 0;
        if (this._strokeEnabled)
            locStrokeShadowOffsetX = locStrokeShadowOffsetY = this._strokeSize * 2;
        if (this._shadowEnabled) {
            var locOffsetSize = this._shadowOffset;
            locStrokeShadowOffsetX += Math.abs(locOffsetSize.x) * 2;
            locStrokeShadowOffsetY += Math.abs(locOffsetSize.y) * 2;
        }
        if (locDimensionsWidth === 0) {
            if (this._isMultiLine)
                locSize = cc.size(0 | (Math.max.apply(Math, locLineWidth) + locStrokeShadowOffsetX),
                    0 | ((this._fontClientHeight * this._strings.length) + locStrokeShadowOffsetY));
            else
                locSize = cc.size(0 | (this._measure(this._string) + locStrokeShadowOffsetX), 0 | (this._fontClientHeight + locStrokeShadowOffsetY));
        } else {
            if (this._dimensions.height === 0) {
                if (this._isMultiLine)
                    locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | ((this._fontClientHeight * this._strings.length) + locStrokeShadowOffsetY));
                else
                    locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | (this._fontClientHeight + locStrokeShadowOffsetY));
            } else {
                locSize = cc.size(0 | (locDimensionsWidth + locStrokeShadowOffsetX), 0 | (this._dimensions.height + locStrokeShadowOffsetY));
            }
        }
        this.setContentSize(locSize);
        this._strokeShadowOffsetX = locStrokeShadowOffsetX;
        this._strokeShadowOffsetY = locStrokeShadowOffsetY;
        var locAP = this._anchorPoint;
        this._anchorPointInPoints.x = (locStrokeShadowOffsetX * 0.5) + ((locSize.width - locStrokeShadowOffsetX) * locAP.x);
        this._anchorPointInPoints.y = (locStrokeShadowOffsetY * 0.5) + ((locSize.height - locStrokeShadowOffsetY) * locAP.y);
    },
    getContentSize: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this);
    },
    _getWidth: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this);
    },
    _getHeight: function () {
        if (this._needUpdateTexture)
            this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this);
    },
    _updateTexture: function () {
        var locContext = this._getLabelContext(), locLabelCanvas = this._labelCanvas;
        var locContentSize = this._contentSize;
        if (this._string.length === 0) {
            locLabelCanvas.width = 1;
            locLabelCanvas.height = locContentSize.height || 1;
            this._texture && this._texture.handleLoadedTexture();
            this.setTextureRect(cc.rect(0, 0, 1, locContentSize.height));
            return true;
        }
        locContext.font = this._fontStyleStr;
        this._updateTTF();
        var width = locContentSize.width, height = locContentSize.height;
        var flag = locLabelCanvas.width == width && locLabelCanvas.height == height;
        locLabelCanvas.width = width;
        locLabelCanvas.height = height;
        if (flag) locContext.clearRect(0, 0, width, height);
        this._drawTTFInCanvas(locContext);
        this._texture && this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, width, height));
        return true;
    },
    visit: function (ctx) {
        if (!this._string || this._string == "")
            return;
        if (this._needUpdateTexture) {
            this._needUpdateTexture = false;
            this._updateTexture();
        }
        var context = ctx || cc._renderContext;
        cc.Sprite.prototype.visit.call(this, context);
    },
    draw: null,
    _setTextureCoords: function (rect) {
        var tex = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!tex)
            return;
        var atlasWidth = tex.pixelsWidth;
        var atlasHeight = tex.pixelsHeight;
        var left, right, top, bottom, tempSwap, locQuad = this._quad;
        if (this._rectRotated) {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.height * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.width * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.height) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.width) / atlasHeight;
            }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL
            if (this._flippedX) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = top;
            locQuad.br.texCoords.u = left;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = right;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = bottom;
        } else {
            if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * rect.x + 1) / (2 * atlasWidth);
                right = left + (rect.width * 2 - 2) / (2 * atlasWidth);
                top = (2 * rect.y + 1) / (2 * atlasHeight);
                bottom = top + (rect.height * 2 - 2) / (2 * atlasHeight);
            } else {
                left = rect.x / atlasWidth;
                right = (rect.x + rect.width) / atlasWidth;
                top = rect.y / atlasHeight;
                bottom = (rect.y + rect.height) / atlasHeight;
            }
            if (this._flippedX) {
                tempSwap = left;
                left = right;
                right = tempSwap;
            }
            if (this._flippedY) {
                tempSwap = top;
                top = bottom;
                bottom = tempSwap;
            }
            locQuad.bl.texCoords.u = left;
            locQuad.bl.texCoords.v = bottom;
            locQuad.br.texCoords.u = right;
            locQuad.br.texCoords.v = bottom;
            locQuad.tl.texCoords.u = left;
            locQuad.tl.texCoords.v = top;
            locQuad.tr.texCoords.u = right;
            locQuad.tr.texCoords.v = top;
        }
        this._quadDirty = true;
    }
});
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LabelTTF.prototype;
    _p.setColor = function (color3) {
        cc.Node.prototype.setColor.call(this, color3);
        this._setColorsString();
    };
    _p._transformForRenderer = function(){
        if (this._needUpdateTexture) {
            this._needUpdateTexture = false;
            this._updateTexture();
        }
        cc.Node.prototype._transformForRenderer.call(this);
    };
    _p._setColorsString = function () {
        this._setUpdateTextureDirty();
        var locDisplayColor = this._displayedColor,
            locDisplayedOpacity = this._displayedOpacity,
            locShadowColor = this._shadowColor || this._displayedColor;
        var locStrokeColor = this._strokeColor, locFontFillColor = this._textFillColor;
        this._shadowColorStr = "rgba(" + (0 | (locShadowColor.r * 0.5)) + "," + (0 | (locShadowColor.g * 0.5)) + "," + (0 | (locShadowColor.b * 0.5)) + "," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | (locDisplayColor.r / 255 * locFontFillColor.r)) + "," + (0 | (locDisplayColor.g / 255 * locFontFillColor.g)) + ","
            + (0 | (locDisplayColor.b / 255 * locFontFillColor.b)) + ", " + locDisplayedOpacity / 255 + ")";
        this._strokeColorStr = "rgba(" + (0 | (locDisplayColor.r / 255 * locStrokeColor.r)) + "," + (0 | (locDisplayColor.g / 255 * locStrokeColor.g)) + ","
            + (0 | (locDisplayColor.b / 255 * locStrokeColor.b)) + ", " + locDisplayedOpacity / 255 + ")";
    };
    _p.updateDisplayedColor = function (parentColor) {
        cc.Node.prototype.updateDisplayedColor.call(this, parentColor);
        this._setColorsString();
    };
    _p.setOpacity = function (opacity) {
        if (this._opacity === opacity)
            return;
        cc.Sprite.prototype.setOpacity.call(this, opacity);
        this._setColorsString();
        this._setUpdateTextureDirty();
    };
    _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity;
    _p.initWithStringAndTextDefinition = function (text, textDefinition) {
        this._updateWithTextDefinition(textDefinition, false);
        this.string = text;
        return true;
    };
    _p.setFontFillColor = function (tintColor) {
        var locTextFillColor = this._textFillColor;
        if (locTextFillColor.r != tintColor.r || locTextFillColor.g != tintColor.g || locTextFillColor.b != tintColor.b) {
            locTextFillColor.r = tintColor.r;
            locTextFillColor.g = tintColor.g;
            locTextFillColor.b = tintColor.b;
            this._setColorsString();
            this._setUpdateTextureDirty();
        }
    };
    _p.draw = cc.Sprite.prototype.draw;
    _p.setTextureRect = function (rect, rotated, untrimmedSize) {
        this._rectRotated = rotated || false;
        untrimmedSize = untrimmedSize || rect;
        this.setContentSize(untrimmedSize);
        this.setVertexRect(rect);
        var locTextureCoordRect = this._rendererCmd._textureCoord;
        locTextureCoordRect.x = rect.x;
        locTextureCoordRect.y = rect.y;
        locTextureCoordRect.renderX = rect.x;
        locTextureCoordRect.renderY = rect.y;
        locTextureCoordRect.width = rect.width;
        locTextureCoordRect.height = rect.height;
        locTextureCoordRect.validRect = !(locTextureCoordRect.width === 0 || locTextureCoordRect.height === 0
            || locTextureCoordRect.x < 0 || locTextureCoordRect.y < 0);
        var relativeOffset = this._unflippedOffsetPositionFromCenter;
        if (this._flippedX)
            relativeOffset.x = -relativeOffset.x;
        if (this._flippedY)
            relativeOffset.y = -relativeOffset.y;
        this._offsetPosition.x = relativeOffset.x + (this._contentSize.width - this._rect.width) / 2;
        this._offsetPosition.y = relativeOffset.y + (this._contentSize.height - this._rect.height) / 2;
        if (this._batchNode) {
            this.dirty = true;
        }
    };
    _p = null;
} else {
    cc.assert(cc.isFunction(cc._tmp.WebGLLabelTTF), cc._LogInfos.MissingFile, "LabelTTFWebGL.js");
    cc._tmp.WebGLLabelTTF();
    delete cc._tmp.WebGLLabelTTF;
}
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = true;
cc.LabelTTF._wordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function (text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
    return new cc.LabelTTF(text, fontName, fontSize, dimensions, hAlignment, vAlignment);
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
if (cc.USE_LA88_LABELS)
    cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTURECOLOR;
else
    cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ?
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv) :
    cc._addEventListener(window, 'load', function () {
        this.removeEventListener('load', arguments.callee, false);
        document.body.appendChild(cc.LabelTTF.__labelHeightDiv);
    }, false);
cc.LabelTTF.__getFontHeightByDiv = function (fontName, fontSize) {
    var clientHeight = cc.LabelTTF.__fontHeightCache[fontName + "." + fontSize];
    if (clientHeight > 0) return clientHeight;
    var labelDiv = cc.LabelTTF.__labelHeightDiv;
    labelDiv.innerHTML = "ajghl~!";
    labelDiv.style.fontFamily = fontName;
    labelDiv.style.fontSize = fontSize + "px";
    clientHeight = labelDiv.clientHeight;
    cc.LabelTTF.__fontHeightCache[fontName + "." + fontSize] = clientHeight;
    labelDiv.innerHTML = "";
    return clientHeight;
};
cc.LabelTTF.__fontHeightCache = {};
var cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function (jsObj, superclass) {
};
cc.KEY = {
    backspace:8,
    tab:9,
    enter:13,
    shift:16,
    ctrl:17,
    alt:18,
    pause:19,
    capslock:20,
    escape:27,
    pageup:33,
    pagedown:34,
    end:35,
    home:36,
    left:37,
    up:38,
    right:39,
    down:40,
    insert:45,
    Delete:46,
    0:48,
    1:49,
    2:50,
    3:51,
    4:52,
    5:53,
    6:54,
    7:55,
    8:56,
    9:57,
    a:65,
    b:66,
    c:67,
    d:68,
    e:69,
    f:70,
    g:71,
    h:72,
    i:73,
    j:74,
    k:75,
    l:76,
    m:77,
    n:78,
    o:79,
    p:80,
    q:81,
    r:82,
    s:83,
    t:84,
    u:85,
    v:86,
    w:87,
    x:88,
    y:89,
    z:90,
    num0:96,
    num1:97,
    num2:98,
    num3:99,
    num4:100,
    num5:101,
    num6:102,
    num7:103,
    num8:104,
    num9:105,
    '*':106,
    '+':107,
    '-':109,
    'numdel':110,
    '/':111,
    f1:112,
    f2:113,
    f3:114,
    f4:115,
    f5:116,
    f6:117,
    f7:118,
    f8:119,
    f9:120,
    f10:121,
    f11:122,
    f12:123,
    numlock:144,
    scrolllock:145,
    semicolon:186,
    ',':186,
    equal:187,
    '=':187,
    ';':188,
    comma:188,
    dash:189,
    '.':190,
    period:190,
    forwardslash:191,
    grave:192,
    '[':219,
    openbracket:219,
    ']':221,
    closebracket:221,
    backslash:220,
    quote:222,
    space:32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function (imgData) {
    if (imgData.length > 8 && imgData[0] == 0x89
        && imgData[1] == 0x50
        && imgData[2] == 0x4E
        && imgData[3] == 0x47
        && imgData[4] == 0x0D
        && imgData[5] == 0x0A
        && imgData[6] == 0x1A
        && imgData[7] == 0x0A) {
        return cc.FMT_PNG;
    }
    if (imgData.length > 2 && ((imgData[0] == 0x49 && imgData[1] == 0x49)
        || (imgData[0] == 0x4d && imgData[1] == 0x4d)
        || (imgData[0] == 0xff && imgData[1] == 0xd8))) {
        return cc.FMT_TIFF;
    }
	return cc.FMT_UNKNOWN;
};
cc.inherits = function (childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
};
cc.base = function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
        ret = caller.superClass_.constructor.apply( me, Array.prototype.slice.call(arguments, 1));
        return ret;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
        if (ctor.prototype[opt_methodName] === caller) {
            foundCaller = true;
        } else if (foundCaller) {
            return ctor.prototype[opt_methodName].apply(me, args);
        }
    }
    if (me[opt_methodName] === caller) {
        return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
        throw Error(
            'cc.base called from a method of one name ' +
                'to a method of a different name');
    }
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    cc.rendererCanvas = {
        childrenOrderDirty: true,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToCanvasOn: false,
        _cacheToCanvasCmds: {},
        _cacheInstanceIds:[],
        _currentID: 0,
        rendering: function (ctx) {
            var locCmds = this._renderCmds,
                i,
                len,
                scaleX = cc.view.getScaleX(),
                scaleY = cc.view.getScaleY();
            var context = ctx || cc._renderContext;
            for (i = 0, len = locCmds.length; i < len; i++) {
                locCmds[i].rendering(context, scaleX, scaleY);
            }
        },
        _renderingToCacheCanvas: function (ctx, instanceID) {
            if (!ctx)
                cc.log("The context of RenderTexture is invalid.");
            instanceID = instanceID || this._currentID;
            var locCmds = this._cacheToCanvasCmds[instanceID], i, len;
            for (i = 0, len = locCmds.length; i < len; i++) {
                locCmds[i].rendering(ctx, 1, 1);
            }
            locCmds.length = 0;
            var locIDs = this._cacheInstanceIds;
            delete this._cacheToCanvasCmds[instanceID];
            cc.arrayRemoveObject(locIDs, instanceID);
            if (locIDs.length === 0)
                this._isCacheToCanvasOn = false;
            else
                this._currentID = locIDs[locIDs.length - 1];
        },
        _turnToCacheMode: function(renderTextureID){
            this._isCacheToCanvasOn = true;
            renderTextureID = renderTextureID || 0;
            this._cacheToCanvasCmds[renderTextureID] = [];
            this._cacheInstanceIds.push(renderTextureID);
            this._currentID = renderTextureID;
        },
        _turnToNormalMode: function(){
            this._isCacheToCanvasOn = false;
        },
        resetFlag: function () {
            this.childrenOrderDirty = false;
            this._transformNodePool.length = 0;
        },
        transform: function () {
            var locPool = this._transformNodePool;
            locPool.sort(this._sortNodeByLevelAsc);
            for (var i = 0, len = locPool.length; i < len; i++) {
                if (locPool[i]._renderCmdDiry)
                    locPool[i]._transformForRenderer();
            }
            locPool.length = 0;
        },
        transformDirty: function () {
            return this._transformNodePool.length > 0;
        },
        _sortNodeByLevelAsc: function (n1, n2) {
            return n1._curLevel - n2._curLevel;
        },
        pushDirtyNode: function (node) {
            this._transformNodePool.push(node);
        },
        clearRenderCommands: function () {
            this._renderCmds.length = 0;
        },
        pushRenderCommand: function (cmd) {
            if (this._isCacheToCanvasOn) {
                var currentId = this._currentID, locCmdBuffer = this._cacheToCanvasCmds;
                var cmdList = locCmdBuffer[currentId];
                if (cmdList.indexOf(cmd) === -1)
                    cmdList.push(cmd);
            } else {
                if (this._renderCmds.indexOf(cmd) === -1)
                    this._renderCmds.push(cmd);
            }
        }
    };
    cc.renderer = cc.rendererCanvas;
    cc.TextureRenderCmdCanvas = function (node) {
        this._node = node;
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: false
        };
    };
    cc.TextureRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var self = this,
            node = self._node;
        var context = ctx || cc._renderContext,
            locTextureCoord = self._textureCoord;
        if(node._texture && (locTextureCoord.width === 0 || locTextureCoord.height === 0))
            return;
        if (!locTextureCoord.validRect && node._displayedOpacity === 0)
            return;
        if(node._texture && !node._texture._isLoaded)
            return;
        var t = node._transformWorld,
            locX = node._offsetPosition.x,
            locY = -node._offsetPosition.y - node._rect.height,
            locWidth = node._rect.width,
            locHeight = node._rect.height,
            image, curColor, contentSize;
        var blendChange = (node._blendFuncStr !== "source"), alpha = (node._displayedOpacity / 255);
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1 || node._flippedX || node._flippedY) {
            context.save();
            context.globalAlpha = alpha;
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            if (blendChange)
                context.globalCompositeOperation = node._blendFuncStr;
            if (node._flippedX){
                locX = -locX - locWidth;
                context.scale(-1, 1);
            }
            if (node._flippedY){
                locY = node._offsetPosition.y;
                context.scale(1, -1);
            }
            if (node._texture) {
                image = node._texture._htmlElementObj;
                if (node._colorized) {
                    context.drawImage(image,
                        0,
                        0,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            locX * scaleX,
                            locY * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY
                    );
                } else {
                    context.drawImage(image,
                        locTextureCoord.renderX,
                        locTextureCoord.renderY,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            locX * scaleX,
                            locY * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY
                    );
                }
            } else {
                contentSize = node._contentSize;
                if(locTextureCoord.validRect) {
                    curColor = node._displayedColor;
                    context.fillStyle = "rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)";
                    context.fillRect(locX * scaleX, locY * scaleY, contentSize.width * scaleX, contentSize.height * scaleY);
                }
            }
            context.restore();
        } else {
            if (blendChange) {
                context.save();
                context.globalCompositeOperation = node._blendFuncStr;
            }
            context.globalAlpha = alpha;
            if (node._texture) {
                image = node._texture.getHtmlElementObj();
                if (node._colorized) {
                    context.drawImage(image,
                        0,
                        0,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            (t.tx + locX) * scaleX,
                            (-t.ty + locY) * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY);
                } else {
                    context.drawImage(
                        image,
                        locTextureCoord.renderX,
                        locTextureCoord.renderY,
                        locTextureCoord.width,
                        locTextureCoord.height,
                            (t.tx + locX) * scaleX,
                            (-t.ty + locY) * scaleY,
                            locWidth * scaleX,
                            locHeight * scaleY);
                }
            } else {
                contentSize = node._contentSize;
                if(locTextureCoord.validRect) {
                    curColor = node._displayedColor;
                    context.fillStyle = "rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)";
                    context.fillRect((t.tx + locX) * scaleX, (-t.ty + locY) * scaleY, contentSize.width * scaleX, contentSize.height * scaleY);
                }
            }
            if (blendChange)
                context.restore();
        }
        cc.g_NumberOfDraws++;
    };
    cc.RectRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.RectRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            node = this._node,
            t = node._transformWorld,
            curColor = node._displayedColor,
            opacity = node._displayedOpacity / 255,
            locWidth = node._contentSize.width,
            locHeight = node._contentSize.height;
        if (opacity === 0)
            return;
        var needTransform = (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1);
        var needRestore = (node._blendFuncStr !== "source") || needTransform;
        if (needRestore) {
            context.save();
            context.globalCompositeOperation = node._blendFuncStr;
        }
        context.globalAlpha = opacity;
        context.fillStyle = "rgba(" + (0 | curColor.r) + "," + (0 | curColor.g) + ","
            + (0 | curColor.b) + ", 1)";
        if (needTransform) {
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
        } else {
            context.fillRect(t.tx * scaleX, -t.ty * scaleY, locWidth * scaleX, -locHeight * scaleY);
        }
        if (needRestore)
            context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.GradientRectRenderCmdCanvas = function (node) {
        this._node = node;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._startStopStr = null;
        this._endStopStr = null;
    };
    cc.GradientRectRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            self = this,
            node = self._node,
            opacity = node._displayedOpacity / 255,
            t = node._transformWorld;
        if(opacity === 0)
            return;
        var needTransform = (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1);
        var needRestore = (node._blendFuncStr !== "source") || needTransform;
        if(needRestore){
            context.save();
            context.globalCompositeOperation = node._blendFuncStr;
        }
        context.globalAlpha = opacity;
        var locWidth = node._contentSize.width, locHeight = node._contentSize.height;
        var gradient = context.createLinearGradient(self._startPoint.x, self._startPoint.y, self._endPoint.x, self._endPoint.y);
        gradient.addColorStop(0, this._startStopStr);
        gradient.addColorStop(1, this._endStopStr);
        context.fillStyle = gradient;
        if(needTransform){
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            context.fillRect(0, 0, locWidth * scaleX, -locHeight * scaleY);
        } else
            context.fillRect(t.tx * scaleX, -t.ty * scaleY, locWidth * scaleX, -locHeight * scaleY);
        if(needRestore)
            context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.ParticleRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ParticleRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext,
            node = this._node,
            t = node._transformWorld,
            pointRect = node._pointRect;
        context.save();
        context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if (node.isBlendAdditive())
            context.globalCompositeOperation = 'lighter';
        else
            context.globalCompositeOperation = 'source-over';
        var i, particle, lpx, alpha;
        var particleCount = this._node.particleCount, particles = this._node._particles;
        if (cc.ParticleSystem.SHAPE_MODE == cc.ParticleSystem.TEXTURE_MODE) {
            if (!node._texture || !node._texture._isLoaded) {
                context.restore();
                return;
            }
            var element = node._texture.getHtmlElementObj();
            if (!element.width || !element.height) {
                context.restore();
                return;
            }
            var textureCache = cc.textureCache, drawElement = element;
            for (i = 0; i < particleCount; i++) {
                particle = particles[i];
                lpx = (0 | (particle.size * 0.5));
                alpha =  particle.color.a / 255;
                if(alpha === 0) continue;
                context.globalAlpha = alpha;
                context.save();
                context.translate((0 | particle.drawPos.x), -(0 | particle.drawPos.y));
                var size = Math.floor(particle.size / 4) * 4;
                var w = pointRect.width;
                var h = pointRect.height;
                context.scale(Math.max((1 / w) * size, 0.000001), Math.max((1 / h) * size, 0.000001));
                if (particle.rotation)
                    context.rotate(cc.degreesToRadians(particle.rotation));
                if (particle.isChangeColor) {
                    var cacheTextureForColor = textureCache.getTextureColors(element);
                    if (cacheTextureForColor) {
                        if (!cacheTextureForColor.tintCache) {
                            cacheTextureForColor.tintCache = cc.newElement('canvas');
                            cacheTextureForColor.tintCache.width = element.width;
                            cacheTextureForColor.tintCache.height = element.height;
                        }
                        cc.generateTintImage(element, cacheTextureForColor, particle.color, this._pointRect, cacheTextureForColor.tintCache);
                        drawElement = cacheTextureForColor.tintCache;
                    }
                }
                context.drawImage(drawElement, -(0 | (w / 2)), -(0 | (h / 2)));
                context.restore();
            }
        } else {
            var drawTool = cc._drawingUtil;
            for (i = 0; i < particleCount; i++) {
                particle = particles[i];
                lpx = (0 | (particle.size * 0.5));
                alpha =  particle.color.a / 255;
                if(alpha === 0) continue;
                context.globalAlpha = alpha;
                context.save();
                context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                if (cc.ParticleSystem.BALL_SHAPE == cc.ParticleSystem.STAR_SHAPE) {
                    if (particle.rotation)
                        context.rotate(cc.degreesToRadians(particle.rotation));
                    drawTool.drawStar(context, lpx, particle.color);
                } else
                    drawTool.drawColorBall(context, lpx, particle.color);
                context.restore();
            }
        }
        context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.ProgressRenderCmdCanvas = function (node) {
        this._PI180 = Math.PI / 180;
        this._node = node;
        this._sprite = null;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._barRect = cc.rect(0, 0, 0, 0);
        this._origin = cc.p(0, 0);
        this._radius = 0;
        this._startAngle = 270;
        this._endAngle = 270;
        this._counterClockWise = false;
    };
    cc.ProgressRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext, node = this._node, locSprite = this._sprite;
        var locTextureCoord = locSprite._rendererCmd._textureCoord, alpha = locSprite._displayedOpacity / 255;
        if(locTextureCoord.width === 0 || locTextureCoord.height === 0)
            return;
        if (!locSprite._texture || !locTextureCoord.validRect || alpha === 0)
            return;
        var t = node._transformWorld;
        context.save();
        context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if (locSprite._blendFuncStr != "source")
            context.globalCompositeOperation = locSprite._blendFuncStr;
        context.globalAlpha = alpha;
        var locRect = locSprite._rect, locOffsetPosition = locSprite._offsetPosition, locDrawSizeCanvas = locSprite._drawSize_Canvas;
        var flipXOffset = 0 | (locOffsetPosition.x), flipYOffset = -locOffsetPosition.y - locRect.height;
        locDrawSizeCanvas.width = locRect.width * scaleX;
        locDrawSizeCanvas.height = locRect.height * scaleY;
        if (locSprite._flippedX) {
            flipXOffset = -locOffsetPosition.x - locRect.width;
            context.scale(-1, 1);
        }
        if (locSprite._flippedY) {
            flipYOffset = locOffsetPosition.y;
            context.scale(1, -1);
        }
        flipXOffset *= scaleX;
        flipYOffset *= scaleY;
        if (this._type == cc.ProgressTimer.TYPE_BAR) {
            var locBarRect = this._barRect;
            context.beginPath();
            context.rect(locBarRect.x * scaleX, locBarRect.y * scaleY, locBarRect.width * scaleX, locBarRect.height * scaleY);
            context.clip();
            context.closePath();
        } else if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
            var locOriginX = this._origin.x * scaleX;
            var locOriginY = this._origin.y * scaleY;
            context.beginPath();
            context.arc(locOriginX, locOriginY, this._radius * scaleY, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise);
            context.lineTo(locOriginX, locOriginY);
            context.clip();
            context.closePath();
        }
        var image = locSprite._texture.getHtmlElementObj();
        context.drawImage(image,
            locTextureCoord.renderX,
            locTextureCoord.renderY,
            locTextureCoord.width,
            locTextureCoord.height,
            flipXOffset, flipYOffset,
            locDrawSizeCanvas.width,
            locDrawSizeCanvas.height
        );
        context.restore();
        cc.g_NumberOfDraws++;
    };
    cc.DrawNodeRenderCmdCanvas = function (node) {
        this._node = node;
        this._buffer = null;
        this._drawColor = null;
        this._blendFunc = null;
    };
    cc.DrawNodeRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var context = ctx || cc._renderContext, _t = this, node = _t._node;
        var alpha = node._displayedOpacity/255;
        if(alpha === 0)
            return;
        context.globalAlpha = alpha;
        var t = node._transformWorld;
        context.save();
        ctx.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        if ((_t._blendFunc && (_t._blendFunc.src == cc.SRC_ALPHA) && (_t._blendFunc.dst == cc.ONE)))
            context.globalCompositeOperation = 'lighter';
        var locBuffer = _t._buffer;
        for (var i = 0, len = locBuffer.length; i < len; i++) {
            var element = locBuffer[i];
            switch (element.type) {
                case cc.DrawNode.TYPE_DOT:
                    _t._drawDot(context, element, scaleX, scaleY);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    _t._drawSegment(context, element, scaleX, scaleY);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    _t._drawPoly(context, element, scaleX, scaleY);
                    break;
            }
        }
        context.restore();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawDot = function (ctx, element, scaleX, scaleY) {
        var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
        ctx.fillStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")";
        ctx.beginPath();
        ctx.arc(locPos.x * scaleX, -locPos.y * scaleY, locRadius * scaleX, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawSegment = function (ctx, element, scaleX, scaleY) {
        var locColor = element.lineColor;
        var locFrom = element.verts[0], locTo = element.verts[1];
        var locLineWidth = element.lineWidth, locLineCap = element.lineCap;
        ctx.strokeStyle = "rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")";
        ctx.lineWidth = locLineWidth * scaleX;
        ctx.beginPath();
        ctx.lineCap = locLineCap;
        ctx.moveTo(locFrom.x * scaleX, -locFrom.y * scaleY);
        ctx.lineTo(locTo.x * scaleX, -locTo.y * scaleY);
        ctx.stroke();
    };
    cc.DrawNodeRenderCmdCanvas.prototype._drawPoly = function (ctx, element, scaleX, scaleY) {
        var locVertices = element.verts, locLineCap = element.lineCap;
        var locFillColor = element.fillColor, locLineWidth = element.lineWidth;
        var locLineColor = element.lineColor, locIsClosePolygon = element.isClosePolygon;
        var locIsFill = element.isFill, locIsStroke = element.isStroke;
        if (locVertices == null)
            return;
        var firstPoint = locVertices[0];
        ctx.lineCap = locLineCap;
        if (locFillColor)
            ctx.fillStyle = "rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + ","
                + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")";
        if (locLineWidth)
            ctx.lineWidth = locLineWidth * scaleX;
        if (locLineColor)
            ctx.strokeStyle = "rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + ","
                + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")";
        ctx.beginPath();
        ctx.moveTo(firstPoint.x * scaleX, -firstPoint.y * scaleY);
        for (var i = 1, len = locVertices.length; i < len; i++)
            ctx.lineTo(locVertices[i].x * scaleX, -locVertices[i].y * scaleY);
        if (locIsClosePolygon)
            ctx.closePath();
        if (locIsFill)
            ctx.fill();
        if (locIsStroke)
            ctx.stroke();
    };
    cc.ClippingNodeSaveRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeSaveRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            var locCache = cc.ClippingNode._getSharedCache();
            var canvas = context.canvas;
            locCache.width = canvas.width;
            locCache.height = canvas.height;
            var locCacheCtx = locCache.getContext("2d");
            locCacheCtx.drawImage(canvas, 0, 0);
            context.save();
        } else {
            node.transform();
            var t = node._transformWorld;
            context.save();
            context.save();
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        }
    };
    cc.ClippingNodeClipRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeClipRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            context.globalCompositeOperation = node.inverted ? "destination-out" : "destination-in";
            var t = node._transformWorld;
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        } else {
            context.restore();
            if (node.inverted) {
                var canvas = context.canvas;
                context.save();
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.moveTo(0, 0);
                context.lineTo(0, canvas.height);
                context.lineTo(canvas.width, canvas.height);
                context.lineTo(canvas.width, 0);
                context.lineTo(0, 0);
                context.restore();
            }
            context.clip();
        }
    };
    cc.ClippingNodeRestoreRenderCmdCanvas = function (node) {
        this._node = node;
    };
    cc.ClippingNodeRestoreRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var locCache = cc.ClippingNode._getSharedCache();
        var context = ctx || cc._renderContext;
        if (node._clipElemType) {
            context.restore();
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.globalCompositeOperation = "destination-over";
            context.drawImage(locCache, 0, 0);
            context.restore();
        } else {
            context.restore();
        }
    };
    cc.PhysicsDebugNodeRenderCmdCanvas = function (node) {
        this._node = node;
        this._buffer = node._buffer;
    };
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var _node = this._node;
        if (!_node._space)
            return;
        _node._space.eachShape(cc.DrawShape.bind(_node));
        _node._space.eachConstraint(cc.DrawConstraint.bind(_node));
        cc.DrawNodeRenderCmdCanvas.prototype.rendering.call(this, ctx, scaleX, scaleY);
        _node.clear();
    };
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawDot = cc.DrawNodeRenderCmdCanvas.prototype._drawDot;
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawSegment = cc.DrawNodeRenderCmdCanvas.prototype._drawSegment;
    cc.PhysicsDebugNodeRenderCmdCanvas.prototype._drawPoly = cc.DrawNodeRenderCmdCanvas.prototype._drawPoly;
    cc.TMXLayerRenderCmdCanvas = function (tmxLayer) {
        this._node = tmxLayer;
        this._childrenRenderCmds = [];
    };
    cc.TMXLayerRenderCmdCanvas.prototype._copyRendererCmds = function (rendererCmds) {
        if (!rendererCmds)
            return;
        var locCacheCmds = this._childrenRenderCmds;
        locCacheCmds.length = 0;
        for (var i = 0, len = rendererCmds.length; i < len; i++) {
            locCacheCmds[i] = rendererCmds[i];
        }
    };
    cc.TMXLayerRenderCmdCanvas.prototype._renderingChildToCache = function (scaleX, scaleY) {
        var locNode = this._node;
        if (locNode._cacheDirty) {
            var locCacheCmds = this._childrenRenderCmds, locCacheContext = locNode._cacheContext, locCanvas = locNode._cacheCanvas;
            locCacheContext.save();
            locCacheContext.clearRect(0, 0, locCanvas.width, -locCanvas.height);
            var t = cc.affineTransformInvert(locNode._transformWorld);
            locCacheContext.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            for (var i = 0, len = locCacheCmds.length; i < len; i++) {
                locCacheCmds[i].rendering(locCacheContext, scaleX, scaleY);
                if (locCacheCmds[i]._node)
                    locCacheCmds[i]._node._cacheDirty = false;
            }
            locCacheContext.restore();
            locNode._cacheDirty = false;
        }
    };
    cc.TMXLayerRenderCmdCanvas.prototype.rendering = function (ctx, scaleX, scaleY) {
        var node = this._node;
        var alpha = node._displayedOpacity/255;
        if(alpha <= 0)
            return;
        this._renderingChildToCache(scaleX, scaleY);
        var context = ctx || cc._renderContext;
        context.globalAlpha = alpha;
        var posX = 0 | ( -node._anchorPointInPoints.x), posY = 0 | ( -node._anchorPointInPoints.y);
        var locCacheCanvas = node._cacheCanvas, t = node._transformWorld;
        if (locCacheCanvas && locCacheCanvas.width !== 0 && locCacheCanvas.height !== 0) {
            context.save();
            context.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
            var locCanvasHeight = locCacheCanvas.height * scaleY;
            if(node.layerOrientation === cc.TMX_ORIENTATION_HEX){
                var halfTileSize = node._mapTileSize.height * 0.5 * scaleY;
                context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height,
                    posX, -(posY + locCanvasHeight) + halfTileSize, locCacheCanvas.width * scaleX, locCanvasHeight);
            } else {
                context.drawImage(locCacheCanvas, 0, 0, locCacheCanvas.width, locCacheCanvas.height,
                    posX, -(posY + locCanvasHeight), locCacheCanvas.width * scaleX, locCanvasHeight);
            }
            context.restore();
        }
        cc.g_NumberOfDraws++;
    };
    cc.CustomRenderCmdCanvas = function(node, func){
        this._node = node;
        this._callback = func;
    };
    cc.CustomRenderCmdCanvas.prototype.rendering = function(ctx, scaleX, scaleY){
        if(!this._callback)
            return;
        this._callback.call(this._node, ctx, scaleX, scaleY);
    };
    cc.SkeletonRenderCmdCanvas = function(node){
        this._node = node;
    };
    cc.SkeletonRenderCmdCanvas.prototype.rendering = function(ctx, scaleX, scaleY){
        var node = this._node;
        ctx = ctx || cc._renderContext;
        if(!node._debugSlots && !node._debugBones){
            return;
        }
        var t = node._transformWorld;
        ctx.save();
        ctx.transform(t.a, t.c, t.b, t.d, t.tx * scaleX, -t.ty * scaleY);
        var locSkeleton = node._skeleton;
        var attachment,slot, i, n, drawingUtil = cc._drawingUtil;
        if (node._debugSlots) {
            drawingUtil.setDrawColor(0, 0, 255, 255);
            drawingUtil.setLineWidth(1);
            var points = [];
            for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                slot = locSkeleton.drawOrder[i];
                if (!slot.attachment || slot.attachment.type != sp.ATTACHMENT_TYPE.REGION)
                    continue;
                attachment = slot.attachment;
                sp._regionAttachment_updateSlotForCanvas(attachment, slot, points);
                drawingUtil.drawPoly(points, 4, true);
            }
        }
        if (node._debugBones) {
            var bone;
            drawingUtil.setLineWidth(2);
            drawingUtil.setDrawColor(255, 0, 0, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                var x = bone.data.length * bone.m00 + bone.worldX;
                var y = bone.data.length * bone.m10 + bone.worldY;
                drawingUtil.drawLine(
                    {x:bone.worldX, y:bone.worldY},
                    {x:x, y:y});
            }
            drawingUtil.setPointSize(4);
            drawingUtil.setDrawColor(0, 0, 255, 255);
            for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                bone = locSkeleton.bones[i];
                drawingUtil.drawPoint({x:bone.worldX, y:bone.worldY});
                if (i === 0)
                    drawingUtil.setDrawColor(0, 255, 0, 255);
            }
        }
        ctx.restore();
    };
}
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX != RotationY. Don't know which one to return",
    Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function (msg) {
    if (!cc._canvas)
        return;
    var logList = cc._logList;
    var doc = document;
    if (!logList) {
        var logDiv = doc.createElement("Div");
        var logDivStyle = logDiv.style;
        logDiv.setAttribute("id", "logInfoDiv");
        cc._canvas.parentNode.appendChild(logDiv);
        logDiv.setAttribute("width", "200");
        logDiv.setAttribute("height", cc._canvas.height);
        logDivStyle.zIndex = "99999";
        logDivStyle.position = "absolute";
        logDivStyle.top = "0";
        logDivStyle.left = "0";
        logList = cc._logList = doc.createElement("textarea");
        var logListStyle = logList.style;
        logList.setAttribute("rows", "20");
        logList.setAttribute("cols", "30");
        logList.setAttribute("disabled", true);
        logDiv.appendChild(logList);
        logListStyle.backgroundColor = "transparent";
        logListStyle.borderBottom = "1px solid #cccccc";
        logListStyle.borderRightWidth = "0px";
        logListStyle.borderLeftWidth = "0px";
        logListStyle.borderTopWidth = "0px";
        logListStyle.borderTopStyle = "none";
        logListStyle.borderRightStyle = "none";
        logListStyle.borderLeftStyle = "none";
        logListStyle.padding = "0px";
        logListStyle.margin = 0;
    }
    logList.value = logList.value + msg + "\r\n";
    logList.scrollTop = logList.scrollHeight;
};
cc._formatString = function (arg) {
    if (cc.isObject(arg)) {
        try {
            return JSON.stringify(arg);
        } catch (err) {
            return "";
        }
    } else
        return arg;
};
cc._initDebugSetting = function (mode) {
    var ccGame = cc.game;
    if(mode == ccGame.DEBUG_MODE_NONE)
        return;
    var locLog;
    if(mode > ccGame.DEBUG_MODE_ERROR){
        locLog = cc._logToWebPage.bind(cc);
        cc.error = function(){
            locLog("ERROR :  " + cc.formatStr.apply(cc, arguments));
        };
        cc.assert = function(cond, msg) {
            if (!cond && msg) {
                for (var i = 2; i < arguments.length; i++)
                    msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                locLog("Assert: " + msg);
            }
        };
        if(mode != ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE){
            cc.warn = function(){
                locLog("WARN :  " + cc.formatStr.apply(cc, arguments));
            };
        }
        if(mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE){
            cc.log = function(){
                locLog(cc.formatStr.apply(cc, arguments));
            };
        }
    } else {
        if(!console)
            return;
        cc.error = function(){
            return console.error.apply(console, arguments);
        };
        cc.assert = function (cond, msg) {
            if (!cond && msg) {
                for (var i = 2; i < arguments.length; i++)
                    msg = msg.replace(/(%s)|(%d)/, cc._formatString(arguments[i]));
                throw msg;
            }
        };
        if(mode != ccGame.DEBUG_MODE_ERROR)
            cc.warn = function(){
                return console.warn.apply(console, arguments);
            };
        if(mode == ccGame.DEBUG_MODE_INFO)
            cc.log = function(){
                return console.log.apply(console, arguments);
            };
    }
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.HashElement = cc.Class.extend({
    actions:null,
    target:null,
    actionIndex:0,
    currentAction:null,
    currentActionSalvaged:false,
    paused:false,
    hh:null,
    ctor:function () {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.currentActionSalvaged = false;
        this.paused = false;
        this.hh = null;
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets:null,
    _arrayTargets:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,
    _searchElementByTarget:function (arr, target) {
        for (var k = 0; k < arr.length; k++) {
            if (target == arr[k].target)
                return arr[k];
        }
        return null;
    },
    ctor:function () {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = false;
    },
    addAction:function (action, target, paused) {
        if(!action)
            throw "cc.ActionManager.addAction(): action must be non-null";
        if(!target)
            throw "cc.ActionManager.addAction(): action must be non-null";
        var element = this._hashTargets[target.__instanceId];
        if (!element) {
            element = new cc.HashElement();
            element.paused = paused;
            element.target = target;
            this._hashTargets[target.__instanceId] = element;
            this._arrayTargets.push(element);
        }
        this._actionAllocWithHashElement(element);
        element.actions.push(action);
        action.startWithTarget(target);
    },
    removeAllActions:function () {
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
            var element = locTargets[i];
            if (element)
                this.removeAllActionsFromTarget(element.target, true);
        }
    },
    removeAllActionsFromTarget:function (target, forceDelete) {
        if (target == null)
            return;
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            if (element.actions.indexOf(element.currentAction) !== -1 && !(element.currentActionSalvaged))
                element.currentActionSalvaged = true;
            element.actions.length = 0;
            if (this._currentTarget == element && !forceDelete) {
                this._currentTargetSalvaged = true;
            } else {
                this._deleteHashElement(element);
            }
        }
    },
    removeAction:function (action) {
        if (action == null)
            return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            for (var i = 0; i < element.actions.length; i++) {
                if (element.actions[i] == action) {
                    element.actions.splice(i, 1);
                    break;
                }
            }
        } else {
            cc.log(cc._LogInfos.ActionManager_removeAction);
        }
    },
    removeActionByTag:function (tag, target) {
        if(tag == cc.ACTION_TAG_INVALID)
            cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(target, cc._LogInfos.ActionManager_addAction);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            var limit = element.actions.length;
            for (var i = 0; i < limit; ++i) {
                var action = element.actions[i];
                if (action && action.getTag() === tag && action.getOriginalTarget() == target) {
                    this._removeActionAtIndex(i, element);
                    break;
                }
            }
        }
    },
    getActionByTag:function (tag, target) {
        if(tag == cc.ACTION_TAG_INVALID)
            cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
            if (element.actions != null) {
                for (var i = 0; i < element.actions.length; ++i) {
                    var action = element.actions[i];
                    if (action && action.getTag() === tag)
                        return action;
                }
            }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, tag);
        }
        return null;
    },
    numberOfRunningActionsInTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            return (element.actions) ? element.actions.length : 0;
        return 0;
    },
    pauseTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            element.paused = true;
    },
    resumeTarget:function (target) {
        var element = this._hashTargets[target.__instanceId];
        if (element)
            element.paused = false;
    },
    pauseAllRunningActions:function(){
        var idsWithActions = [];
        var locTargets = this._arrayTargets;
        for(var i = 0; i< locTargets.length; i++){
            var element = locTargets[i];
            if(element && !element.paused){
                element.paused = true;
                idsWithActions.push(element.target);
            }
        }
        return idsWithActions;
    },
    resumeTargets:function(targetsToResume){
        if(!targetsToResume)
            return;
        for(var i = 0 ; i< targetsToResume.length; i++){
            if(targetsToResume[i])
                this.resumeTarget(targetsToResume[i]);
        }
    },
    purgeSharedManager:function () {
        cc.director.getScheduler().unscheduleUpdateForTarget(this);
    },
    _removeActionAtIndex:function (index, element) {
        var action = element.actions[index];
        if ((action == element.currentAction) && (!element.currentActionSalvaged))
            element.currentActionSalvaged = true;
        element.actions.splice(index, 1);
        if (element.actionIndex >= index)
            element.actionIndex--;
        if (element.actions.length == 0) {
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            } else {
                this._deleteHashElement(element);
            }
        }
    },
    _deleteHashElement:function (element) {
        if (element) {
            delete this._hashTargets[element.target.__instanceId];
            cc.arrayRemoveObject(this._arrayTargets, element);
            element.actions = null;
            element.target = null;
        }
    },
    _actionAllocWithHashElement:function (element) {
        if (element.actions == null) {
            element.actions = [];
        }
    },
    update:function (dt) {
        var locTargets = this._arrayTargets , locCurrTarget;
        for (var elt = 0; elt < locTargets.length; elt++) {
            this._currentTarget = locTargets[elt];
            locCurrTarget = this._currentTarget;
            if (!locCurrTarget.paused) {
                for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length;
                     locCurrTarget.actionIndex++) {
                    locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                    if (!locCurrTarget.currentAction)
                        continue;
                    locCurrTarget.currentActionSalvaged = false;
                    locCurrTarget.currentAction.step(dt * ( locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1 ) );
                    if (locCurrTarget.currentActionSalvaged) {
                        locCurrTarget.currentAction = null;//release
                    } else if (locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        var action = locCurrTarget.currentAction;
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                    }
                    locCurrTarget.currentAction = null;
                }
            }
            if (this._currentTargetSalvaged && locCurrTarget.actions.length === 0) {
                this._deleteHashElement(locCurrTarget);
            }
        }
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget:null,
    target:null,
    tag:cc.ACTION_TAG_INVALID,
    ctor:function () {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.ACTION_TAG_INVALID;
    },
    copy:function () {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone();
    },
    clone:function () {
        var action = new cc.Action();
        action.originalTarget = null;
        action.target = null;
        action.tag = this.tag;
        return action;
    },
    isDone:function () {
        return true;
    },
    startWithTarget:function (target) {
        this.originalTarget = target;
        this.target = target;
    },
    stop:function () {
        this.target = null;
    },
    step:function (dt) {
        cc.log("[Action step]. override me");
    },
    update:function (dt) {
        cc.log("[Action update]. override me");
    },
    getTarget:function () {
        return this.target;
    },
    setTarget:function (target) {
        this.target = target;
    },
    getOriginalTarget:function () {
        return this.originalTarget;
    },
    setOriginalTarget:function (originalTarget) {
        this.originalTarget = originalTarget;
    },
    getTag:function () {
        return this.tag;
    },
    setTag:function (tag) {
        this.tag = tag;
    },
    retain:function () {
    },
    release:function () {
    }
});
cc.action = function () {
    return new cc.Action();
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration:0,
    ctor:function () {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0;
    },
    getDuration:function () {
        return this._duration * (this._times || 1);
    },
    setDuration:function (duration) {
        this._duration = duration;
    },
    reverse:function () {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null;
    },
    clone:function () {
        return new cc.FiniteTimeAction();
    }
});
cc.Speed = cc.Action.extend({
    _speed:0.0,
    _innerAction:null,
    ctor:function (action, speed) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
		action && this.initWithAction(action, speed);
    },
    getSpeed:function () {
        return this._speed;
    },
    setSpeed:function (speed) {
        this._speed = speed;
    },
    initWithAction:function (action, speed) {
        if(!action)
            throw "cc.Speed.initWithAction(): action must be non nil";
        this._innerAction = action;
        this._speed = speed;
        return true;
    },
    clone:function () {
        var action = new cc.Speed();
        action.initWithAction(this._innerAction.clone(), this._speed);
        return action;
    },
    startWithTarget:function (target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    step:function (dt) {
        this._innerAction.step(dt * this._speed);
    },
    isDone:function () {
        return this._innerAction.isDone();
    },
    reverse:function () {
        return new cc.Speed(this._innerAction.reverse(), this._speed);
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.speed = function (action, speed) {
    return new cc.Speed(action, speed);
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode:null,
    _boundarySet:false,
    _boundaryFullyCovered:false,
    _halfScreenSize:null,
    _fullScreenSize:null,
    _worldRect:null,
    leftBoundary:0.0,
    rightBoundary:0.0,
    topBoundary:0.0,
    bottomBoundary:0.0,
    ctor:function (followedNode, rect) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;
        this._halfScreenSize = null;
        this._fullScreenSize = null;
        this.leftBoundary = 0.0;
        this.rightBoundary = 0.0;
        this.topBoundary = 0.0;
        this.bottomBoundary = 0.0;
        this._worldRect = cc.rect(0, 0, 0, 0);
		if(followedNode)
			rect ? this.initWithTarget(followedNode, rect)
				 : this.initWithTarget(followedNode);
    },
    clone:function () {
        var action = new cc.Follow();
        var locRect = this._worldRect;
        var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
        action.initWithTarget(this._followedNode, rect);
        return action;
    },
    isBoundarySet:function () {
        return this._boundarySet;
    },
    setBoudarySet:function (value) {
        this._boundarySet = value;
    },
    initWithTarget:function (followedNode, rect) {
        if(!followedNode)
            throw "cc.Follow.initWithAction(): followedNode must be non nil";
        var _this = this;
        rect = rect || cc.rect(0, 0, 0, 0);
        _this._followedNode = followedNode;
        _this._worldRect = rect;
        _this._boundarySet = !cc._rectEqualToZero(rect);
        _this._boundaryFullyCovered = false;
        var winSize = cc.director.getWinSize();
        _this._fullScreenSize = cc.p(winSize.width, winSize.height);
        _this._halfScreenSize = cc.pMult(_this._fullScreenSize, 0.5);
        if (_this._boundarySet) {
            _this.leftBoundary = -((rect.x + rect.width) - _this._fullScreenSize.x);
            _this.rightBoundary = -rect.x;
            _this.topBoundary = -rect.y;
            _this.bottomBoundary = -((rect.y + rect.height) - _this._fullScreenSize.y);
            if (_this.rightBoundary < _this.leftBoundary) {
                _this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2;
            }
            if (_this.topBoundary < _this.bottomBoundary) {
                _this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2;
            }
            if ((_this.topBoundary == _this.bottomBoundary) && (_this.leftBoundary == _this.rightBoundary))
                _this._boundaryFullyCovered = true;
        }
        return true;
    },
    step:function (dt) {
        var tempPosX = this._followedNode.x;
        var tempPosY = this._followedNode.y;
        tempPosX = this._halfScreenSize.x - tempPosX;
        tempPosY = this._halfScreenSize.y - tempPosY;
        if (this._boundarySet) {
            if (this._boundaryFullyCovered)
                return;
	        this.target.setPosition(cc.clampf(tempPosX, this.leftBoundary, this.rightBoundary), cc.clampf(tempPosY, this.bottomBoundary, this.topBoundary));
        } else {
            this.target.setPosition(tempPosX, tempPosY);
        }
    },
    isDone:function () {
        return ( !this._followedNode.running );
    },
    stop:function () {
        this.target = null;
        cc.Action.prototype.stop.call(this);
    }
});
cc.follow = function (followedNode, rect) {
    return new cc.Follow(followedNode, rect);
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed:0,
    _firstTick:false,
    _easeList: null,
    _times:1,
    _repeatForever: false,
    _repeatMethod: false,//Compatible with repeat class, Discard after can be deleted
    _speed: 1,
    _speedMethod: false,//Compatible with speed class, Discard after can be deleted
    ctor:function (d) {
        this._speed = 1;
        this._times = 1;
        this._repeatForever = false;
        this.MAX_VALUE = 2;
        this._repeatMethod = false;//Compatible with repeat class, Discard after can be deleted
        this._speedMethod = false;//Compatible with repeat class, Discard after can be deleted
        cc.FiniteTimeAction.prototype.ctor.call(this);
		d !== undefined && this.initWithDuration(d);
    },
    getElapsed:function () {
        return this._elapsed;
    },
    initWithDuration:function (d) {
        this._duration = (d === 0) ? cc.FLT_EPSILON : d;
        this._elapsed = 0;
        this._firstTick = true;
        return true;
    },
    isDone:function () {
        return (this._elapsed >= this._duration);
    },
    _cloneDecoration: function(action){
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._times = this._times;
        action._easeList = this._easeList;
        action._speedMethod = this._speedMethod;
        action._repeatMethod = this._repeatMethod;
    },
    _reverseEaseList: function(action){
        if(this._easeList){
            action._easeList = [];
            for(var i=0; i<this._easeList.length; i++){
                action._easeList.push(this._easeList[i].reverse());
            }
        }
    },
    clone:function () {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action;
    },
    easing: function (easeObj) {
        if (this._easeList)
            this._easeList.length = 0;
        else
            this._easeList = [];
        for (var i = 0; i < arguments.length; i++)
            this._easeList.push(arguments[i]);
        return this;
    },
    _computeEaseTime: function (dt) {
        var locList = this._easeList;
        if ((!locList) || (locList.length === 0))
            return dt;
        for (var i = 0, n = locList.length; i < n; i++)
            dt = locList[i].easing(dt);
        return dt;
    },
    step:function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
        } else
            this._elapsed += dt;
        var t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
        t = (1 > t ? t : 1);
        this.update(t > 0 ? t : 0);
        if(this._repeatMethod && this._times > 1 && this.isDone()){
            if(!this._repeatForever){
                this._times--;
            }
            this.startWithTarget(this.target);
            this.step(this._elapsed - this._duration);
        }
    },
    startWithTarget:function (target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true;
    },
    reverse:function () {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null;
    },
    setAmplitudeRate:function (amp) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.");
    },
    getAmplitudeRate:function () {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0;
    },
    speed: function(speed){
        if(speed <= 0){
            cc.log("The speed parameter error");
            return this;
        }
        this._speedMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._speed *= speed;
        return this;
    },
    getSpeed: function(){
        return this._speed;
    },
    setSpeed: function(speed){
        this._speed = speed;
        return this;
    },
    repeat: function(times){
        times = Math.round(times);
        if(isNaN(times) || times < 1){
            cc.log("The repeat parameter error");
            return this;
        }
        this._repeatMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._times *= times;
        return this;
    },
    repeatForever: function(){
        this._repeatMethod = true;//Compatible with repeat class, Discard after can be deleted
        this._times = this.MAX_VALUE;
        this._repeatForever = true;
        return this;
    }
});
cc.actionInterval = function (d) {
    return new cc.ActionInterval(d);
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions:null,
    _split:null,
    _last:0,
    ctor:function (tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
		var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
		var last = paramArray.length - 1;
		if ((last >= 0) && (paramArray[last] == null))
			cc.log("parameters should not be ending with null in Javascript");
        if (last >= 0) {
            var prev = paramArray[0], action1;
            for (var i = 1; i < last; i++) {
                if (paramArray[i]) {
                    action1 = prev;
                    prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
                }
            }
            this.initWithTwoActions(prev, paramArray[last]);
        }
    },
    initWithTwoActions:function (actionOne, actionTwo) {
        if(!actionOne || !actionTwo)
            throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        var d = actionOne._duration + actionTwo._duration;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
    },
    clone:function () {
        var action = new cc.Sequence();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1;
    },
    stop:function () {
        if (this._last !== -1)
            this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var new_t, found = 0;
        var locSplit = this._split, locActions = this._actions, locLast = this._last;
        if (dt < locSplit) {
            new_t = (locSplit !== 0) ? dt / locSplit : 1;
            if (found === 0 && locLast === 1) {
                locActions[1].update(0);
                locActions[1].stop();
            }
        } else {
            found = 1;
            new_t = (locSplit === 1) ? 1 : (dt - locSplit) / (1 - locSplit);
            if (locLast === -1) {
                locActions[0].startWithTarget(this.target);
                locActions[0].update(1);
                locActions[0].stop();
            }
            if (!locLast) {
                locActions[0].update(1);
                locActions[0].stop();
            }
        }
        if (locLast === found && locActions[found].isDone())
            return;
        if (locLast !== found)
            locActions[found].startWithTarget(this.target);
        locActions[found].update(new_t);
        this._last = found;
    },
    reverse:function () {
        var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.sequence = function (tempArray) {
    var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
    if ((paramArray.length > 0) && (paramArray[paramArray.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i])
            prev = cc.Sequence._actionOneTwo(prev, paramArray[i]);
    }
    return prev;
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function (actionOne, actionTwo) {
    var sequence = new cc.Sequence();
    sequence.initWithTwoActions(actionOne, actionTwo);
    return sequence;
};
cc.Repeat = cc.ActionInterval.extend({
    _times:0,
    _total:0,
    _nextDt:0,
    _actionInstant:false,
    _innerAction:null,
    ctor: function (action, times) {
        cc.ActionInterval.prototype.ctor.call(this);
		times !== undefined && this.initWithAction(action, times);
    },
    initWithAction:function (action, times) {
        var duration = action._duration * times;
        if (this.initWithDuration(duration)) {
            this._times = times;
            this._innerAction = action;
            if (action instanceof cc.ActionInstant){
                this._actionInstant = true;
                this._times -= 1;
            }
            this._total = 0;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Repeat();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action;
    },
    startWithTarget:function (target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var locInnerAction = this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (dt >= locNextDt) {
            while (dt > locNextDt && this._total < locTimes) {
                locInnerAction.update(1);
                this._total++;
                locInnerAction.stop();
                locInnerAction.startWithTarget(this.target);
                locNextDt += locInnerAction._duration / locDuration;
                this._nextDt = locNextDt;
            }
            if (dt >= 1.0 && this._total < locTimes)
                this._total++;
            if (!this._actionInstant) {
                if (this._total === locTimes) {
                    locInnerAction.update(1);
                    locInnerAction.stop();
                } else {
                    locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
                }
            }
        } else {
            locInnerAction.update((dt * locTimes) % 1.0);
        }
    },
    isDone:function () {
        return this._total == this._times;
    },
    reverse:function () {
        var action = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.repeat = function (action, times) {
    return new cc.Repeat(action, times);
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction:null,
    ctor:function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
		action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.RepeatForever.initWithAction(): action must be non null";
        this._innerAction = action;
        return true;
    },
    clone:function () {
        var action = new cc.RepeatForever();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },
    step:function (dt) {
        var locInnerAction = this._innerAction;
        locInnerAction.step(dt);
        if (locInnerAction.isDone()) {
            locInnerAction.startWithTarget(this.target);
            locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
        }
    },
    isDone:function () {
        return false;
    },
    reverse:function () {
        var action = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },
    getInnerAction:function () {
        return this._innerAction;
    }
});
cc.repeatForever = function (action) {
    return new cc.RepeatForever(action);
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one:null,
    _two:null,
    ctor:function (tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._one = null;
        this._two = null;
		var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
		var last = paramArray.length - 1;
		if ((last >= 0) && (paramArray[last] == null))
			cc.log("parameters should not be ending with null in Javascript");
        if (last >= 0) {
            var prev = paramArray[0], action1;
            for (var i = 1; i < last; i++) {
                if (paramArray[i]) {
                    action1 = prev;
                    prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
                }
            }
            this.initWithTwoActions(prev, paramArray[last]);
        }
    },
    initWithTwoActions:function (action1, action2) {
        if(!action1 || !action2)
            throw "cc.Spawn.initWithTwoActions(): arguments must all be non null" ;
        var ret = false;
        var d1 = action1._duration;
        var d2 = action2._duration;
        if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;
            if (d1 > d2) {
                this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2));
            } else if (d1 < d2) {
                this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1));
            }
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.Spawn();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._one.clone(), this._two.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
    },
    stop:function () {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this._one)
            this._one.update(dt);
        if (this._two)
            this._two.update(dt);
    },
    reverse:function () {
        var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.spawn = function (tempArray) {
    var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
    if ((paramArray.length > 0) && (paramArray[paramArray.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i] != null)
            prev = cc.Spawn._actionOneTwo(prev, paramArray[i]);
    }
    return prev;
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function (action1, action2) {
    var pSpawn = new cc.Spawn();
    pSpawn.initWithTwoActions(action1, action2);
    return pSpawn;
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX:0,
    _startAngleX:0,
    _diffAngleX:0,
    _dstAngleY:0,
    _startAngleY:0,
    _diffAngleY:0,
    ctor:function (duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
    },
    initWithDuration:function (duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._dstAngleX = deltaAngleX || 0;
            this._dstAngleY = deltaAngleY || this._dstAngleX;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.RotateTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locStartAngleX = target.rotationX % 360.0;
        var locDiffAngleX = this._dstAngleX - locStartAngleX;
        if (locDiffAngleX > 180)
            locDiffAngleX -= 360;
        if (locDiffAngleX < -180)
            locDiffAngleX += 360;
        this._startAngleX = locStartAngleX;
        this._diffAngleX = locDiffAngleX;
        this._startAngleY = target.rotationY % 360.0;
        var locDiffAngleY = this._dstAngleY - this._startAngleY;
        if (locDiffAngleY > 180)
            locDiffAngleY -= 360;
        if (locDiffAngleY < -180)
            locDiffAngleY += 360;
        this._diffAngleY = locDiffAngleY;
    },
    reverse:function () {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.");
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
            this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
        }
    }
});
cc.rotateTo = function (duration, deltaAngleX, deltaAngleY) {
    return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX:0,
    _startAngleX:0,
    _angleY:0,
    _startAngleY:0,
    ctor: function (duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
    },
    initWithDuration:function (duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._angleX = deltaAngleX || 0;
            this._angleY = deltaAngleY || this._angleX;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.RotateBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._angleX, this._angleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngleX = target.rotationX;
        this._startAngleY = target.rotationY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.rotationX = this._startAngleX + this._angleX * dt;
            this.target.rotationY = this._startAngleY + this._angleY * dt;
        }
    },
    reverse:function () {
        var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.rotateBy = function (duration, deltaAngleX, deltaAngleY) {
    return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta:null,
    _startPosition:null,
    _previousPosition:null,
    ctor:function (duration, deltaPos, deltaY) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
		deltaPos !== undefined && this.initWithDuration(duration, deltaPos, deltaY);
    },
    initWithDuration:function (duration, position, y) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
	        if(position.x !== undefined) {
		        y = position.y;
		        position = position.x;
	        }
            this._positionDelta.x = position;
            this._positionDelta.y = y;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.MoveBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._positionDelta);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var x = this._positionDelta.x * dt;
            var y = this._positionDelta.y * dt;
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var action = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.moveBy = function (duration, deltaPos, deltaY) {
    return new cc.MoveBy(duration, deltaPos, deltaY);
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition:null,
    ctor:function (duration, position, y) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
		position !== undefined && this.initWithDuration(duration, position, y);
    },
    initWithDuration:function (duration, position, y) {
        if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
	        if(position.x !== undefined) {
		        y = position.y;
		        position = position.x;
	        }
            this._endPosition.x = position;
            this._endPosition.y = y;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.MoveTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition);
        return action;
    },
    startWithTarget:function (target) {
        cc.MoveBy.prototype.startWithTarget.call(this, target);
        this._positionDelta.x = this._endPosition.x - target.getPositionX();
        this._positionDelta.y = this._endPosition.y - target.getPositionY();
    }
});
cc.moveTo = function (duration, position, y) {
    return new cc.MoveTo(duration, position, y);
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX:0,
    _skewY:0,
    _startSkewX:0,
    _startSkewY:0,
    _endSkewX:0,
    _endSkewY:0,
    _deltaX:0,
    _deltaY:0,
    ctor: function (t, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
		sy !== undefined && this.initWithDuration(t, sx, sy);
    },
    initWithDuration:function (t, sx, sy) {
        var ret = false;
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._endSkewX = sx;
            this._endSkewY = sy;
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.SkewTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startSkewX = target.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        if (this._deltaX > 180)
            this._deltaX -= 360;
        if (this._deltaX < -180)
            this._deltaX += 360;
        this._startSkewY = target.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        if (this._deltaY > 180)
            this._deltaY -= 360;
        if (this._deltaY < -180)
            this._deltaY += 360;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this.target.skewX = this._startSkewX + this._deltaX * dt;
        this.target.skewY = this._startSkewY + this._deltaY * dt;
    }
});
cc.skewTo = function (t, sx, sy) {
    return new cc.SkewTo(t, sx, sy);
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
	ctor: function(t, sx, sy) {
		cc.SkewTo.prototype.ctor.call(this);
		sy !== undefined && this.initWithDuration(t, sx, sy);
	},
    initWithDuration:function (t, deltaSkewX, deltaSkewY) {
        var ret = false;
        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
            this._skewX = deltaSkewX;
            this._skewY = deltaSkewY;
            ret = true;
        }
        return ret;
    },
    clone:function () {
        var action = new cc.SkewBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._skewX, this._skewY);
        return action;
    },
    startWithTarget:function (target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
    },
    reverse:function () {
        var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.skewBy = function (t, sx, sy) {
    return new cc.SkewBy(t, sx, sy);
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition:null,
    _delta:null,
    _height:0,
    _jumps:0,
    _previousPosition:null,
    ctor:function (duration, position, y, height, jumps) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
		height !== undefined && this.initWithDuration(duration, position, y, height, jumps);
    },
    initWithDuration:function (duration, position, y, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
	        if (jumps === undefined) {
		        jumps = height;
		        height = y;
		        y = position.y;
		        position = position.x;
	        }
            this._delta.x = position;
            this._delta.y = y;
            this._height = height;
            this._jumps = jumps;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.JumpBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var frac = dt * this._jumps % 1.0;
            var y = this._height * 4 * frac * (1 - frac);
            y += this._delta.y * dt;
            var x = this._delta.x * dt;
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var action = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.jumpBy = function (duration, position, y, height, jumps) {
    return new cc.JumpBy(duration, position, y, height, jumps);
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition:null,
    ctor:function (duration, position, y, height, jumps) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        height !== undefined && this.initWithDuration(duration, position, y, height, jumps);
    },
    initWithDuration:function (duration, position, y, height, jumps) {
        if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
            if (jumps === undefined) {
                y = position.y;
                position = position.x;
            }
            this._endPosition.x = position;
            this._endPosition.y = y;
            return true;
        }
        return false;
    },
    startWithTarget:function (target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y;
    },
    clone:function () {
        var action = new cc.JumpTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action;
    }
});
cc.jumpTo = function (duration, position, y, height, jumps) {
    return new cc.JumpTo(duration, position, y, height, jumps);
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function (a, b, c, d, t) {
    return (Math.pow(1 - t, 3) * a +
        3 * t * (Math.pow(1 - t, 2)) * b +
        3 * Math.pow(t, 2) * (1 - t) * c +
        Math.pow(t, 3) * d );
};
cc.BezierBy = cc.ActionInterval.extend({
    _config:null,
    _startPosition:null,
    _previousPosition:null,
    ctor:function (t, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
		c && this.initWithDuration(t, c);
    },
    initWithDuration:function (t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._config = c;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.BezierBy();
        this._cloneDecoration(action);
        var newConfigs = [];
        for (var i = 0; i < this._config.length; i++) {
            var selConf = this._config[i];
            newConfigs.push(cc.p(selConf.x, selConf.y));
        }
        action.initWithDuration(this._duration, newConfigs);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            var locConfig = this._config;
            var xa = 0;
            var xb = locConfig[0].x;
            var xc = locConfig[1].x;
            var xd = locConfig[2].x;
            var ya = 0;
            var yb = locConfig[0].y;
            var yc = locConfig[1].y;
            var yd = locConfig[2].y;
            var x = cc.bezierAt(xa, xb, xc, xd, dt);
            var y = cc.bezierAt(ya, yb, yc, yd, dt);
            var locStartPosition = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var targetX = this.target.getPositionX();
                var targetY = this.target.getPositionY();
                var locPreviousPosition = this._previousPosition;
                locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                x = x + locStartPosition.x;
                y = y + locStartPosition.y;
	            locPreviousPosition.x = x;
	            locPreviousPosition.y = y;
	            this.target.setPosition(x, y);
            } else {
                this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
            }
        }
    },
    reverse:function () {
        var locConfig = this._config;
        var r = [
            cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])),
            cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])),
            cc.pNeg(locConfig[2]) ];
        var action = new cc.BezierBy(this._duration, r);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.bezierBy = function (t, c) {
    return new cc.BezierBy(t, c);
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig:null,
    ctor:function (t, c) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
		c && this.initWithDuration(t, c);
    },
    initWithDuration:function (t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._toConfig = c;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.BezierTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toConfig);
        return action;
    },
    startWithTarget:function (target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        var locStartPos = this._startPosition;
        var locToConfig = this._toConfig;
        var locConfig = this._config;
        locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
        locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
        locConfig[2] = cc.pSub(locToConfig[2], locStartPos);
    }
});
cc.bezierTo = function (t, c) {
    return new cc.BezierTo(t, c);
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX:1,
    _scaleY:1,
    _startScaleX:1,
    _startScaleY:1,
    _endScaleX:0,
    _endScaleY:0,
    _deltaX:0,
    _deltaY:0,
    ctor:function (duration, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
		sx !== undefined && this.initWithDuration(duration, sx, sy);
    },
    initWithDuration:function (duration, sx, sy) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._endScaleX = sx;
            this._endScaleY = (sy != null) ? sy : sx;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.ScaleTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.scaleX;
        this._startScaleY = target.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
            this.target.scaleX = this._startScaleX + this._deltaX * dt;
	        this.target.scaleY = this._startScaleY + this._deltaY * dt;
        }
    }
});
cc.scaleTo = function (duration, sx, sy) {
    return new cc.ScaleTo(duration, sx, sy);
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget:function (target) {
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
    },
    reverse:function () {
        var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.ScaleBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
    }
});
cc.scaleBy = function (duration, sx, sy) {
    return new cc.ScaleBy(duration, sx, sy);
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times:0,
    _originalState:false,
    ctor:function (duration, blinks) {
        cc.ActionInterval.prototype.ctor.call(this);
		blinks !== undefined && this.initWithDuration(duration, blinks);
    },
    initWithDuration:function (duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._times = blinks;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Blink();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._times);
        return action;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this.target && !this.isDone()) {
            var slice = 1.0 / this._times;
            var m = dt % slice;
            this.target.visible = (m > (slice / 2));
        }
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._originalState = target.visible;
    },
    stop:function () {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
    },
    reverse:function () {
        var action = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.blink = function (duration, blinks) {
    return new cc.Blink(duration, blinks);
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity:0,
    _fromOpacity:0,
    ctor:function (duration, opacity) {
        cc.ActionInterval.prototype.ctor.call(this);
		opacity !== undefined && this.initWithDuration(duration, opacity);
    },
    initWithDuration:function (duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._toOpacity = opacity;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.FadeTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    },
    update:function (time) {
        time = this._computeEaseTime(time);
        var fromOpacity = this._fromOpacity !== undefined ? this._fromOpacity : 255;
        this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.opacity;
    }
});
cc.fadeTo = function (duration, opacity) {
    return new cc.FadeTo(duration, opacity);
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor:function (duration) {
        cc.FadeTo.prototype.ctor.call(this);
        duration && this.initWithDuration(duration, 255);
    },
    reverse:function () {
        var action = new cc.FadeOut();
        action.initWithDuration(this._duration, 0);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.FadeIn();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    },
    startWithTarget:function (target) {
        if(this._reverseAction)
            this._toOpacity = this._reverseAction._fromOpacity;
        cc.FadeTo.prototype.startWithTarget.call(this, target);
    }
});
cc.fadeIn = function (duration) {
    return new cc.FadeIn(duration);
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor:function (duration) {
        cc.FadeTo.prototype.ctor.call(this);
        duration && this.initWithDuration(duration, 0);
    },
    reverse:function () {
        var action = new cc.FadeIn();
        action._reverseAction = this;
        action.initWithDuration(this._duration, 255);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.FadeOut();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
    }
});
cc.fadeOut = function (d) {
    return new cc.FadeOut(d);
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to:null,
    _from:null,
    ctor:function (duration, red, green, blue) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
		blue !== undefined && this.initWithDuration(duration, red, green, blue);
    },
    initWithDuration:function (duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._to = cc.color(red, green, blue);
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TintTo();
        this._cloneDecoration(action);
        var locTo = this._to;
        action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this.target.color;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var locFrom = this._from, locTo = this._to;
        if (locFrom) {
            this.target.color = cc.color(locFrom.r + (locTo.r - locFrom.r) * dt,
                                        locFrom.g + (locTo.g - locFrom.g) * dt,
	                                    locFrom.b + (locTo.b - locFrom.b) * dt);
        }
    }
});
cc.tintTo = function (duration, red, green, blue) {
    return new cc.TintTo(duration, red, green, blue);
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR:0,
    _deltaG:0,
    _deltaB:0,
    _fromR:0,
    _fromG:0,
    _fromB:0,
    ctor:function (duration, deltaRed, deltaGreen, deltaBlue) {
        cc.ActionInterval.prototype.ctor.call(this);
		deltaBlue !== undefined && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
    },
    initWithDuration:function (duration, deltaRed, deltaGreen, deltaBlue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._deltaR = deltaRed;
            this._deltaG = deltaGreen;
            this._deltaB = deltaBlue;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TintBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var color = target.color;
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this.target.color = cc.color(this._fromR + this._deltaR * dt,
                                    this._fromG + this._deltaG * dt,
                                    this._fromB + this._deltaB * dt);
    },
    reverse:function () {
        var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    }
});
cc.tintBy = function (duration, deltaRed, deltaGreen, deltaBlue) {
    return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update:function (dt) {},
    reverse:function () {
        var action = new cc.DelayTime(this._duration);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    clone:function () {
        var action = new cc.DelayTime();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration);
        return action;
    }
});
cc.delayTime = function (d) {
    return new cc.DelayTime(d);
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other:null,
    ctor:function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
		action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.ReverseTime.initWithAction(): action must be non null";
        if(action == this._other)
            throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
            this._other = action;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.ReverseTime();
        this._cloneDecoration(action);
        action.initWithAction(this._other.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (this._other)
            this._other.update(1 - dt);
    },
    reverse:function () {
        return this._other.clone();
    },
    stop:function () {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
    }
});
cc.reverseTime = function (action) {
    return new cc.ReverseTime(action);
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation:null,
    _nextFrame:0,
    _origFrame:null,
    _executedLoops:0,
    _splitTimes:null,
    ctor:function (animation) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
		animation && this.initWithAnimation(animation);
    },
    getAnimation:function () {
        return this._animation;
    },
    setAnimation:function (animation) {
        this._animation = animation;
    },
    initWithAnimation:function (animation) {
        if(!animation)
            throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var singleDuration = animation.getDuration();
        if (this.initWithDuration(singleDuration * animation.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(animation);
            this._origFrame = null;
            this._executedLoops = 0;
            var locTimes = this._splitTimes;
            locTimes.length = 0;
            var accumUnitsOfTime = 0;
            var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
            var frames = animation.getFrames();
            cc.arrayVerifyType(frames, cc.AnimationFrame);
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var value = (accumUnitsOfTime * newUnitOfTimeValue) / singleDuration;
                accumUnitsOfTime += frame.getDelayUnits();
                locTimes.push(value);
            }
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.Animate();
        this._cloneDecoration(action);
        action.initWithAnimation(this._animation.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        if (this._animation.getRestoreOriginalFrame())
            this._origFrame = target.displayFrame();
        this._nextFrame = 0;
        this._executedLoops = 0;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        if (dt < 1.0) {
            dt *= this._animation.getLoops();
            var loopNumber = 0 | dt;
            if (loopNumber > this._executedLoops) {
                this._nextFrame = 0;
                this._executedLoops++;
            }
            dt = dt % 1.0;
        }
        var frames = this._animation.getFrames();
        var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
        for (var i = this._nextFrame; i < numberOfFrames; i++) {
            if (locSplitTimes[i] <= dt) {
                this.target.setSpriteFrame(frames[i].getSpriteFrame());
                this._nextFrame = i + 1;
            } else {
                break;
            }
        }
    },
    reverse:function () {
        var locAnimation = this._animation;
        var oldArray = locAnimation.getFrames();
        var newArray = [];
        cc.arrayVerifyType(oldArray, cc.AnimationFrame);
        if (oldArray.length > 0) {
            for (var i = oldArray.length - 1; i >= 0; i--) {
                var element = oldArray[i];
                if (!element)
                    break;
                newArray.push(element.clone());
            }
        }
        var newAnim = new cc.Animation(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
        newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
        var action = new cc.Animate(newAnim);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
    },
    stop:function () {
        if (this._animation.getRestoreOriginalFrame() && this.target)
            this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this);
    }
});
cc.animate = function (animation) {
    return new cc.Animate(animation);
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action:null,
    _forcedTarget:null,
    ctor: function (target, action) {
        cc.ActionInterval.prototype.ctor.call(this);
		action && this.initWithTarget(target, action);
    },
    initWithTarget:function (target, action) {
        if (this.initWithDuration(action._duration)) {
            this._forcedTarget = target;
            this._action = action;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.TargetedAction();
        this._cloneDecoration(action);
        action.initWithTarget(this._forcedTarget, this._action.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget);
    },
    stop:function () {
        this._action.stop();
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        this._action.update(dt);
    },
    getForcedTarget:function () {
        return this._forcedTarget;
    },
    setForcedTarget:function (forcedTarget) {
        if (this._forcedTarget != forcedTarget)
            this._forcedTarget = forcedTarget;
    }
});
cc.targetedAction = function (target, action) {
    return new cc.TargetedAction(target, action);
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone:function () {
        return true;
    },
    step:function (dt) {
        this.update(1);
    },
    update:function (dt) {
    },
    reverse:function(){
        return this.clone();
    },
    clone:function(){
        return new cc.ActionInstant();
    }
});
cc.Show = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = true;
    },
    reverse:function () {
        return new cc.Hide();
    },
    clone:function(){
        return new cc.Show();
    }
});
cc.show = function () {
    return new cc.Show();
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = false;
    },
    reverse:function () {
        return new cc.Show();
    },
    clone:function(){
        return new cc.Hide();
    }
});
cc.hide = function () {
    return new cc.Hide();
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update:function (dt) {
        this.target.visible = !this.target.visible;
    },
    reverse:function () {
        return new cc.ToggleVisibility();
    },
    clone:function(){
        return new cc.ToggleVisibility();
    }
});
cc.toggleVisibility = function () {
    return new cc.ToggleVisibility();
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
     _isNeedCleanUp: true,
    ctor:function(isNeedCleanUp){
        cc.FiniteTimeAction.prototype.ctor.call(this);
	    isNeedCleanUp !== undefined && this.init(isNeedCleanUp);
    },
    update:function(dt){
        this.target.removeFromParent(this._isNeedCleanUp);
    },
    /**
     * Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it .
     * @param isNeedCleanUp
     * @returns {boolean}
     */
    init:function(isNeedCleanUp){
        this._isNeedCleanUp = isNeedCleanUp;
        return true;
    },
    reverse:function(){
        return new cc.RemoveSelf(this._isNeedCleanUp);
    },
    clone:function(){
        return new cc.RemoveSelf(this._isNeedCleanUp);
    }
});
cc.removeSelf = function(isNeedCleanUp){
    return new cc.RemoveSelf(isNeedCleanUp);
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX:false,
    ctor:function(flip){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = false;
		flip !== undefined && this.initWithFlipX(flip);
    },
    initWithFlipX:function (flip) {
        this._flippedX = flip;
        return true;
    },
    update:function (dt) {
        this.target.flippedX = this._flippedX;
    },
    reverse:function () {
        return new cc.FlipX(!this._flippedX);
    },
    clone:function(){
        var action = new cc.FlipX();
        action.initWithFlipX(this._flippedX);
        return action;
    }
});
cc.flipX = function (flip) {
    return new cc.FlipX(flip);
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY:false,
    ctor: function(flip){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = false;
		flip !== undefined && this.initWithFlipY(flip);
    },
    initWithFlipY:function (flip) {
        this._flippedY = flip;
        return true;
    },
    update:function (dt) {
        this.target.flippedY = this._flippedY;
    },
    reverse:function () {
        return new cc.FlipY(!this._flippedY);
    },
    clone:function(){
        var action = new cc.FlipY();
        action.initWithFlipY(this._flippedY);
        return action;
    }
});
cc.flipY = function (flip) {
    return new cc.FlipY(flip);
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
	_y: 0,
    ctor:function(pos, y){
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._x = 0;
	    this._y = 0;
		if (pos !== undefined) {
			if (pos.x !== undefined) {
				y = pos.y;
				pos = pos.x;
			}
			this.initWithPosition(pos, y);
		}
    },
    initWithPosition: function (x, y) {
        this._x = x;
        this._y = y;
        return true;
    },
    update:function (dt) {
        this.target.setPosition(this._x, this._y);
    },
    clone:function(){
        var action = new cc.Place();
        action.initWithPosition(this._x, this._y);
        return action;
    }
});
cc.place = function (pos, y) {
    return new cc.Place(pos, y);
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget:null,
    _callFunc:null,
    _function:null,
    _data:null,
    ctor:function(selector, selectorTarget, data){
        cc.FiniteTimeAction.prototype.ctor.call(this);
		if(selector !== undefined){
			if(selectorTarget === undefined)
				this.initWithFunction(selector);
			else this.initWithFunction(selector, selectorTarget, data);
		}
    },
    initWithFunction:function (selector, selectorTarget, data) {
	    if (selectorTarget) {
            this._data = data;
            this._callFunc = selector;
            this._selectorTarget = selectorTarget;
	    }
	    else if (selector)
		    this._function = selector;
        return true;
    },
    execute:function () {
        if (this._callFunc != null)
            this._callFunc.call(this._selectorTarget, this.target, this._data);
        else if(this._function)
            this._function.call(null, this.target);
    },
    update:function (dt) {
        this.execute();
    },
    getTargetCallback:function () {
        return this._selectorTarget;
    },
    setTargetCallback:function (sel) {
        if (sel != this._selectorTarget) {
            if (this._selectorTarget)
                this._selectorTarget = null;
            this._selectorTarget = sel;
        }
    },
    clone:function(){
       var action = new cc.CallFunc();
        if(this._selectorTarget){
             action.initWithFunction(this._callFunc,  this._selectorTarget, this._data)
        }else if(this._function){
             action.initWithFunction(this._function);
        }
        return action;
    }
});
cc.callFunc = function (selector, selectorTarget, data) {
    return new cc.CallFunc(selector, selectorTarget, data);
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig:0,
    _centerYOrig:0,
    _centerZOrig:0,
    _eyeXOrig:0,
    _eyeYOrig:0,
    _eyeZOrig:0,
    _upXOrig:0,
    _upYOrig:0,
    _upZOrig:0,
    ctor:function(){
        var _t = this;
        cc.ActionInterval.prototype.ctor.call(_t);
        _t._centerXOrig=0;
        _t._centerYOrig=0;
        _t._centerZOrig=0;
        _t._eyeXOrig=0;
        _t._eyeYOrig=0;
        _t._eyeZOrig=0;
        _t._upXOrig=0;
        _t._upYOrig=0;
        _t._upZOrig=0;
    },
    startWithTarget:function (target) {
        var _t = this;
        cc.ActionInterval.prototype.startWithTarget.call(_t, target);
        var camera = target.getCamera();
        var centerXYZ = camera.getCenter();
        _t._centerXOrig = centerXYZ.x;
        _t._centerYOrig = centerXYZ.y;
        _t._centerZOrig = centerXYZ.z;
        var eyeXYZ = camera.getEye();
        _t._eyeXOrig = eyeXYZ.x;
        _t._eyeYOrig = eyeXYZ.y;
        _t._eyeZOrig = eyeXYZ.z;
        var upXYZ = camera.getUp();
        _t._upXOrig = upXYZ.x;
        _t._upYOrig = upXYZ.y;
        _t._upZOrig = upXYZ.z;
    },
    clone:function(){
       return new cc.ActionCamera();
    },
    reverse:function () {
        return new cc.ReverseTime(this);
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0.0,
    _deltaRadius: 0.0,
    _angleZ: 0.0,
    _deltaAngleZ: 0.0,
    _angleX: 0.0,
    _deltaAngleX: 0.0,
    _radZ: 0.0,
    _radDeltaZ: 0.0,
    _radX: 0.0,
    _radDeltaX: 0.0,
    ctor:function(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX){
        cc.ActionCamera.prototype.ctor.call(this);
		deltaAngleX !== undefined && this.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX);
    },
    initWithDuration:function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            var _t = this;
            _t._radius = radius;
            _t._deltaRadius = deltaRadius;
            _t._angleZ = angleZ;
            _t._deltaAngleZ = deltaAngleZ;
            _t._angleX = angleX;
            _t._deltaAngleX = deltaAngleX;
            _t._radDeltaZ = cc.degreesToRadians(deltaAngleZ);
            _t._radDeltaX = cc.degreesToRadians(deltaAngleX);
            return true;
        }
        return false;
    },
    sphericalRadius:function () {
        var newRadius, zenith, azimuth;
        var camera = this.target.getCamera();
        var eyeXYZ = camera.getEye();
        var centerXYZ = camera.getCenter();
        var x = eyeXYZ.x - centerXYZ.x, y = eyeXYZ.y - centerXYZ.y, z = eyeXYZ.z - centerXYZ.z;
        var r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
        var s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if (s === 0.0)
            s = cc.FLT_EPSILON;
        if (r === 0.0)
            r = cc.FLT_EPSILON;
        zenith = Math.acos(z / r);
        if (x < 0)
            azimuth = Math.PI - Math.asin(y / s);
        else
            azimuth = Math.asin(y / s);
        newRadius = r / cc.Camera.getZEye();
        return {newRadius:newRadius, zenith:zenith, azimuth:azimuth};
    },
    startWithTarget:function (target) {
        var _t = this;
        cc.ActionInterval.prototype.startWithTarget.call(_t, target);
        var retValue = _t.sphericalRadius();
        if (isNaN(_t._radius))
            _t._radius = retValue.newRadius;
        if (isNaN(_t._angleZ))
            _t._angleZ = cc.radiansToDegrees(retValue.zenith);
        if (isNaN(_t._angleX))
            _t._angleX = cc.radiansToDegrees(retValue.azimuth);
        _t._radZ = cc.degreesToRadians(_t._angleZ);
        _t._radX = cc.degreesToRadians(_t._angleX);
    },
    clone:function(){
        var a = new cc.OrbitCamera(), _t = this;
        a.initWithDuration(_t._duration, _t._radius, _t._deltaRadius, _t._angleZ, _t._deltaAngleZ, _t._angleX, _t._deltaAngleX);
        return a;
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var r = (this._radius + this._deltaRadius * dt) * cc.Camera.getZEye();
        var za = this._radZ + this._radDeltaZ * dt;
        var xa = this._radX + this._radDeltaX * dt;
        var i = Math.sin(za) * Math.cos(xa) * r + this._centerXOrig;
        var j = Math.sin(za) * Math.sin(xa) * r + this._centerYOrig;
        var k = Math.cos(za) * r + this._centerZOrig;
        this.target.getCamera().setEye(i, j, k);
        this.target.setNodeDirty();
    }
});
cc.orbitCamera = function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    return new cc.OrbitCamera(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX);
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner:null,
    ctor: function (action) {
        cc.ActionInterval.prototype.ctor.call(this);
        action && this.initWithAction(action);
    },
    initWithAction:function (action) {
        if(!action)
            throw "cc.ActionEase.initWithAction(): action must be non nil";
        if (this.initWithDuration(action.getDuration())) {
            this._inner = action;
            return true;
        }
        return false;
    },
    clone:function(){
       var action = new cc.ActionEase();
        action.initWithAction(this._inner.clone());
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._inner.startWithTarget(this.target);
    },
    stop:function () {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this);
    },
    update:function (dt) {
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.ActionEase(this._inner.reverse());
    },
    getInnerAction:function(){
       return this._inner;
    }
});
cc.actionEase = function (action) {
    return new cc.ActionEase(action);
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate:0,
    ctor: function(action, rate){
        cc.ActionEase.prototype.ctor.call(this);
		rate !== undefined && this.initWithAction(action, rate);
    },
    setRate:function (rate) {
        this._rate = rate;
    },
    getRate:function () {
        return this._rate;
    },
    initWithAction:function (action, rate) {
        if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
            this._rate = rate;
            return true;
        }
        return false;
    },
    clone:function(){
        var action = new cc.EaseRateAction();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    },
    reverse:function () {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
    }
});
cc.easeRateAction = function (action, rate) {
    return new cc.EaseRateAction(action, rate);
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update:function (dt) {
        this._inner.update(Math.pow(dt, this._rate));
    },
    reverse:function () {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
    },
    clone:function(){
        var action = new cc.EaseIn();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    }
});
cc.EaseIn.create = function (action, rate) {
    return new cc.EaseIn(action, rate);
};
cc.easeIn = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            return Math.pow(dt, this._rate);
        },
        reverse: function(){
            return cc.easeIn(1 / this._rate);
        }
    };
};
cc.EaseOut = cc.EaseRateAction.extend({
    update:function (dt) {
        this._inner.update(Math.pow(dt, 1 / this._rate));
    },
    reverse:function () {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
    },
    clone:function(){
        var action = new cc.EaseOut();
        action.initWithAction(this._inner.clone(),this._rate);
        return action;
    }
});
cc.EaseOut.create = function (action, rate) {
    return new cc.EaseOut(action, rate);
};
cc.easeOut = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            return Math.pow(dt, 1 / this._rate);
        },
        reverse: function(){
            return cc.easeOut(1 / this._rate)
        }
    };
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update:function (dt) {
        dt *= 2;
        if (dt < 1)
            this._inner.update(0.5 * Math.pow(dt, this._rate));
        else
            this._inner.update(1.0 - 0.5 * Math.pow(2 - dt, this._rate));
    },
    clone:function(){
        var action = new cc.EaseInOut();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
    },
    reverse:function () {
        return new cc.EaseInOut(this._inner.reverse(), this._rate);
    }
});
cc.EaseInOut.create = function (action, rate) {
    return new cc.EaseInOut(action, rate);
};
cc.easeInOut = function (rate) {
    return {
        _rate: rate,
        easing: function (dt) {
            dt *= 2;
            if (dt < 1)
                return 0.5 * Math.pow(dt, this._rate);
            else
                return 1.0 - 0.5 * Math.pow(2 - dt, this._rate);
        },
        reverse: function(){
            return cc.easeInOut(this._rate);
        }
    };
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update:function (dt) {
        this._inner.update(dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1)));
    },
    reverse:function () {
        return new cc.EaseExponentialOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialIn.create = function (action) {
    return new cc.EaseExponentialIn(action);
};
cc._easeExponentialInObj = {
    easing: function(dt){
        return dt === 0 ? 0 : Math.pow(2, 10 * (dt - 1));
    },
    reverse: function(){
        return cc._easeExponentialOutObj;
    }
};
cc.easeExponentialIn = function(){
    return cc._easeExponentialInObj;
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update:function (dt) {
        this._inner.update(dt == 1 ? 1 : (-(Math.pow(2, -10 * dt)) + 1));
    },
    reverse:function () {
        return new cc.EaseExponentialIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialOut.create = function (action) {
    return new cc.EaseExponentialOut(action);
};
cc._easeExponentialOutObj = {
    easing: function(dt){
        return dt == 1 ? 1 : (-(Math.pow(2, -10 * dt)) + 1);
    },
    reverse: function(){
        return cc._easeExponentialInObj;
    }
};
cc.easeExponentialOut = function(){
    return cc._easeExponentialOutObj;
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update:function (dt) {
        if( dt != 1 && dt !== 0) {
            dt *= 2;
            if (dt < 1)
                dt = 0.5 * Math.pow(2, 10 * (dt - 1));
            else
                dt = 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
        }
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseExponentialInOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseExponentialInOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseExponentialInOut.create = function (action) {
    return new cc.EaseExponentialInOut(action);
};
cc._easeExponentialInOutObj = {
    easing: function(dt){
        if( dt !== 1 && dt !== 0) {
            dt *= 2;
            if (dt < 1)
                return 0.5 * Math.pow(2, 10 * (dt - 1));
            else
                return 0.5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
        }
        return dt;
    },
    reverse: function(){
        return cc._easeExponentialInOutObj;
    }
};
cc.easeExponentialInOut = function(){
    return cc._easeExponentialInOutObj;
};
cc.EaseSineIn = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseSineOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseSineIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseSineIn.create = function (action) {
    return new cc.EaseSineIn(action);
};
cc._easeSineInObj = {
    easing: function(dt){
        return (dt===0 || dt===1) ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
    },
    reverse: function(){
        return cc._easeSineOutObj;
    }
};
cc.easeSineIn = function(){
    return cc._easeSineInObj;
};
cc.EaseSineOut = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : Math.sin(dt * Math.PI / 2);
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseSineIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseSineOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseSineOut.create = function (action) {
    return new cc.EaseSineOut(action);
};
cc._easeSineOutObj = {
    easing: function(dt){
        return (dt===0 || dt==1) ? dt : Math.sin(dt * Math.PI / 2);
    },
    reverse: function(){
        return cc._easeSineInObj;
    }
};
cc.easeSineOut = function(){
    return cc._easeSineOutObj;
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update:function (dt) {
        dt = dt===0 || dt===1 ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
        this._inner.update(dt);
    },
    clone:function(){
        var action = new cc.EaseSineInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseSineInOut(this._inner.reverse());
    }
});
cc.EaseSineInOut.create = function (action) {
    return new cc.EaseSineInOut(action);
};
cc._easeSineInOutObj = {
    easing: function(dt){
        return (dt === 0 || dt === 1) ? dt : -0.5 * (Math.cos(Math.PI * dt) - 1);
    },
    reverse: function(){
        return cc._easeSineInOutObj;
    }
};
cc.easeSineInOut = function(){
    return cc._easeSineInOutObj;
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor:function(action, period){
        cc.ActionEase.prototype.ctor.call(this);
		action && this.initWithAction(action, period);
    },
    getPeriod:function () {
        return this._period;
    },
    setPeriod:function (period) {
        this._period = period;
    },
    initWithAction:function (action, period) {
        cc.ActionEase.prototype.initWithAction.call(this, action);
        this._period = (period == null) ? 0.3 : period;
        return true;
    },
    reverse:function () {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null;
    },
    clone:function(){
        var action = new cc.EaseElastic();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElastic.create = function (action, period) {
    return new cc.EaseElastic(action, period);
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        if (dt === 0 || dt === 1) {
            newT = dt;
        } else {
            var s = this._period / 4;
            dt = dt - 1;
            newT = -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period);
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticIn();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticIn.create = function (action, period) {
    return new cc.EaseElasticIn(action, period);
};
cc._easeElasticInObj = {
   easing:function(dt){
       if (dt === 0 || dt === 1)
           return dt;
       dt = dt - 1;
       return -Math.pow(2, 10 * dt) * Math.sin((dt - (0.3 / 4)) * Math.PI * 2 / 0.3);
   },
    reverse:function(){
        return cc._easeElasticOutObj;
    }
};
cc.easeElasticIn = function (period) {
    if(period && period !== 0.3){
        return {
            _period: period,
            easing: function (dt) {
                if (dt === 0 || dt === 1)
                    return dt;
                dt = dt - 1;
                return -Math.pow(2, 10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period);
            },
            reverse:function () {
                return cc.easeElasticOut(this._period);
            }
        };
    }
    return cc._easeElasticInObj;
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        if (dt === 0 || dt == 1) {
            newT = dt;
        } else {
            var s = this._period / 4;
            newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period) + 1;
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticOut.create = function (action, period) {
    return new cc.EaseElasticOut(action, period);
};
cc._easeElasticOutObj = {
    easing: function (dt) {
        return (dt === 0 || dt === 1) ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - (0.3 / 4)) * Math.PI * 2 / 0.3) + 1;
    },
    reverse:function(){
        return cc._easeElasticInObj;
    }
};
cc.easeElasticOut = function (period) {
    if(period && period !== 0.3){
        return {
            _period: period,
            easing: function (dt) {
                return (dt === 0 || dt === 1) ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - (this._period / 4)) * Math.PI * 2 / this._period) + 1;
            },
            reverse:function(){
                return cc.easeElasticIn(this._period);
            }
        };
    }
    return cc._easeElasticOutObj;
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update:function (dt) {
        var newT = 0;
        var locPeriod = this._period;
        if (dt === 0 || dt == 1) {
            newT = dt;
        } else {
            dt = dt * 2;
            if (!locPeriod)
                locPeriod = this._period = 0.3 * 1.5;
            var s = locPeriod / 4;
            dt = dt - 1;
            if (dt < 0)
                newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
            else
                newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1;
        }
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
    },
    clone:function(){
        var action = new cc.EaseElasticInOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
    }
});
cc.EaseElasticInOut.create = function (action, period) {
    return new cc.EaseElasticInOut(action, period);
};
cc.easeElasticInOut = function (period) {
    period = period || 0.3;
    return {
        _period: period,
        easing: function (dt) {
            var newT = 0;
            var locPeriod = this._period;
            if (dt === 0 || dt === 1) {
                newT = dt;
            } else {
                dt = dt * 2;
                if (!locPeriod)
                    locPeriod = this._period = 0.3 * 1.5;
                var s = locPeriod / 4;
                dt = dt - 1;
                if (dt < 0)
                    newT = -0.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod);
                else
                    newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * 0.5 + 1;
            }
            return newT;
        },
        reverse: function(){
            return cc.easeElasticInOut(this._period);
        }
    };
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime:function (time1) {
        if (time1 < 1 / 2.75) {
            return 7.5625 * time1 * time1;
        } else if (time1 < 2 / 2.75) {
            time1 -= 1.5 / 2.75;
            return 7.5625 * time1 * time1 + 0.75;
        } else if (time1 < 2.5 / 2.75) {
            time1 -= 2.25 / 2.75;
            return 7.5625 * time1 * time1 + 0.9375;
        }
        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + 0.984375;
    },
    clone:function(){
        var action = new cc.EaseBounce();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBounce(this._inner.reverse());
    }
});
cc.EaseBounce.create = function (action) {
    return new cc.EaseBounce(action);
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = 1 - this.bounceTime(1 - dt);
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseBounceOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBounceIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBounceIn.create = function (action) {
    return new cc.EaseBounceIn(action);
};
cc._bounceTime = function (time1) {
    if (time1 < 1 / 2.75) {
        return 7.5625 * time1 * time1;
    } else if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + 0.75;
    } else if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + 0.9375;
    }
    time1 -= 2.625 / 2.75;
    return 7.5625 * time1 * time1 + 0.984375;
};
cc._easeBounceInObj = {
    easing: function(dt){
        return 1 - cc._bounceTime(1 - dt);
    },
    reverse: function(){
        return cc._easeBounceOutObj;
    }
};
cc.easeBounceIn = function(){
    return cc._easeBounceInObj;
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = this.bounceTime(dt);
        this._inner.update(newT);
    },
    reverse:function () {
        return new cc.EaseBounceIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBounceOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBounceOut.create = function (action) {
    return new cc.EaseBounceOut(action);
};
cc._easeBounceOutObj = {
    easing: function(dt){
        return cc._bounceTime(dt);
    },
    reverse:function () {
        return cc._easeBounceInObj;
    }
};
cc.easeBounceOut = function(){
    return cc._easeBounceOutObj;
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update:function (dt) {
        var newT = 0;
        if (dt < 0.5) {
            dt = dt * 2;
            newT = (1 - this.bounceTime(1 - dt)) * 0.5;
        } else {
            newT = this.bounceTime(dt * 2 - 1) * 0.5 + 0.5;
        }
        this._inner.update(newT);
    },
    clone:function(){
        var action = new cc.EaseBounceInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBounceInOut(this._inner.reverse());
    }
});
cc.EaseBounceInOut.create = function (action) {
    return new cc.EaseBounceInOut(action);
};
cc._easeBounceInOutObj = {
    easing: function (time1) {
        var newT;
        if (time1 < 0.5) {
            time1 = time1 * 2;
            newT = (1 - cc._bounceTime(1 - time1)) * 0.5;
        } else {
            newT = cc._bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
        }
        return newT;
    },
    reverse: function(){
        return cc._easeBounceInOutObj;
    }
};
cc.easeBounceInOut = function(){
    return cc._easeBounceInOutObj;
};
cc.EaseBackIn = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158;
        dt = dt===0 || dt==1 ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
        this._inner.update(dt);
    },
    reverse:function () {
        return new cc.EaseBackOut(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBackIn();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBackIn.create = function (action) {
    return new cc.EaseBackIn(action);
};
cc._easeBackInObj = {
    easing: function (time1) {
        var overshoot = 1.70158;
        return (time1===0 || time1===1) ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
    },
    reverse: function(){
        return cc._easeBackOutObj;
    }
};
cc.easeBackIn = function(){
    return cc._easeBackInObj;
};
cc.EaseBackOut = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158;
        dt = dt - 1;
        this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) + 1);
    },
    reverse:function () {
        return new cc.EaseBackIn(this._inner.reverse());
    },
    clone:function(){
        var action = new cc.EaseBackOut();
        action.initWithAction(this._inner.clone());
        return action;
    }
});
cc.EaseBackOut.create = function (action) {
    return new cc.EaseBackOut(action);
};
cc._easeBackOutObj = {
    easing: function (time1) {
        var overshoot = 1.70158;
        time1 = time1 - 1;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
    },
    reverse: function(){
        return cc._easeBackInObj;
    }
};
cc.easeBackOut = function(){
    return cc._easeBackOutObj;
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update:function (dt) {
        var overshoot = 1.70158 * 1.525;
        dt = dt * 2;
        if (dt < 1) {
            this._inner.update((dt * dt * ((overshoot + 1) * dt - overshoot)) / 2);
        } else {
            dt = dt - 2;
            this._inner.update((dt * dt * ((overshoot + 1) * dt + overshoot)) / 2 + 1);
        }
    },
    clone:function(){
        var action = new cc.EaseBackInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse:function () {
        return new cc.EaseBackInOut(this._inner.reverse());
    }
});
cc.EaseBackInOut.create = function (action) {
    return new cc.EaseBackInOut(action);
};
cc._easeBackInOutObj = {
    easing: function (time1) {
        var overshoot = 1.70158 * 1.525;
        time1 = time1 * 2;
        if (time1 < 1) {
            return (time1 * time1 * ((overshoot + 1) * time1 - overshoot)) / 2;
        } else {
            time1 = time1 - 2;
            return (time1 * time1 * ((overshoot + 1) * time1 + overshoot)) / 2 + 1;
        }
    },
    reverse: function(){
        return cc._easeBackInOutObj;
    }
};
cc.easeBackInOut = function(){
    return cc._easeBackInOutObj;
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(action){
        cc.ActionEase.prototype.ctor.call(this, action);
    },
    _updateTime: function(a, b, c, d, t){
        return (Math.pow(1-t,3) * a + 3*t*(Math.pow(1-t,2))*b + 3*Math.pow(t,2)*(1-t)*c + Math.pow(t,3)*d );
    },
    update: function(dt){
        var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, dt);
        this._inner.update(t);
    },
    clone: function(){
        var action = new cc.EaseBezierAction();
        action.initWithAction(this._inner.clone());
        action.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return action;
    },
    reverse: function(){
        var action = new cc.EaseBezierAction(this._inner.reverse());
        action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return action;
    },
    setBezierParamer: function(p0, p1, p2, p3){
        this._p0 = p0 || 0;
        this._p1 = p1 || 0;
        this._p2 = p2 || 0;
        this._p3 = p3 || 0;
    }
});
cc.EaseBezierAction.create = function(action){
    return new cc.EaseBezierAction(action);
};
cc.easeBezierAction = function(p0, p1, p2, p3){
    return {
        easing: function(time){
            return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time);
        },
        reverse: function(){
            return cc.easeBezierAction(p3, p2, p1, p0);
        }
    };
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return Math.pow(time, 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionIn(this._inner.reverse());
    }
});
cc.EaseQuadraticActionIn.create = function(action){
    return new cc.EaseQuadraticActionIn(action);
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionIn;
    }
};
cc.easeQuadraticActionIn = function(){
    return cc._easeQuadraticActionIn;
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        return -time*(time-2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionOut();
        action.initWithAction();
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionOut(this._inner.reverse());
    }
});
cc.EaseQuadraticActionOut.create = function(action){
    return new cc.EaseQuadraticActionOut(action);
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionOut;
    }
};
cc.easeQuadraticActionOut = function(){
    return cc._easeQuadraticActionOut;
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        var resultTime = time;
        time *= 2;
        if(time < 1){
            resultTime = time * time * 0.5;
        }else{
            --time;
            resultTime = -0.5 * ( time * ( time - 2 ) - 1)
        }
        return resultTime;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuadraticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuadraticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuadraticActionInOut.create = function(action){
    return new cc.EaseQuadraticActionInOut(action);
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuadraticActionInOut;
    }
};
cc.easeQuadraticActionInOut = function(){
    return cc._easeQuadraticActionInOut;
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionIn(this._inner.reverse());
    }
});
cc.EaseQuarticActionIn.create = function(action){
    return new cc.EaseQuarticActionIn(action);
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionIn;
    }
};
cc.easeQuarticActionIn = function(){
    return cc._easeQuarticActionIn;
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -= 1;
        return -(time * time * time * time - 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionOut(this._inner.reverse());
    }
});
cc.EaseQuarticActionOut.create = function(action){
    return new cc.EaseQuarticActionOut(action);
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionOut;
    }
};
cc.easeQuarticActionOut = function(){
    return cc._easeQuarticActionOut;
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time * time;
        time -= 2;
        return -0.5 * (time * time * time * time - 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuarticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuarticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuarticActionInOut.create = function(action){
    return new cc.EaseQuarticActionInOut(action);
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuarticActionInOut;
    }
};
cc.easeQuarticActionInOut = function(){
    return cc._easeQuarticActionInOut;
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionIn(this._inner.reverse());
    }
});
cc.EaseQuinticActionIn.create = function(action){
    return new cc.EaseQuinticActionIn(action);
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionIn;
    }
};
cc.easeQuinticActionIn = function(){
    return cc._easeQuinticActionIn;
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -=1;
        return (time * time * time * time * time + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionOut(this._inner.reverse());
    }
});
cc.EaseQuinticActionOut.create = function(action){
    return new cc.EaseQuinticActionOut(action);
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionOut;
    }
};
cc.easeQuinticActionOut = function(){
    return cc._easeQuinticActionOut;
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time * time * time;
        time -= 2;
        return 0.5 * (time * time * time * time * time + 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseQuinticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseQuinticActionInOut(this._inner.reverse());
    }
});
cc.EaseQuinticActionInOut.create = function(action){
    return new cc.EaseQuinticActionInOut(action);
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeQuinticActionInOut;
    }
};
cc.easeQuinticActionInOut = function(){
    return cc._easeQuinticActionInOut;
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return -1 * (Math.sqrt(1 - time * time) - 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionIn(this._inner.reverse());
    }
});
cc.EaseCircleActionIn.create = function(action){
    return new cc.EaseCircleActionIn(action);
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionIn;
    }
};
cc.easeCircleActionIn = function(){
    return cc._easeCircleActionIn;
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time - 1;
        return Math.sqrt(1 - time * time);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionOut(this._inner.reverse());
    }
});
cc.EaseCircleActionOut.create = function(action){
    return new cc.EaseCircleActionOut(action);
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionOut;
    }
};
cc.easeCircleActionOut = function(){
    return cc._easeCircleActionOut;
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time * 2;
        if (time < 1)
            return -0.5 * (Math.sqrt(1 - time * time) - 1);
        time -= 2;
        return 0.5 * (Math.sqrt(1 - time * time) + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCircleActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCircleActionInOut(this._inner.reverse());
    }
});
cc.EaseCircleActionInOut.create = function(action){
    return new cc.EaseCircleActionInOut(action);
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCircleActionInOut;
    }
};
cc.easeCircleActionInOut = function(){
    return cc._easeCircleActionInOut;
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(time){
        return time * time * time;
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionIn();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionIn(this._inner.reverse());
    }
});
cc.EaseCubicActionIn.create = function(action){
    return new cc.EaseCubicActionIn(action);
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionIn;
    }
};
cc.easeCubicActionIn = function(){
    return cc._easeCubicActionIn;
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time -= 1;
        return (time * time * time + 1);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionOut(this._inner.reverse());
    }
});
cc.EaseCubicActionOut.create = function(action){
    return new cc.EaseCubicActionOut(action);
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionOut;
    }
};
cc.easeCubicActionOut = function(){
    return cc._easeCubicActionOut;
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(time){
        time = time*2;
        if (time < 1)
            return 0.5 * time * time * time;
        time -= 2;
        return 0.5 * (time * time * time + 2);
    },
    update: function(dt){
        this._inner.update(this._updateTime(dt));
    },
    clone: function(){
        var action = new cc.EaseCubicActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
    },
    reverse: function(){
        return new cc.EaseCubicActionInOut(this._inner.reverse());
    }
});
cc.EaseCubicActionInOut.create = function(action){
    return new cc.EaseCubicActionInOut(action);
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function(){
        return cc._easeCubicActionInOut;
    }
};
cc.easeCubicActionInOut = function(){
    return cc._easeCubicActionInOut;
};
cc.cardinalSplineAt = function (p0, p1, p2, p3, tension, t) {
    var t2 = t * t;
    var t3 = t2 * t;
    var s = (1 - tension) / 2;
    var b1 = s * ((-t3 + (2 * t2)) - t);
    var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
    var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
    var b4 = s * (t3 - t2);
    var x = (p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4);
    var y = (p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4);
    return cc.p(x, y);
};
cc.reverseControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = controlPoints.length - 1; i >= 0; i--) {
        newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    }
    return newArray;
};
cc.cloneControlPoints = function (controlPoints) {
    var newArray = [];
    for (var i = 0; i < controlPoints.length; i++)
        newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
    return newArray;
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function (controlPoints, pos) {
    var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
    return controlPoints[p];
};
cc.reverseControlPointsInline = function (controlPoints) {
    var len = controlPoints.length;
    var mid = 0 | (len / 2);
    for (var i = 0; i < mid; ++i) {
        var temp = controlPoints[i];
        controlPoints[i] = controlPoints[len - i - 1];
        controlPoints[len - i - 1] = temp;
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points:null,
    _deltaT:0,
    _tension:0,
    _previousPosition:null,
    _accumulatedDiff:null,
    ctor: function (duration, points, tension) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
		tension !== undefined && this.initWithDuration(duration, points, tension);
    },
    initWithDuration:function (duration, points, tension) {
        if(!points || points.length == 0)
            throw "Invalid configuration. It must at least have one control point";
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this.setPoints(points);
            this._tension = tension;
            return true;
        }
        return false;
    },
    clone:function () {
        var action = new cc.CardinalSplineTo();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return action;
    },
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0);
    },
    update:function (dt) {
        dt = this._computeEaseTime(dt);
        var p, lt;
        var ps = this._points;
        if (dt == 1) {
            p = ps.length - 1;
            lt = 1;
        } else {
            var locDT = this._deltaT;
            p = 0 | (dt / locDT);
            lt = (dt - locDT * p) / locDT;
        }
        var newPos = cc.cardinalSplineAt(
            cc.getControlPointAt(ps, p - 1),
            cc.getControlPointAt(ps, p - 0),
            cc.getControlPointAt(ps, p + 1),
            cc.getControlPointAt(ps, p + 2),
            this._tension, lt);
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var tempX, tempY;
            tempX = this.target.getPositionX() - this._previousPosition.x;
            tempY = this.target.getPositionY() - this._previousPosition.y;
            if (tempX != 0 || tempY != 0) {
                var locAccDiff = this._accumulatedDiff;
                tempX = locAccDiff.x + tempX;
                tempY = locAccDiff.y + tempY;
                locAccDiff.x = tempX;
                locAccDiff.y = tempY;
                newPos.x += tempX;
                newPos.y += tempY;
            }
        }
        this.updatePosition(newPos);
    },
    reverse:function () {
        var reversePoints = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
    },
    updatePosition:function (newPos) {
        this.target.setPosition(newPos);
        this._previousPosition = newPos;
    },
    getPoints:function () {
        return this._points;
    },
    setPoints:function (points) {
        this._points = points;
    }
});
cc.cardinalSplineTo = function (duration, points, tension) {
    return new cc.CardinalSplineTo(duration, points, tension);
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition:null,
    ctor:function (duration, points, tension) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
		tension !== undefined && this.initWithDuration(duration, points, tension);
    },
    startWithTarget:function (target) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
        this._startPosition.x = target.getPositionX();
        this._startPosition.y = target.getPositionY();
    },
    reverse:function () {
        var copyConfig = this._points.slice();
        var current;
        var p = copyConfig[0];
        for (var i = 1; i < copyConfig.length; ++i) {
            current = copyConfig[i];
            copyConfig[i] = cc.pSub(current, p);
            p = current;
        }
        var reverseArray = cc.reverseControlPoints(copyConfig);
        p = reverseArray[ reverseArray.length - 1 ];
        reverseArray.pop();
        p.x = -p.x;
        p.y = -p.y;
        reverseArray.unshift(p);
        for (var i = 1; i < reverseArray.length; ++i) {
            current = reverseArray[i];
            current.x = -current.x;
            current.y = -current.y;
            current.x += p.x;
            current.y += p.y;
            reverseArray[i] = current;
            p = current;
        }
        return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
    },
    updatePosition:function (newPos) {
        var pos = this._startPosition;
        var posX = newPos.x + pos.x;
        var posY = newPos.y + pos.y;
	    this._previousPosition.x = posX;
	    this._previousPosition.y = posY;
	    this.target.setPosition(posX, posY);
    },
    clone:function () {
        var a = new cc.CardinalSplineBy();
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a;
    }
});
cc.cardinalSplineBy = function (duration, points, tension) {
    return new cc.CardinalSplineBy(duration, points, tension);
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
	ctor: function(dt, points) {
		points && this.initWithDuration(dt, points);
	},
    initWithDuration:function (dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5);
    },
    clone:function () {
        var action = new cc.CatmullRomTo();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return action;
    }
});
cc.catmullRomTo = function (dt, points) {
    return new cc.CatmullRomTo(dt, points);
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
	ctor: function(dt, points) {
		cc.CardinalSplineBy.prototype.ctor.call(this);
		points && this.initWithDuration(dt, points);
	},
    initWithDuration:function (dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, 0.5);
    },
    clone:function () {
        var action = new cc.CatmullRomBy();
        action.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return action;
    }
});
cc.catmullRomBy = function (dt, points) {
    return new cc.CatmullRomBy(dt, points);
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction:function(value, key){}
});
cc.ActionTween = cc.ActionInterval.extend({
    key:"",
    from:0,
    to:0,
    delta:0,
    ctor:function(duration, key, from, to){
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
		to !== undefined && this.initWithDuration(duration, key, from, to);
    },
    initWithDuration:function (duration, key, from, to) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this.key = key;
            this.to = to;
            this.from = from;
            return true;
        }
        return false;
    },
    startWithTarget:function (target) {
        if(!target || !target.updateTweenAction)
            throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this.delta = this.to - this.from;
    },
    update:function (dt) {
        this.target.updateTweenAction(this.to - this.delta * (1 - dt), this.key);
    },
    reverse:function () {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from);
    },
    clone:function(){
        var action = new cc.ActionTween();
        action.initWithDuration(this._duration, this.key, this.from, this.to);
        return action;
    }
});
cc.actionTween = function (duration, key, from, to) {
    return new cc.ActionTween(duration, key, from, to);
};
cc.ActionTween.create = cc.actionTween;
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,//"none" or "metadata" or "auto" or "" (empty string) or empty    TODO not used here
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: false,
        _stopped: true,
        _loadState: -1,//-1 : not loaded, 0 : waiting, 1 : loaded, -2 : load failed
        ctor: function (src) {
            var self = this;
            self._events = {};
            self.src = src;
            if (_ctx["createGain"])
                self._volumeNode = _ctx["createGain"]();
            else
                self._volumeNode = _ctx["createGainNode"]();
            self._onSuccess1 = self._onSuccess.bind(this);
            self._onError1 = self._onError.bind(this);
        },
        _play: function (offset) {
            var self = this;
            var sourceNode = self._sourceNode = _ctx["createBufferSource"]();
            var volumeNode = self._volumeNode;
            offset = offset || 0;
            sourceNode.buffer = self._buffer;
            volumeNode["gain"].value = self._volume;
            sourceNode["connect"](volumeNode);
            volumeNode["connect"](_ctx["destination"]);
            sourceNode.loop = self._loop;
            sourceNode._stopped = false;
            if(!sourceNode["playbackState"]){
                sourceNode["onended"] = function(){
                    this._stopped = true;
                };
            }
            self._paused = false;
            self._stopped = false;
            if (sourceNode.start) {
                sourceNode.start(0, offset);
            } else if (sourceNode["noteGrainOn"]) {
                var duration = sourceNode.buffer.duration;
                if (self.loop) {
                    sourceNode["noteGrainOn"](0, offset, duration);
                } else {
                    sourceNode["noteGrainOn"](0, offset, duration - offset);
                }
            } else {
                sourceNode["noteOn"](0);
            }
            self._pauseTime = 0;
        },
        _stop: function () {
            var self = this, sourceNode = self._sourceNode;
            if (self._stopped)
                return;
            if (sourceNode.stop)
                sourceNode.stop(0);
            else
                sourceNode.noteOff(0);
            self._stopped = true;
        },
        play: function () {
            var self = this;
            if (self._loadState == -1) {
                self._loadState = 0;
                return;
            } else if (self._loadState != 1)
                return;
            var sourceNode = self._sourceNode;
            if (!self._stopped && sourceNode && (sourceNode["playbackState"] == 2 || !sourceNode._stopped))
                return;//playing
            self.startTime = _ctx.currentTime;
            this._play(0);
        },
        pause: function () {
            this._pauseTime = _ctx.currentTime;
            this._paused = true;
            this._stop();
        },
        resume: function () {
            var self = this;
            if (self._paused) {
                var offset = self._buffer ? (self._pauseTime - self.startTime) % self._buffer.duration : 0;
                this._play(offset);
            }
        },
        stop: function () {
            this._pauseTime = 0;
            this._paused = false;
            this._stop();
        },
        load: function () {
            var self = this;
            if (self._loadState == 1)
                return;
            self._loadState = -1;//not loaded
            self.played = false;
            self.ended = true;
            var request = new XMLHttpRequest();
            request.open("GET", self.src, true);
            request.responseType = "arraybuffer";
            request.onload = function () {
                _ctx["decodeAudioData"](request.response, self._onSuccess1, self._onError1);
            };
            request.send();
        },
        addEventListener: function (eventName, event) {
            this._events[eventName] = event.bind(this);
        },
        removeEventListener: function (eventName) {
            delete this._events[eventName];
        },
        canplay: function () {
            return cc.sys._supportWebAudio;
        },
        _onSuccess: function (buffer) {
            var self = this;
            self._buffer = buffer;
            var success = self._events["success"], canplaythrough = self._events["canplaythrough"];
            if (success)
                success();
            if (canplaythrough)
                canplaythrough();
            if (self._loadState == 0 || self.autoplay == "autoplay" || self.autoplay == true)
                self._play();
            self._loadState = 1;//loaded
        },
        _onError: function () {
            var error = this._events["error"];
            if (error)
                error();
            this._loadState = -2;//load failed
        },
        cloneNode: function () {
            var self = this, obj = new cc.WebAudio(self.src);
            obj.volume = self.volume;
            obj._loadState = self._loadState;
            obj._buffer = self._buffer;
            if (obj._loadState == 0 || obj._loadState == -1)
                obj.load();
            return obj;
        }
    });
    var _p = cc.WebAudio.prototype;
    _p.loop;
    cc.defineGetterSetter(_p, "loop", function () {
        return this._loop;
    }, function (loop) {
        this._loop = loop;
        if (this._sourceNode)
            this._sourceNode.loop = loop;
    });
    _p.volume;
    cc.defineGetterSetter(_p, "volume", function () {
        return this._volume;
    }, function (volume) {
        this._volume = volume;
        this._volumeNode["gain"].value = volume;
    });
    _p.paused;
    cc.defineGetterSetter(_p, "paused", function () {
        return this._paused;
    });
    _p.ended;
    cc.defineGetterSetter(_p, "ended", function () {
        var sourceNode = this._sourceNode;
        if(this._paused)
           return false;
        if(this._stopped && !sourceNode)
            return true;
        if(sourceNode["playbackState"] == null)
            return sourceNode._stopped;
        else
            return sourceNode["playbackState"] == 3;
    });
    _p.played;
    cc.defineGetterSetter(_p, "played", function () {
        var sourceNode = this._sourceNode;
        return sourceNode && (sourceNode["playbackState"] == 2 || !sourceNode._stopped);
    });
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: false,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,//max count of audios that has same url
    _effectPauseCb: null,
    _playings: [],//only store when window is hidden
    ctor: function () {
        var self = this;
        self._soundSupported = cc._audioLoader._supportedAudioTypes.length > 0;
        if (self._effectPauseCb)
            self._effectPauseCb = self._effectPauseCb.bind(self);
    },
    willPlayMusic: function () {
        return false;
    },
    getEffectsVolume: function () {
        return this._effectsVolume;
    },
    playMusic: function (url, loop) {
        var self = this;
        if (!self._soundSupported)
            return;
        var audio = self._currMusic;
        if (audio)
            this._stopAudio(audio);
        if(cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS){
            audio = self._getAudioByUrl(url);
            self._currMusic = audio.cloneNode();
            self._currMusicPath = url;
        }else{
            if (url != self._currMusicPath) {
                audio = self._getAudioByUrl(url);
                self._currMusic = audio;
                self._currMusicPath = url;
            }
        }
        if (!self._currMusic)
            return;
        self._currMusic.loop = loop || false;
        self._playMusic(self._currMusic);
    },
    _getAudioByUrl: function (url) {
        var locLoader = cc.loader, audio = locLoader.getRes(url);
        if (!audio) {
            locLoader.load(url);
            audio = locLoader.getRes(url);
        }
        return audio;
    },
    _playMusic: function (audio) {
        if (!audio.ended) {
            if (audio.stop) {//cc.WebAudio
                audio.stop();
            } else {
                audio.pause();
                if (audio.readyState > 2)
                    audio.currentTime = 0;
            }
        }
        this._musicPlayState = 2;
        audio.play();
    },
    stopMusic: function (releaseData) {
        if (this._musicPlayState > 0) {
            var audio = this._currMusic;
            if (!audio) return;
            if (!this._stopAudio(audio))
                return;
            if (releaseData)
                cc.loader.release(this._currMusicPath);
            this._currMusic = null;
            this._currMusicPath = null;
            this._musicPlayState = 0;
        }
    },
    _stopAudio: function (audio) {
        if (audio && !audio.ended) {
            if (audio.stop) {//cc.WebAudio
                audio.stop();
            } else {
                audio.pause();
                if (audio.readyState > 2 && audio.duration && audio.duration != Infinity)
                    audio.currentTime = audio.duration;
            }
            return true;
        }
        return false;
    },
    pauseMusic: function () {
        if (this._musicPlayState == 2) {
            this._currMusic.pause();
            this._musicPlayState = 1;
        }
    },
    resumeMusic: function () {
        if (this._musicPlayState == 1) {
            var audio = this._currMusic;
            this._resumeAudio(audio);
            this._musicPlayState = 2;
        }
    },
    _resumeAudio: function (audio) {
        if (audio && !audio.ended) {
            if (audio.resume)
                audio.resume();//cc.WebAudio
            else
                audio.play();
        }
    },
    rewindMusic: function () {
        if (this._currMusic)
            this._playMusic(this._currMusic);
    },
    getMusicVolume: function () {
        return this._musicPlayState == 0 ? 0 : this._currMusic.volume;
    },
    setMusicVolume: function (volume) {
        if (this._musicPlayState > 0) {
            this._currMusic.volume = Math.min(Math.max(volume, 0), 1);
        }
    },
    isMusicPlaying: function () {
        return this._musicPlayState == 2 && this._currMusic && !this._currMusic.ended;
    },
    _getEffectList: function (url) {
        var list = this._audioPool[url];
        if (!list)
            list = this._audioPool[url] = [];
        return list;
    },
    _getEffect: function (url) {
        var self = this, audio;
        if (!self._soundSupported) return null;
        var effList = this._getEffectList(url);
        if(cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS){
            audio = this._getEffectAudio(effList, url);
        }else{
            for (var i = 0, li = effList.length; i < li; i++) {
                var eff = effList[i];
                if (eff.ended) {
                    audio = eff;
                    if (audio.readyState > 2)
                        audio.currentTime = 0;
                    if (window.chrome)
                        audio.load();
                    break;
                }
            }
            if (!audio) {
                audio = this._getEffectAudio(effList, url);
                audio && effList.push(audio);
            }
        }
        return audio;
    },
    _getEffectAudio: function(effList, url){
        var audio;
        if (effList.length >= this._maxAudioInstance) {
            cc.log("Error: " + url + " greater than " + this._maxAudioInstance);
            return null;
        }
        audio = this._getAudioByUrl(url);
        if (!audio)
            return null;
        audio = audio.cloneNode(true);
        if (this._effectPauseCb)
            cc._addEventListener(audio, "pause", this._effectPauseCb);
        audio.volume = this._effectsVolume;
        return audio;
    },
    playEffect: function (url, loop) {
        var audio = this._getEffect(url);
        if (!audio) return null;
        audio.loop = loop || false;
        audio.play();
        var audioId = this._audioID++;
        this._effects[audioId] = audio;
        return audioId;
    },
    setEffectsVolume: function (volume) {
        volume = this._effectsVolume = Math.min(Math.max(volume, 0), 1);
        var effects = this._effects;
        for (var key in effects) {
            effects[key].volume = volume;
        }
    },
    pauseEffect: function (audioID) {
        var audio = this._effects[audioID];
        if (audio && !audio.ended) {
            audio.pause();
        }
    },
    pauseAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            var eff = effects[key];
            if (!eff.ended) eff.pause();
        }
    },
    resumeEffect: function (effectId) {
        this._resumeAudio(this._effects[effectId])
    },
    resumeAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            this._resumeAudio(effects[key]);
        }
    },
    stopEffect: function (effectId) {
        this._stopAudio(this._effects[effectId]);
        delete this._effects[effectId];
    },
    stopAllEffects: function () {
        var effects = this._effects;
        for (var key in effects) {
            this._stopAudio(effects[key]);
            delete effects[key];
        }
    },
    unloadEffect: function (url) {
        var locLoader = cc.loader, locEffects = this._effects, effectList = this._getEffectList(url);
        locLoader.release(url);//release the resource in cc.loader first.
        if (effectList.length == 0) return;
        var realUrl = effectList[0].src;
        delete this._audioPool[url];
        for (var key in locEffects) {
            if (locEffects[key].src == realUrl) {
                this._stopAudio(locEffects[key]);
                delete locEffects[key];
            }
        }
    },
    end: function () {
        this.stopMusic();
        this.stopAllEffects();
    },
    _pausePlaying: function () {//in this function, do not change any status of audios
        var self = this, effects = self._effects, eff;
        for (var key in effects) {
            eff = effects[key];
            if (eff && !eff.ended && !eff.paused) {
                self._playings.push(eff);
                eff.pause();
            }
        }
        if (self.isMusicPlaying()) {
            self._playings.push(self._currMusic);
            self._currMusic.pause();
        }
    },
    _resumePlaying: function () {//in this function, do not change any status of audios
        var self = this, playings = this._playings;
        for (var i = 0, li = playings.length; i < li; i++) {
            self._resumeAudio(playings[i]);
        }
        playings.length = 0;
    }
});
if (!cc.sys._supportWebAudio && !cc.sys._supportMultipleAudio) {
    cc.AudioEngineForSingle = cc.AudioEngine.extend({
        _waitingEffIds: [],
        _pausedEffIds: [],
        _currEffect: null,
        _maxAudioInstance: 2,
        _effectCache4Single: {},//{url:audio},
        _needToResumeMusic: false,
        _expendTime4Music: 0,
        _isHiddenMode: false,
        _playMusic: function (audio) {
            this._stopAllEffects();
            this._super(audio);
        },
        resumeMusic: function () {
            var self = this;
            if (self._musicPlayState == 1) {
                self._stopAllEffects();
                self._needToResumeMusic = false;
                self._expendTime4Music = 0;
                self._super();
            }
        },
        playEffect: function (url, loop) {
            var self = this, currEffect = self._currEffect;
            var audio = loop ? self._getEffect(url) : self._getSingleEffect(url);
            if (!audio) return null;
            audio.loop = loop || false;
            var audioId = self._audioID++;
            self._effects[audioId] = audio;
            if (self.isMusicPlaying()) {
                self.pauseMusic();
                self._needToResumeMusic = true;
            }
            if (currEffect) {
                if (currEffect != audio) self._waitingEffIds.push(self._currEffectId);
                self._waitingEffIds.push(audioId);
                currEffect.pause();
            } else {
                self._currEffect = audio;
                self._currEffectId = audioId;
                audio.play();
            }
            return audioId;
        },
        pauseEffect: function (effectId) {
            cc.log("pauseEffect not supported in single audio mode!");
        },
        pauseAllEffects: function () {
            var self = this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds, currEffect = self._currEffect;
            if (!currEffect) return;
            for (var i = 0, li = waitings.length; i < li; i++) {
                pauseds.push(waitings[i]);
            }
            waitings.length = 0;//clear
            pauseds.push(self._currEffectId);
            currEffect.pause();
        },
        resumeEffect: function (effectId) {
            cc.log("resumeEffect not supported in single audio mode!");
        },
        resumeAllEffects: function () {
            var self = this, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (self.isMusicPlaying()) {//if music is playing, pause it first
                self.pauseMusic();
                self._needToResumeMusic = true;
            }
            for (var i = 0, li = pauseds.length; i < li; i++) {//move pauseds to waitings
                waitings.push(pauseds[i]);
            }
            pauseds.length = 0;//clear
            if (!self._currEffect && waitings.length >= 0) {//is none currEff, resume the newest effect in waitings
                var effId = waitings.pop();
                var eff = self._effects[effId];
                if (eff) {
                    self._currEffectId = effId;
                    self._currEffect = eff;
                    self._resumeAudio(eff);
                }
            }
        },
        stopEffect: function (effectId) {
            var self = this, currEffect = self._currEffect, waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (currEffect && this._currEffectId == effectId) {//if the eff to be stopped is currEff
                this._stopAudio(currEffect);
            } else {//delete from waitings or pauseds
                var index = waitings.indexOf(effectId);
                if (index >= 0) {
                    waitings.splice(index, 1);
                } else {
                    index = pauseds.indexOf(effectId);
                    if (index >= 0) pauseds.splice(index, 1);
                }
            }
        },
        stopAllEffects: function () {
            var self = this;
            self._stopAllEffects();
            if (!self._currEffect && self._needToResumeMusic) {//need to resume music
                self._resumeAudio(self._currMusic);
                self._musicPlayState = 2;
                self._needToResumeMusic = false;
                self._expendTime4Music = 0;
            }
        },
        unloadEffect: function (url) {
            var self = this, locLoader = cc.loader, locEffects = self._effects, effCache = self._effectCache4Single,
                effectList = self._getEffectList(url), currEffect = self._currEffect;
            locLoader.release(url);//release the resource in cc.loader first.
            if (effectList.length == 0 && !effCache[url]) return;
            var realUrl = effectList.length > 0 ? effectList[0].src : effCache[url].src;
            delete self._audioPool[url];
            delete effCache[url];
            for (var key in locEffects) {
                if (locEffects[key].src == realUrl) {
                    delete locEffects[key];
                }
            }
            if (currEffect && currEffect.src == realUrl) self._stopAudio(currEffect);//need to stop currEff
        },
        _getSingleEffect: function (url) {
            var self = this, audio = self._effectCache4Single[url], locLoader = cc.loader,
                waitings = self._waitingEffIds, pauseds = self._pausedEffIds, effects = self._effects;
            if (audio) {
                if (audio.readyState > 2)
                    audio.currentTime = 0;
            } else {
                audio = self._getAudioByUrl(url);
                if (!audio) return null;
                audio = audio.cloneNode(true);
                if (self._effectPauseCb)
                    cc._addEventListener(audio, "pause", self._effectPauseCb);
                audio.volume = self._effectsVolume;
                self._effectCache4Single[url] = audio;
            }
            for (var i = 0, li = waitings.length; i < li;) {//reset waitings
                if (effects[waitings[i]] == audio) {
                    waitings.splice(i, 1);
                } else
                    i++;
            }
            for (var i = 0, li = pauseds.length; i < li;) {//reset pauseds
                if (effects[pauseds[i]] == audio) {
                    pauseds.splice(i, 1);
                } else
                    i++;
            }
            audio._isToPlay = true;//custom flag
            return audio;
        },
        _stopAllEffects: function () {
            var self = this, currEffect = self._currEffect, audioPool = self._audioPool, sglCache = self._effectCache4Single,
                waitings = self._waitingEffIds, pauseds = self._pausedEffIds;
            if (!currEffect && waitings.length == 0 && pauseds.length == 0)
                return;
            for (var key in sglCache) {
                var eff = sglCache[key];
                if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                    eff.currentTime = eff.duration;
            }
            waitings.length = 0;
            pauseds.length = 0;
            for (var key in audioPool) {//reset audios in pool to be ended
                var list = audioPool[key];
                for (var i = 0, li = list.length; i < li; i++) {
                    var eff = list[i];
                    eff.loop = false;
                    if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                        eff.currentTime = eff.duration;
                }
            }
            if (currEffect) self._stopAudio(currEffect);
        },
        _effectPauseCb: function () {
            var self = this;
            if (self._isHiddenMode) return;//in this mode, return
            var currEffect = self._getWaitingEffToPlay();//get eff to play
            if (currEffect) {
                if (currEffect._isToPlay) {
                    delete currEffect._isToPlay;
                    currEffect.play();
                }
                else self._resumeAudio(currEffect);
            } else if (self._needToResumeMusic) {
                var currMusic = self._currMusic;
                if (currMusic.readyState > 2 && currMusic.duration && currMusic.duration != Infinity) {//calculate current time
                    var temp = currMusic.currentTime + self._expendTime4Music;
                    temp = temp - currMusic.duration * ((temp / currMusic.duration) | 0);
                    currMusic.currentTime = temp;
                }
                self._expendTime4Music = 0;
                self._resumeAudio(currMusic);
                self._musicPlayState = 2;
                self._needToResumeMusic = false;
            }
        },
        _getWaitingEffToPlay: function () {
            var self = this, waitings = self._waitingEffIds, effects = self._effects,
                currEffect = self._currEffect;
            var expendTime = currEffect ? currEffect.currentTime - (currEffect.startTime || 0) : 0;
            self._expendTime4Music += expendTime;
            while (true) {//get a audio to play
                if (waitings.length == 0)
                    break;
                var effId = waitings.pop();
                var eff = effects[effId];
                if (!eff)
                    continue;
                if (eff._isToPlay || eff.loop || (eff.duration && eff.currentTime + expendTime < eff.duration)) {
                    self._currEffectId = effId;
                    self._currEffect = eff;
                    if (!eff._isToPlay && eff.readyState > 2 && eff.duration && eff.duration != Infinity) {
                        var temp = eff.currentTime + expendTime;
                        temp = temp - eff.duration * ((temp / eff.duration) | 0);
                        eff.currentTime = temp;
                    }
                    eff._isToPlay = false;
                    return eff;
                } else {
                    if (eff.readyState > 2 && eff.duration && eff.duration != Infinity)
                        eff.currentTime = eff.duration;
                }
            }
            self._currEffectId = null;
            self._currEffect = null;
            return null;
        },
        _pausePlaying: function () {//in this function, do not change any status of audios
            var self = this, currEffect = self._currEffect;
            self._isHiddenMode = true;
            var audio = self._musicPlayState == 2 ? self._currMusic : currEffect;
            if (audio) {
                self._playings.push(audio);
                audio.pause();
            }
        },
        _resumePlaying: function () {//in this function, do not change any status of audios
            var self = this, playings = self._playings;
            self._isHiddenMode = false;
            if (playings.length > 0) {
                self._resumeAudio(playings[0]);
                playings.length = 0;
            }
        }
    });
}
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function () {
        return cc.loader.audioPath;
    },
    _load: function (realUrl, url, res, count, tryArr, audio, cb) {
        var self = this, locLoader = cc.loader, path = cc.path;
        var types = this._supportedAudioTypes;
        var extname = "";
        if (types.length == 0)
            return cb("can not support audio!");
        if (count == -1) {
            extname = (path.extname(realUrl) || "").toLowerCase();
            if (!self.audioTypeSupported(extname)) {
                extname = types[0];
                count = 0;
            }
        } else if (count < types.length) {
            extname = types[count];
        } else {
            return cb("can not found the resource of audio! Last match url is : " + realUrl);
        }
        if (tryArr.indexOf(extname) >= 0)
            return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);
        realUrl = path.changeExtname(realUrl, extname);
        tryArr.push(extname);
        var delFlag = (count == types.length -1);
        audio = self._loadAudio(realUrl, audio, function (err) {
            if (err)
                return self._load(realUrl, url, res, count + 1, tryArr, audio, cb);//can not found
            cb(null, audio);
        }, delFlag);
        locLoader.cache[url] = audio;
    },
    audioTypeSupported: function (type) {
        if (!type) return false;
        return this._supportedAudioTypes.indexOf(type.toLowerCase()) >= 0;
    },
    _loadAudio: function (url, audio, cb, delFlag) {
        var _Audio;
        if (!cc.isObject(window["cc"]) && cc.sys.browserType == "firefox")
            _Audio = Audio;
        else
            _Audio = (location.origin == "file://") ? Audio : (cc.WebAudio || Audio);
        if (arguments.length == 2) {
            cb = audio;
            audio = new _Audio();
        } else if ((arguments.length > 3 ) && !audio) {
            audio = new _Audio();
        }
        audio.src = url;
        audio.preload = "auto";
        var ua = navigator.userAgent;
        if (/Mobile/.test(ua) && (/iPhone OS/.test(ua) || /iPad/.test(ua) || /Firefox/.test(ua)) || /MSIE/.test(ua)) {
            audio.load();
            cb(null, audio);
        } else {
            var canplaythrough = "canplaythrough", error = "error";
            cc._addEventListener(audio, canplaythrough, function () {
                cb(null, audio);
                this.removeEventListener(canplaythrough, arguments.callee, false);
                this.removeEventListener(error, arguments.callee, false);
            }, false);
            var audioCB = function () {
                audio.removeEventListener("emptied", audioCB);
                audio.removeEventListener(error, audioCB);
                cb("load " + url + " failed");
                if(delFlag){
                    this.removeEventListener(canplaythrough, arguments.callee, false);
                    this.removeEventListener(error, arguments.callee, false);
                }
            };
            if(cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT){
                cc._addEventListener(audio, "emptied", audioCB, false);
            }
            cc._addEventListener(audio, error, audioCB, false);
            audio.load();
        }
        return audio;
    },
    load: function (realUrl, url, res, cb) {
        var tryArr = [];
        this._load(realUrl, url, res, -1, tryArr, null, cb);
    }
};
cc._audioLoader._supportedAudioTypes = function () {
    var au = cc.newElement('audio'), arr = [];
    if (au.canPlayType) {
        var _check = function (typeStr) {
            var result = au.canPlayType(typeStr);
            return result != "no" && result != "";
        };
        if (_check('audio/ogg; codecs="vorbis"')) arr.push(".ogg");
        if (_check("audio/mpeg")) arr.push(".mp3");
        if (_check('audio/wav; codecs="1"')) arr.push(".wav");
        if (_check("audio/mp4")) arr.push(".mp4");
        if (_check("audio/x-m4a") || _check("audio/aac")) arr.push(".m4a");
    }
    return arr;
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle() : new cc.AudioEngine();
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
    cc.audioEngine._pausePlaying();
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
    cc.audioEngine._resumePlaying();
});
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = false;
cc.MenuItem = cc.Node.extend({
    _enabled: false,
    _target: null,
    _callback: null,
    _isSelected: false,
    _className: "MenuItem",
    ctor: function (callback, target) {
        var nodeP = cc.Node.prototype;
        nodeP.ctor.call(this);
        this._target = null;
        this._callback = null;
        this._isSelected = false;
        this._enabled = false;
        nodeP.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = target || null;
        this._callback = callback || null;
        if (this._callback) {
            this._enabled = true;
        }
    },
    isSelected: function () {
        return this._isSelected;
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    setTarget: function (selector, rec) {
        this._target = rec;
        this._callback = selector;
    },
    isEnabled: function () {
        return this._enabled;
    },
    setEnabled: function (enable) {
        this._enabled = enable;
    },
    initWithCallback: function (callback, target) {
        this.anchorX = 0.5;
        this.anchorY = 0.5;
        this._target = target;
        this._callback = callback;
        this._enabled = true;
        this._isSelected = false;
        return true;
    },
    rect: function () {
        var locPosition = this._position, locContentSize = this._contentSize, locAnchorPoint = this._anchorPoint;
        return cc.rect(locPosition.x - locContentSize.width * locAnchorPoint.x,
            locPosition.y - locContentSize.height * locAnchorPoint.y,
            locContentSize.width, locContentSize.height);
    },
    selected: function () {
        this._isSelected = true;
    },
    unselected: function () {
        this._isSelected = false;
    },
    setCallback: function (callback, target) {
        this._target = target;
        this._callback = callback;
    },
    activate: function () {
        if (this._enabled) {
            var locTarget = this._target, locCallback = this._callback;
            if (!locCallback)
                return;
            if (locTarget && cc.isString(locCallback)) {
                locTarget[locCallback](this);
            } else if (locTarget && cc.isFunction(locCallback)) {
                locCallback.call(locTarget, this);
            } else
                locCallback(this);
        }
    }
});
var _p = cc.MenuItem.prototype;
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function (callback, target) {
    return new cc.MenuItem(callback, target);
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function (label, selector, target) {
        cc.MenuItem.prototype.ctor.call(this, selector, target);
        this._disabledColor = null;
        this._label = null;
        this._orginalScale = 0;
        this._colorBackup = null;
        if (label) {
            this._originalScale = 1.0;
            this._colorBackup = cc.color.WHITE;
            this._disabledColor = cc.color(126, 126, 126);
            this.setLabel(label);
            this.cascadeColor = true;
            this.cascadeOpacity = true;
        }
    },
    getDisabledColor: function () {
        return this._disabledColor;
    },
    setDisabledColor: function (color) {
        this._disabledColor = color;
    },
    getLabel: function () {
        return this._label;
    },
    setLabel: function (label) {
        if (label) {
            this.addChild(label);
            label.anchorX = 0;
            label.anchorY = 0;
            this.width = label.width;
            this.height = label.height;
        }
        if (this._label) {
            this.removeChild(this._label, true);
        }
        this._label = label;
    },
    setEnabled: function (enabled) {
        if (this._enabled != enabled) {
            var locLabel = this._label;
            if (!enabled) {
                this._colorBackup = locLabel.color;
                locLabel.color = this._disabledColor;
            } else {
                locLabel.color = this._colorBackup;
            }
        }
        cc.MenuItem.prototype.setEnabled.call(this, enabled);
    },
    setOpacity: function (opacity) {
        this._label.opacity = opacity;
    },
    getOpacity: function () {
        return this._label.opacity;
    },
    setColor: function (color) {
        this._label.color = color;
    },
    getColor: function () {
        return this._label.color;
    },
    initWithLabel: function (label, selector, target) {
        this.initWithCallback(selector, target);
        this._originalScale = 1.0;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(label);
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    setString: function (label) {
        this._label.string = label;
        this.width = this._label.width;
        this.height = this._label.height;
    },
    getString: function () {
        return this._label.string;
    },
    activate: function () {
        if (this._enabled) {
            this.stopAllActions();
            this.scale = this._originalScale;
            cc.MenuItem.prototype.activate.call(this);
        }
    },
    selected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            if (action)
                this.stopAction(action);
            else
                this._originalScale = this.scale;
            var zoomAction = cc.scaleTo(0.1, this._originalScale * 1.2);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    },
    unselected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var zoomAction = cc.scaleTo(0.1, this._originalScale);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    }
});
var _p = cc.MenuItemLabel.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.disabledColor;
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
_p.label;
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function (label, selector, target) {
    return new cc.MenuItemLabel(label, selector, target);
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
        var label;
        if (value && value.length > 0) {
            label = new cc.LabelAtlas(value, charMapFile, itemWidth, itemHeight, startCharMap);
        }
        cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
    },
    initWithString: function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
        if (!value || value.length == 0)
            throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var label = new cc.LabelAtlas();
        label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
        if (this.initWithLabel(label, callback, target)) {
        }
        return true;
    }
});
cc.MenuItemAtlasFont.create = function (value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target) {
    return new cc.MenuItemAtlasFont(value, charMapFile, itemWidth, itemHeight, startCharMap, callback, target);
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function (value, callback, target) {
        var label;
        if (value && value.length > 0) {
            this._fontName = cc._globalFontName;
            this._fontSize = cc._globalFontSize;
            label = new cc.LabelTTF(value, this._fontName, this._fontSize);
        }
        else {
            this._fontSize = 0;
            this._fontName = "";
        }
        cc.MenuItemLabel.prototype.ctor.call(this, label, callback, target);
    },
    initWithString: function (value, callback, target) {
        if (!value || value.length == 0)
            throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        var label = new cc.LabelTTF(value, this._fontName, this._fontSize);
        if (this.initWithLabel(label, callback, target)) {
        }
        return true;
    },
    setFontSize: function (s) {
        this._fontSize = s;
        this._recreateLabel();
    },
    getFontSize: function () {
        return this._fontSize;
    },
    setFontName: function (name) {
        this._fontName = name;
        this._recreateLabel();
    },
    getFontName: function () {
        return this._fontName;
    },
    _recreateLabel: function () {
        var label = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(label);
    }
});
cc.MenuItemFont.setFontSize = function (fontSize) {
    cc._globalFontSize = fontSize;
};
cc.MenuItemFont.fontSize = function () {
    return cc._globalFontSize;
};
cc.MenuItemFont.setFontName = function (name) {
    if (cc._globalFontNameRelease) {
        cc._globalFontName = '';
    }
    cc._globalFontName = name;
    cc._globalFontNameRelease = true;
};
var _p = cc.MenuItemFont.prototype;
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function () {
    return cc._globalFontName;
};
cc.MenuItemFont.create = function (value, callback, target) {
    return new cc.MenuItemFont(value, callback, target);
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function (normalSprite, selectedSprite, three, four, five) {
        cc.MenuItem.prototype.ctor.call(this);
        this._normalImage = null;
        this._selectedImage = null;
        this._disabledImage = null;
        if (selectedSprite !== undefined) {
            normalSprite = normalSprite;
            selectedSprite = selectedSprite;
            var disabledImage, target, callback;
            if (five !== undefined) {
                disabledImage = three;
                callback = four;
                target = five;
            } else if (four !== undefined && cc.isFunction(four)) {
                disabledImage = three;
                callback = four;
            } else if (four !== undefined && cc.isFunction(three)) {
                target = four;
                callback = three;
                disabledImage = new cc.Sprite(selectedSprite);
            } else if (three === undefined) {
                disabledImage = new cc.Sprite(selectedSprite);
            }
            this.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, callback, target);
        }
    },
    getNormalImage: function () {
        return this._normalImage;
    },
    setNormalImage: function (normalImage) {
        if (this._normalImage == normalImage) {
            return;
        }
        if (normalImage) {
            this.addChild(normalImage, 0, cc.NORMAL_TAG);
            normalImage.anchorX = 0;
            normalImage.anchorY = 0;
        }
        if (this._normalImage) {
            this.removeChild(this._normalImage, true);
        }
        this._normalImage = normalImage;
        this.width = this._normalImage.width;
        this.height = this._normalImage.height;
        this._updateImagesVisibility();
        if (normalImage.textureLoaded && !normalImage.textureLoaded()) {
            normalImage.addEventListener("load", function (sender) {
                this.width = sender.width;
                this.height = sender.height;
            }, this);
        }
    },
    getSelectedImage: function () {
        return this._selectedImage;
    },
    setSelectedImage: function (selectedImage) {
        if (this._selectedImage == selectedImage)
            return;
        if (selectedImage) {
            this.addChild(selectedImage, 0, cc.SELECTED_TAG);
            selectedImage.anchorX = 0;
            selectedImage.anchorY = 0;
        }
        if (this._selectedImage) {
            this.removeChild(this._selectedImage, true);
        }
        this._selectedImage = selectedImage;
        this._updateImagesVisibility();
    },
    getDisabledImage: function () {
        return this._disabledImage;
    },
    setDisabledImage: function (disabledImage) {
        if (this._disabledImage == disabledImage)
            return;
        if (disabledImage) {
            this.addChild(disabledImage, 0, cc.DISABLE_TAG);
            disabledImage.anchorX = 0;
            disabledImage.anchorY = 0;
        }
        if (this._disabledImage)
            this.removeChild(this._disabledImage, true);
        this._disabledImage = disabledImage;
        this._updateImagesVisibility();
    },
    initWithNormalSprite: function (normalSprite, selectedSprite, disabledSprite, callback, target) {
        this.initWithCallback(callback, target);
        this.setNormalImage(normalSprite);
        this.setSelectedImage(selectedSprite);
        this.setDisabledImage(disabledSprite);
        var locNormalImage = this._normalImage;
        if (locNormalImage) {
            this.width = locNormalImage.width;
            this.height = locNormalImage.height;
            if (locNormalImage.textureLoaded && !locNormalImage.textureLoaded()) {
                locNormalImage.addEventListener("load", function (sender) {
                    this.width = sender.width;
                    this.height = sender.height;
                    this.cascadeColor = true;
                    this.cascadeOpacity = true;
                }, this);
            }
        }
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    setColor: function (color) {
        this._normalImage.color = color;
        if (this._selectedImage)
            this._selectedImage.color = color;
        if (this._disabledImage)
            this._disabledImage.color = color;
    },
    getColor: function () {
        return this._normalImage.color;
    },
    setOpacity: function (opacity) {
        this._normalImage.opacity = opacity;
        if (this._selectedImage)
            this._selectedImage.opacity = opacity;
        if (this._disabledImage)
            this._disabledImage.opacity = opacity;
    },
    getOpacity: function () {
        return this._normalImage.opacity;
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        if (this._normalImage) {
            if (this._disabledImage)
                this._disabledImage.visible = false;
            if (this._selectedImage) {
                this._normalImage.visible = false;
                this._selectedImage.visible = true;
            } else
                this._normalImage.visible = true;
        }
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        if (this._normalImage) {
            this._normalImage.visible = true;
            if (this._selectedImage)
                this._selectedImage.visible = false;
            if (this._disabledImage)
                this._disabledImage.visible = false;
        }
    },
    setEnabled: function (bEnabled) {
        if (this._enabled != bEnabled) {
            cc.MenuItem.prototype.setEnabled.call(this, bEnabled);
            this._updateImagesVisibility();
        }
    },
    _updateImagesVisibility: function () {
        var locNormalImage = this._normalImage, locSelImage = this._selectedImage, locDisImage = this._disabledImage;
        if (this._enabled) {
            if (locNormalImage)
                locNormalImage.visible = true;
            if (locSelImage)
                locSelImage.visible = false;
            if (locDisImage)
                locDisImage.visible = false;
        } else {
            if (locDisImage) {
                if (locNormalImage)
                    locNormalImage.visible = false;
                if (locSelImage)
                    locSelImage.visible = false;
                if (locDisImage)
                    locDisImage.visible = true;
            } else {
                if (locNormalImage)
                    locNormalImage.visible = true;
                if (locSelImage)
                    locSelImage.visible = false;
            }
        }
    }
});
var _p = cc.MenuItemSprite.prototype;
_p.normalImage;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
_p.selectedImage;
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
_p.disabledImage;
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function (normalSprite, selectedSprite, three, four, five) {
    return new cc.MenuItemSprite(normalSprite, selectedSprite, three, four, five || undefined);
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function (normalImage, selectedImage, three, four, five) {
        var normalSprite = null,
            selectedSprite = null,
            disabledSprite = null,
            callback = null,
            target = null;
        if (normalImage === undefined) {
            cc.MenuItemSprite.prototype.ctor.call(this);
        }
        else {
            normalSprite = new cc.Sprite(normalImage);
            selectedImage &&
            (selectedSprite = new cc.Sprite(selectedImage));
            if (four === undefined) {
                callback = three;
            }
            else if (five === undefined) {
                callback = three;
                target = four;
            }
            else if (five) {
                disabledSprite = new cc.Sprite(three);
                callback = four;
                target = five;
            }
            cc.MenuItemSprite.prototype.ctor.call(this, normalSprite, selectedSprite, disabledSprite, callback, target);
        }
    },
    setNormalSpriteFrame: function (frame) {
        this.setNormalImage(new cc.Sprite(frame));
    },
    setSelectedSpriteFrame: function (frame) {
        this.setSelectedImage(new cc.Sprite(frame));
    },
    setDisabledSpriteFrame: function (frame) {
        this.setDisabledImage(new cc.Sprite(frame));
    },
    initWithNormalImage: function (normalImage, selectedImage, disabledImage, callback, target) {
        var normalSprite = null;
        var selectedSprite = null;
        var disabledSprite = null;
        if (normalImage) {
            normalSprite = new cc.Sprite(normalImage);
        }
        if (selectedImage) {
            selectedSprite = new cc.Sprite(selectedImage);
        }
        if (disabledImage) {
            disabledSprite = new cc.Sprite(disabledImage);
        }
        return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, callback, target);
    }
});
cc.MenuItemImage.create = function (normalImage, selectedImage, three, four, five) {
    return new cc.MenuItemImage(normalImage, selectedImage, three, four, five);
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function () {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        if(arguments.length > 0)
            this.initWithItems(Array.prototype.slice.apply(arguments));
    },
    getOpacity: function () {
        return this._opacity;
    },
    setOpacity: function (opacity) {
        this._opacity = opacity;
        if (this.subItems && this.subItems.length > 0) {
            for (var it = 0; it < this.subItems.length; it++) {
                this.subItems[it].opacity = opacity;
            }
        }
        this._color.a = opacity;
    },
    getColor: function () {
        var locColor = this._color;
        return cc.color(locColor.r, locColor.g, locColor.b, locColor.a);
    },
    setColor: function (color) {
        var locColor = this._color;
        locColor.r = color.r;
        locColor.g = color.g;
        locColor.b = color.b;
        if (this.subItems && this.subItems.length > 0) {
            for (var it = 0; it < this.subItems.length; it++) {
                this.subItems[it].setColor(color);
            }
        }
        if (color.a !== undefined && !color.a_undefined) {
            this.setOpacity(color.a);
        }
    },
    getSelectedIndex: function () {
        return this._selectedIndex;
    },
    setSelectedIndex: function (SelectedIndex) {
        if (SelectedIndex != this._selectedIndex) {
            this._selectedIndex = SelectedIndex;
            var currItem = this.getChildByTag(cc.CURRENT_ITEM);
            if (currItem)
                currItem.removeFromParent(false);
            var item = this.subItems[this._selectedIndex];
            this.addChild(item, 0, cc.CURRENT_ITEM);
            var w = item.width, h = item.height;
            this.width = w;
            this.height = h;
            item.setPosition(w / 2, h / 2);
        }
    },
    getSubItems: function () {
        return this.subItems;
    },
    setSubItems: function (subItems) {
        this.subItems = subItems;
    },
    initWithItems: function (args) {
        var l = args.length;
        if (cc.isFunction(args[args.length - 2])) {
            this.initWithCallback(args[args.length - 2], args[args.length - 1]);
            l = l - 2;
        } else if (cc.isFunction(args[args.length - 1])) {
            this.initWithCallback(args[args.length - 1], null);
            l = l - 1;
        } else {
            this.initWithCallback(null, null);
        }
        var locSubItems = this.subItems;
        locSubItems.length = 0;
        for (var i = 0; i < l; i++) {
            if (args[i])
                locSubItems.push(args[i]);
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        this.cascadeColor = true;
        this.cascadeOpacity = true;
        return true;
    },
    addSubItem: function (item) {
        this.subItems.push(item);
    },
    activate: function () {
        if (this._enabled) {
            var newIndex = (this._selectedIndex + 1) % this.subItems.length;
            this.setSelectedIndex(newIndex);
        }
        cc.MenuItem.prototype.activate.call(this);
    },
    selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected();
    },
    unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected();
    },
    setEnabled: function (enabled) {
        if (this._enabled != enabled) {
            cc.MenuItem.prototype.setEnabled.call(this, enabled);
            var locItems = this.subItems;
            if (locItems && locItems.length > 0) {
                for (var it = 0; it < locItems.length; it++)
                    locItems[it].enabled = enabled;
            }
        }
    },
    selectedItem: function () {
        return this.subItems[this._selectedIndex];
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex);
    }
});
var _p = cc.MenuItemToggle.prototype;
_p.selectedIndex;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function () {
    if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var ret = new cc.MenuItemToggle();
    ret.initWithItems(Array.prototype.slice.apply(arguments));
    return ret;
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: false,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function (menuItems) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = false;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: true,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var argc = arguments.length, items;
        if (argc == 0) {
            items = [];
        } else if (argc == 1) {
            if (menuItems instanceof Array) {
                items = menuItems;
            }
            else items = [menuItems];
        }
        else if (argc > 1) {
            items = [];
            for (var i = 0; i < argc; i++) {
                if (arguments[i])
                    items.push(arguments[i]);
            }
        }
        this.initWithArray(items);
    },
    onEnter: function () {
        var locListener = this._touchListener;
        if (!locListener._isRegistered())
            cc.eventManager.addListener(locListener, this);
        cc.Node.prototype.onEnter.call(this);
    },
    isEnabled: function () {
        return this.enabled;
    },
    setEnabled: function (enabled) {
        this.enabled = enabled;
    },
    initWithItems: function (args) {
        var pArray = [];
        if (args) {
            for (var i = 0; i < args.length; i++) {
                if (args[i])
                    pArray.push(args[i]);
            }
        }
        return this.initWithArray(pArray);
    },
    initWithArray: function (arrayOfItems) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = true;
            var winSize = cc.winSize;
            this.setPosition(winSize.width / 2, winSize.height / 2);
            this.setContentSize(winSize);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(true);
            if (arrayOfItems) {
                for (var i = 0; i < arrayOfItems.length; i++)
                    this.addChild(arrayOfItems[i], i);
            }
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            this.cascadeColor = true;
            this.cascadeOpacity = true;
            return true;
        }
        return false;
    },
    addChild: function (child, zOrder, tag) {
        if (!(child instanceof cc.MenuItem))
            throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, child, zOrder, tag);
    },
    alignItemsVertically: function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsVerticallyWithPadding: function (padding) {
        var height = -padding, locChildren = this._children, len, i, locScaleY, locHeight, locChild;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++)
                height += locChildren[i].height * locChildren[i].scaleY + padding;
            var y = height / 2.0;
            for (i = 0, len = locChildren.length; i < len; i++) {
                locChild = locChildren[i];
                locHeight = locChild.height;
                locScaleY = locChild.scaleY;
                locChild.setPosition(0, y - locHeight * locScaleY / 2);
                y -= locHeight * locScaleY + padding;
            }
        }
    },
    alignItemsHorizontally: function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },
    alignItemsHorizontallyWithPadding: function (padding) {
        var width = -padding, locChildren = this._children, i, len, locScaleX, locWidth, locChild;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++)
                width += locChildren[i].width * locChildren[i].scaleX + padding;
            var x = -width / 2.0;
            for (i = 0, len = locChildren.length; i < len; i++) {
                locChild = locChildren[i];
                locScaleX = locChild.scaleX;
                locWidth = locChildren[i].width;
                locChild.setPosition(x + locWidth * locScaleX / 2, 0);
                x += locWidth * locScaleX + padding;
            }
        }
    },
    alignItemsInColumns: function () {
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var rows = [];
        for (var i = 0; i < arguments.length; i++) {
            rows.push(arguments[i]);
        }
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns, tmp, len;
        var locChildren = this._children;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                if (row >= rows.length)
                    continue;
                rowColumns = rows[row];
                if (!rowColumns)
                    continue;
                tmp = locChildren[i].height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    height += rowHeight + 5;
                    columnsOccupied = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
        var winSize = cc.director.getWinSize();
        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0.0;
        var x = 0.0;
        var y = (height / 2);
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                var child = locChildren[i];
                if (rowColumns == 0) {
                    rowColumns = rows[row];
                    w = winSize.width / (1 + rowColumns);
                    x = w;
                }
                tmp = child._getHeight();
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);
                child.setPosition(x - winSize.width / 2, y - tmp / 2);
                x += w;
                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    y -= rowHeight + 5;
                    columnsOccupied = 0;
                    rowColumns = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
    },
    alignItemsInRows: function () {
        if ((arguments.length > 0) && (arguments[arguments.length - 1] == null))
            cc.log("parameters should not be ending with null in Javascript");
        var columns = [], i;
        for (i = 0; i < arguments.length; i++) {
            columns.push(arguments[i]);
        }
        var columnWidths = [];
        var columnHeights = [];
        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows, child, len, tmp;
        var locChildren = this._children;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                child = locChildren[i];
                if (column >= columns.length)
                    continue;
                columnRows = columns[column];
                if (!columnRows)
                    continue;
                tmp = child.width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);
                columnHeight += (child.height + 5);
                ++rowsOccupied;
                if (rowsOccupied >= columnRows) {
                    columnWidths.push(columnWidth);
                    columnHeights.push(columnHeight);
                    width += columnWidth + 10;
                    rowsOccupied = 0;
                    columnWidth = 0;
                    columnHeight = -5;
                    ++column;
                }
            }
        }
        var winSize = cc.director.getWinSize();
        column = 0;
        columnWidth = 0;
        columnRows = 0;
        var x = -width / 2;
        var y = 0.0;
        if (locChildren && locChildren.length > 0) {
            for (i = 0, len = locChildren.length; i < len; i++) {
                child = locChildren[i];
                if (columnRows == 0) {
                    columnRows = columns[column];
                    y = columnHeights[column];
                }
                tmp = child._getWidth();
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);
                child.setPosition(x + columnWidths[column] / 2, y - winSize.height / 2);
                y -= child.height + 10;
                ++rowsOccupied;
                if (rowsOccupied >= columnRows) {
                    x += columnWidth + 5;
                    rowsOccupied = 0;
                    columnRows = 0;
                    columnWidth = 0;
                    ++column;
                }
            }
        }
    },
    removeChild: function (child, cleanup) {
        if (child == null)
            return;
        if (!(child instanceof cc.MenuItem)) {
            cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
            return;
        }
        if (this._selectedItem == child)
            this._selectedItem = null;
        cc.Node.prototype.removeChild.call(this, child, cleanup);
    },
    _onTouchBegan: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state != cc.MENU_STATE_WAITING || !target._visible || !target.enabled)
            return false;
        for (var c = target.parent; c != null; c = c.parent) {
            if (!c.isVisible())
                return false;
        }
        target._selectedItem = target._itemForTouch(touch);
        if (target._selectedItem) {
            target._state = cc.MENU_STATE_TRACKING_TOUCH;
            target._selectedItem.selected();
            return true;
        }
        return false;
    },
    _onTouchEnded: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchEnded(): invalid state");
            return;
        }
        if (target._selectedItem) {
            target._selectedItem.unselected();
            target._selectedItem.activate();
        }
        target._state = cc.MENU_STATE_WAITING;
    },
    _onTouchCancelled: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchCancelled(): invalid state");
            return;
        }
        if (this._selectedItem)
            target._selectedItem.unselected();
        target._state = cc.MENU_STATE_WAITING;
    },
    _onTouchMoved: function (touch, event) {
        var target = event.getCurrentTarget();
        if (target._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchMoved(): invalid state");
            return;
        }
        var currentItem = target._itemForTouch(touch);
        if (currentItem != target._selectedItem) {
            if (target._selectedItem)
                target._selectedItem.unselected();
            target._selectedItem = currentItem;
            if (target._selectedItem)
                target._selectedItem.selected();
        }
    },
    onExit: function () {
        if (this._state == cc.MENU_STATE_TRACKING_TOUCH) {
            if (this._selectedItem) {
                this._selectedItem.unselected();
                this._selectedItem = null;
            }
            this._state = cc.MENU_STATE_WAITING;
        }
        cc.Node.prototype.onExit.call(this);
    },
    setOpacityModifyRGB: function (value) {
    },
    isOpacityModifyRGB: function () {
        return false;
    },
    _itemForTouch: function (touch) {
        var touchLocation = touch.getLocation();
        var itemChildren = this._children, locItemChild;
        if (itemChildren && itemChildren.length > 0) {
            for (var i = itemChildren.length - 1; i >= 0; i--) {
                locItemChild = itemChildren[i];
                if (locItemChild.isVisible() && locItemChild.isEnabled()) {
                    var local = locItemChild.convertToNodeSpace(touchLocation);
                    var r = locItemChild.rect();
                    r.x = 0;
                    r.y = 0;
                    if (cc.rectContainsPoint(r, local))
                        return locItemChild;
                }
            }
        }
        return null;
    }
});
var _p = cc.Menu.prototype;
_p.enabled;
cc.Menu.create = function (menuItems) {
    var argc = arguments.length;
    if ((argc > 0) && (arguments[argc - 1] == null))
        cc.log("parameters should not be ending with null in Javascript");
    var ret;
    if (argc == 0)
        ret = new cc.Menu();
    else if (argc == 1)
        ret = new cc.Menu(menuItems);
    else
        ret = new cc.Menu(Array.prototype.slice.call(arguments, 0));
    return ret;
};
